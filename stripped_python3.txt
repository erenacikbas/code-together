this is the print version of non-programmer's tutorial for python 3you won't see this message or any elements not part of the book's content when you print or preview this page. non-programmer's tutorial for python 3 the current, editable version of this book is available in wikibooks, the open-content textbooks collection, at https://en.wikibooks.org/wiki/non-programmer%27s_tutorial_for_python_3 permission is granted to copy, distribute, and/or modify this document under the terms of the creative commons attribution-sharealike 3.0 license. contents 1 1. front matter 1.1 other resources 2 2. intro 2.1 first things first 2.2 installing python 2.2.1 linux, bsd, and unix users 2.2.2 mac users 2.2.3 windows users 2.2.3.1 configuring your path environment variable 2.3 interactive mode 2.4 creating and running programs 2.4.1 program file names 2.5 using python from the command line 2.5.1 running python programs in *nix 2.6 where to get help 2.6.1 python documentation 2.6.2 python user community 3 3. hello, world 3.1 what you should know 3.2 printing 3.2.1 terminology 3.3 expressions 3.3.1 arithmetic expressions 3.4 commenting in python 3.5 examples 3.6 exercises 3.6.1 footnotes 4 4. who goes there? 4.1 input and variables 4.2 assignment 4.3 examples 4.4 exercises 5 5. count to 10 5.1 while loops 5.1.1 infinite loops or never ending loop 5.2 examples 5.2.1 fibonacci sequence 5.2.2 enter password 5.3 exercises 6 6. decisions 6.1 if statement 6.2 examples 6.3 exercises 7 7. debugging 7.1 what is debugging? 7.2 what should the program do? 7.3 what does the program do? 7.4 how do i fix my program? 8 8. defining functions 8.1 creating functions 8.2 variables in functions 8.3 examples 8.4 exercises 9 9. advanced functions example 9.1 recursion 9.2 examples 10 10. lists 10.1 variables with more than one value 10.2 more features of lists 10.3 examples 10.4 exercises 11 11. for loops 12 12. boolean expressions 12.1 a note on boolean operators 12.2 examples 12.3 exercises 13 13. dictionaries 14 14. using modules 14.1 exercises 14.2 other modules 14.2.1 creating your own module 14.2.1.1 the __name__ == __main__ trick 14.2.2 the pip module 15 15. more on lists 16 16. revenge of the strings 16.1 slicing strings (and lists) 16.2 examples 17 17. file io 17.1 file i/o 17.2 advanced use of .txt files 17.3 exercises 18 18. dealing with the imperfect 18.1 ...or how to handle errors 18.2 closing files with with 18.3 catching errors with try 18.4 exercises 19 19. the end 20 20. faq 1. front matter all example python source code in this tutorial is granted to the public domain. therefore you may modify it and relicense it under any license you please. since you are expected to learn programming, the creative commons attribution-sharealike license would require you to keep all programs that are derived from the source code in this tutorial under that license. since the python source code is granted to the public domain, that requirement is waived. this tutorial is more or less a conversion of non-programmer's tutorial for python 2.6. older versions and some versions in korean, spanish, italian and greek are available from http://jjc.freeshell.org/easytut/ the non-programmers' tutorial for python 3 is a tutorial designed to be an introduction to the python programming language. this guide is for someone with no programming experience. if you have programmed in other languages i recommend using python tutorial for programmers written by guido van rossum. if you have any questions or comments please use the discussion pages or see authors page for author contact information. i welcome questions and comments about this tutorial. i will try to answer any questions you have as best i can. thanks go to james a. brown for writing most of the windows install info. thanks also to elizabeth cogliati for complaining enough :) about the original tutorial (that is almost unusable for a non-programmer), for proofreading, and for many ideas and comments on it. thanks to joe oppegaard for writing almost all the exercises. thanks to everyone i have missed. other resources python home page python 3 documentation a byte of python by swaroop c h porting to python 3: an in-depth guide non-programmer's tutorial for python 3 ← authors print version intro → 2. intro first things first so, you've never programmed before. as we go through this tutorial, i will attempt to teach you how to program. there really is only one way to learn to program. you must read code and write code (as computer programs are often called). i'm going to show you lots of code. you should type in code that i show you to see what happens. play around with it and make changes. the worst that can happen is that it won't work. when i type in code it will be formatted like this: # python is easy to learn print("hello, world!") that's so it is easy to distinguish from the other text. if you're reading this on the web, you'll notice the code is in color -- that's just to make it stand out, and to make the different parts of the code stand out from each other. the code you enter will probably not be colored, or the colors may be different, but it won't affect the code as long as you enter it the same way as it's printed here. if the computer prints something out it will be formatted like this: hello, world! (note that printed text goes to your screen, and does not involve paper. before computers had screens, the output of computer programs would be printed on paper.) note that this is a python 3 tutorial, which means that most of the examples will not work in python 2.7 and before. as well, all but a small number of the extra python 2.7 libraries (third-party libraries) have been converted to python 3. most likely you will want to learn python 3, but if you are learning python for a specific package or set of modules that are only written in python 2.7, you may want to consider learning from the non-programmer's tutorial for python 2.6. however, the differences between python 2 and 3 are not particularly large, so if you learn one, you should be able to read programs written for the other without much difficulty. there will often be a mixture of the text you type (which is shown in bold) and the text the program prints to the screen, which would look like this: halt! who goes there? josh you may pass, josh (some of the tutorial has not been converted to this format. since this is a wiki, you can convert it when you find it.) i will also introduce you to the terminology of programming - for example, that programming is often referred to as coding or hacking. this will not only help you understand what programmers are talking about, but also help the learning process. now, on to more important things. in order to program in python you need the python 3 software. if you don't already have the python software go to www.python.org/download and get the proper version for your platform. download it, read the instructions and get it installed. installing python for python programming you need a working python installation and a text editor. python comes with its own editor, idle, which is quite nice and totally sufficient for the beginning. as you get more into programming, you will probably switch to some other editor like nano, emacs, vi or another. the python download page is http://www.python.org/download. the most recent version is python 3.8.5 (as of july 2020); python 2.7 and older versions will not work with this tutorial. there are various different installation files for different computer platforms available on the download site. here are some specific instructions for the most common operating systems: linux, bsd, and unix users you are probably lucky and python is already installed on your machine. to test it type python3 on a command line. if you see something like what is shown in the following section, you are set. idle may need to be installed separately, from its own package such as idle3 or as part of python-tools. if you have to install python, first try to use the operating system's package manager or go to the repository where your packages are available and get python 3. python 3.0 was released in december 2008; all distributions should have python 3 available, so you may not need to compile it from scratch. ubuntu and fedora do have python 3 binary packages available, but they are not yet the default, so they need to be installed specially. roughly, here are the steps to compile python from source code in unix (if these totally don't make sense, you may want to read another introduction to *nix, such as introduction to linux): download the .tgz file (use your web browser to get the gzipped tar file from https://www.python.org/ftp/python/3.7.4/python-3.7.4.tgz) uncompress the tar file (put in the correct path to where you downloaded it): $ tar -xvzf ~/download/python-3.7.4.tgz ... list of files as they are uncompressed change to the directory and tell the computer to compile and install the program $ cd python-3.7/ $ ./configure --prefix=$home/python3_install ... lots of output. watch for error messages here ... $ make ... even more output. hopefully no error messages ... $ make install add python 3 to your path. you can test it first by specifying the full path. you should add $home/python3_install/bin to your path bash variable. $ ~/python3_install/bin/python3 python 3.7.4 (... size and date information ...) [gcc 9.1.0] on linux type "help", "copyright", "credits" or "license" for more information. >>> the above commands will install python 3 to your home directory, which is probably what you want, but if you skip the --prefix=$home/python3_install, it will install it to /usr/local. if you want to use the idle graphical code editor, you need to make sure that the tk and tcl libraries, together with their development files, are installed on the system. you will get a warning during the make phase if these are not available. mac users starting from mac os x tiger (10.4), versions of python 2 shipped with the operating system by default, but you will need to also install python 3 unless mac os starts including python 3 (check the version by starting python3 in a command line terminal). also idle (the python editor) might be missing in the standard installation. if you want to (re-)install python, get the mac os installer from the python download site. windows users download the appropriate windows installer (the x86 msi installer, if you do not have a 64-bit amd or intel chip). start the installer by double-clicking it and follow the prompts. see https://docs.python.org/3/using/windows.html#installing-python for more information. configuring your path environment variable the path environment variable is a list of folders, separated by semicolons, in which windows will look for a program whenever you try to execute one by typing its name at a command prompt. you can see the current value of your path by typing this command at a command prompt: echo %path% the easiest way to permanently change environment variables is to bring up the built-in environment variable editor in windows. how you get to this editor is slightly different on different versions of windows. on windows 8 or windows 10: press the windows key and type control panel to locate the windows control panel. once you've opened the control panel, select view by: large icons, then click on system. in the window that pops up, click the advanced system settings link, then click the environment variables... button. on windows 7 or vista: click the start button in the lower-left corner of the screen, move your mouse over computer, right-click, and select properties from the pop-up menu. click the advanced system settings link, then click the environment variables... button. once you've brought up the environment variable editor, you'll do the same thing regardless of which version of windows you're running. under system variables in the bottom half of the editor, find a variable called path. if there is is one, select it and click edit.... assuming your python root is c:\python37, add these two folders to your path (and make sure you get the semicolons right; there should be a semicolon between each folder in the list): c:\python37 c:\python37\scripts note: if you want to double-click and start your python programs from a windows folder and not have the console window disappear, you can add the following code to the bottom of each script: #stops console from exiting end_prog = "" while end_prog != "q": end_prog = input("type q to quit") interactive mode go into idle (also called the python gui). you should see a window that has some text like this: python 3.0 (r30:67503, dec 29 2008, 21:31:07) [gcc 4.3.2 20081105 (red hat 4.3.2-7)] on linux2 type "copyright", "credits" or "license()" for more information. **************************************************************** personal firewall software may warn about the connection idle makes to its subprocess using this computer's internal loopback interface. this connection is not visible on any external interface and no data is sent to or received from the internet. **************************************************************** idle 3.0 >>> the >>> is python's way of telling you that you are in interactive mode. in interactive mode what you type is immediately run. try typing 1+1 in. python will respond with 2. interactive mode allows you to test out and see what python will do. if you ever feel you need to play with new python statements, go into interactive mode and try them out. creating and running programs go into idle if you are not already. in the menu at the top, select file then new file. in the new window that appears, type the following: print("hello, world!") now save the program: select file from the menu, then save. save it as "hello.py" (you can save it in any folder you want). now that it is saved it can be run. next run the program by going to run then run module (or if you have an older version of idle use edit then run script). this will output hello, world! on the *python shell* window. for a more in-depth introduction to idle, a longer tutorial with screenshots can be found at http://hkn.eecs.berkeley.edu/~dyoo/python/idle_intro/index.html. program file names it is very useful to stick to some rules regarding the file names of python programs. otherwise some things might go wrong unexpectedly. these don't matter as much for programs, but you can have weird problems if you don't follow them for module names (modules will be discussed later). always save the program with the extension .py. do not put another dot anywhere else in the file name. only use standard characters for file names: letters, numbers, dash (-) and underscore (_). white space (" ") should not be used at all (use underscores instead). do not use anything other than a letter (particularly no numbers!) at the beginning of a file name. do not use "non-english" characters (such as å, ɓ, ç, ð, é, õ, ü) in your file names—or, even better, do not use them at all when programming. do not use module names for file names (such as print.py, math.py, list.py) using python from the command line if you don't want to use python from the command line, you don't have to, just use idle. to get into interactive mode just type python3 without any arguments. to run a program, create it with a text editor (emacs has a good python mode) and then run it with python3 program_name. running python programs in *nix if you are using unix (such as linux, mac os, or bsd), if you make the program executable with chmod, and have as the first line: #!/usr/bin/env python3 you can run the python program with ./hello.py like any other command. where to get help at some point in your python career you will probably get stuck and have no clue about how to solve the problem you are supposed to work on. this tutorial only covers the basics of python programming, but there is a lot of further information available. python documentation first of all, python is very well documented. there might even be copies of these documents on your computer that came with your python installation: the official python 3 tutorial by guido van rossum is often a good starting point for general questions. for questions about standard modules (you will learn what these are later), the python 3 library reference is the place to look. if you really want to get to know something about the details of the language, the python 3 reference manual is comprehensive but quite complex for beginners. python user community there are a lot of other python users out there, and usually they are nice and willing to help you. this very active user community is organised mostly through mailing lists and a newsgroup: the tutor mailing list is for folks who want to ask questions regarding how to learn computer programming with the python language. the python-help mailing list is python.org's help desk. you can ask a group of knowledgeable volunteers questions about all your python problems. the python newsgroup comp.lang.python (google groups archive) is the place for general python discussions, questions and the central meeting point of the community. python wiki has a list of local user groups, you can join the group mailing list and ask questions. you can also participate in the user group meetings. learnpython subreddit is another location where beginner level questions can be asked. in order not to reinvent the wheel and discuss the same questions again and again, people will appreciate very much if you do a web search for a solution to your problem before contacting these lists! non-programmer's tutorial for python 3 ← front matter print version hello, world → 3. hello, world what you should know once you've read and mastered this chapter, you should know how to edit programs in a text editor or idle, save them to the hard disk, and run them once they have been saved. printing programming tutorials since the beginning of time have started with a little program called "hello, world!"[1] so here it is: print("hello, world!") if you are using the command line to run programs then type it in with a text editor, save it as hello.py and run it with python3 hello.py otherwise go into idle, create a new window, and create the program as in section creating and running programs. when this program is run here's what it prints: hello, world! now i'm not going to tell you this every time, but when i show you a program i recommend that you type it in and run it. i learn better when i type it in and you probably do too. now here is a more complicated program: print("jack and jill went up a hill") print("to fetch a pail of water;") print("jack fell down, and broke his crown,") print("and jill came tumbling after.") when you run this program it prints out: jack and jill went up a hill to fetch a pail of water; jack fell down, and broke his crown, and jill came tumbling after. when the computer runs this program it first sees the line: print("jack and jill went up a hill") so the computer prints: jack and jill went up a hill then the computer goes down to the next line and sees: print("to fetch a pail of water;") so the computer prints to the screen: to fetch a pail of water; the computer keeps looking at each line, follows the command and then goes on to the next line. the computer keeps running commands until it reaches the end of the program. terminology now is probably a good time to give you a bit of an explanation of what is happening - and a little bit of programming terminology. what we were doing above was using a function called print. the function's name - print - is followed by parentheses containing zero or more arguments. so in this example print("hello, world!") there is one argument, which is "hello, world!". note that this argument is a group of characters enclosed in double quotes (""). this is commonly referred to as a string of characters, or string, for short. another example of a string is "jack and jill went up a hill". the combination of a function and parentheses with the arguments is a function call. a function and its arguments are one type of statement that python has, so print("hello, world!") is an example of a statement. basically, you can think of a statement as a single line in a program. that's probably more than enough terminology for now. expressions here is another program: print("2 + 2 is", 2 + 2) print("3 * 4 is", 3 * 4) print("100 - 1 is", 100 - 1) print("(33 + 2) / 5 + 11.5 is", (33 + 2) / 5 + 11.5) and here is the output when the program is run: 2 + 2 is 4 3 * 4 is 12 100 - 1 is 99 (33 + 2) / 5 + 11.5 is 18.5 as you can see, python can turn your thousand-dollar computer into a five-dollar calculator. arithmetic expressions in this example, the print function is followed by two arguments, with each of the arguments separated by a comma. so with the first line of the program print("2 + 2 is", 2 + 2) the first argument is the string "2 + 2 is" and the second argument is the arithmetic expression 2 + 2, which is one kind of expression. what is important to note is that a string is printed as is (without the enclosing double quotes), but an expression is evaluated, or converted to its actual value. python has seven basic operations for numbers: operation symbol example power (exponentiation) ** 5 ** 2 == 25 multiplication * 2 * 3 == 6 division / 14 / 3 == 4.666666666666667 integer division // 14 // 3 == 4 remainder (modulo) % 14 % 3 == 2 addition + 1 + 2 == 3 subtraction - 4 - 3 == 1 notice that there are two ways to do division, one that returns the repeating decimal, and the other that can get the remainder and the whole number. the order of operations is the same as in math: parentheses () exponents ** multiplication *, division /, integer division //, and remainder % addition + and subtraction - so use parentheses to structure your formulas when needed. commenting in python often in programming, you are doing something complicated and may not in the future remember what you did. when this happens the program should probably be commented. a comment is a note to you and other programmers explaining what is happening. for example: # not quite pi, but a credible simulation print(22 / 7) which outputs 3.14285714286 notice that the comment starts with a hash: #. comments are used to communicate with others who read the program and your future self to make clear what is complicated. note that any text can follow comment and that when the program is run, the text after the # through to the end of that line is ignored. the # does not have to be at the beginning of a new line: # output pi on the screen print(22 / 7) # well, just a good approximation examples each chapter (eventually) will contain examples of the programming features introduced in the chapter. you should at least look over them and see if you understand them. if you don't, you may want to type them in and see what happens. mess around with them, change them and see what happens. denmark.py print("something's rotten in the state of denmark.") print(" -- shakespeare") output: something's rotten in the state of denmark. -- shakespeare school.py # this is not quite true outside of usa # and is based on my dim memories of my younger years print("firstish grade") print("1 + 1 =", 1 + 1) print("2 + 4 =", 2 + 4) print("5 - 2 =", 5 - 2) print() print("thirdish grade") print("243 - 23 =", 243 - 23) print("12 * 4 =", 12 * 4) print("12 / 3 =", 12 / 3) print("13 / 3 =", 13 // 3, "r", 13 % 3) print() print("junior high") print("123.56 - 62.12 =", 123.56 - 62.12) print("(4 + 3) * 2 =", (4 + 3) * 2) print("4 + 3 * 2 =", 4 + 3 * 2) print("3 ** 2 =", 3 ** 2) output: firstish grade 1 + 1 = 2 2 + 4 = 6 5 - 2 = 3 thirdish grade 243 - 23 = 220 12 * 4 = 48 12 / 3 = 4 13 / 3 = 4 r 1 junior high 123.56 - 62.12 = 61.44 (4 + 3) * 2 = 14 4 + 3 * 2 = 10 3 ** 2 = 9 exercises write a program that prints your full name and your birthday as separate strings. write a program that shows the use of all 7 arithmetic operations. solution 1. write a program that prints your full name and your birthday as separate strings. print("ada lovelace", "born on", "november 27, 1852") print("albert einstein", "born on", "14 march 1879") print(("john smith"), ("born on"), ("14 march 1879")) solution 2. write a program that shows the use of all 7 arithmetic operations. print("5**5 = ", 5**5) print("6*7 = ", 6*7) print("56/8 = ", 56/8) print("14//6 = ", 14//6) print("14%6 = ", 14%6) print("5+6 = ", 5+6) print("9-0 = ", 9-0) footnotes ↑ here is a great list of the famous "hello, world!" program in many programming languages. just so you know how simple python can be... non-programmer's tutorial for python 3 ← intro print version who goes there? → 4. who goes there? input and variables now i feel it is time for a really complicated program. here it is: print("halt!") user_input = input("who goes there? ") print("you may pass,", user_input) when i ran it, here is what my screen showed: halt! who goes there? josh you may pass, josh note: after running the code by pressing f5, the python shell will only give output: halt! who goes there? you need to enter your name in the python shell, and then press enter for the rest of the output. of course when you run the program your screen will look different because of the input() statement. when you ran the program you probably noticed (you did run the program, right?) how you had to type in your name and then press enter. then the program printed out some more text and also your name. this is an example of input. the program reaches a certain point and then waits for the user to input some data that the program can use later. of course, getting information from the user would be useless if we didn't have anywhere to put that information and this is where variables come in. in the previous program user_input is a variable. variables are like a box that can store some piece of data. here is a program to show examples of variables: a = 123.4 b23 = 'spam' first_name = "bill" b = 432 c = a + b print("a + b is",c) print("first_name is",first_name) print("sorted parts, after midnight or",b23) and here is the output: a + b is 555.4 first_name is bill sorted parts, after midnight or spam variables store data. the variables in the above program are a, b23, first_name, b, and c. the two basic types are strings and numbers. strings are a sequence of letters, numbers and other characters. in this example b23 and first_name are variables that are storing strings. spam, bill, a + b is, first_name is, and sorted parts, after midnight or are the strings in this program. the characters are surrounded by " or '. the other type of variables are numbers. remember that variables are used to store a value, they do not use quotation marks (" and '). if you want to use an actual value, you must use quotation marks. value1 == pim value2 == "pim" both look the same, but in the first one python checks if the value stored in the variable value1 is the same as the value stored in the variable pim. in the second one, python checks if the string (the actual letters p,i, and m) are the same as in value2 (continue this tutorial for more explanation about strings and about the ==). assignment okay, so we have these boxes called variables and also data that can go into the variable. the computer will see a line like first_name = "bill" and it reads it as "put the string bill into the box (or variable) first_name". later on it sees the statement c = a + b and it reads it as "put the sum of a + b or 123.4 + 432 which equals 555.4 into c". the right hand side of the statement (a + b) is evaluated and the result is stored in the variable on the left hand side (c). this is called assignment, and you should not confuse the assignment equal sign (=) with "equality" in a mathematical sense here (that's what == will be used for later). here is another example of variable usage: a = 1 print(a) a = a + 1 print(a) a = a * 2 print(a) and of course here is the output: 1 2 4 even if the same variable appears on both sides of the equals sign (e.g., spam = spam), the computer still reads it as, "first find out the data to store and then find out where the data goes." one more program before i end this chapter: number = float(input("type in a number: ")) integer = int(input("type in an integer: ")) text = input("type in a string: ") print("number =", number) print("number is a", type(number)) print("number * 2 =", number * 2) print("integer =", integer) print("integer is a", type(integer)) print("integer * 2 =", integer * 2) print("text =", text) print("text is a", type(text)) print("text * 2 =", text * 2) the output i got was: type in a number: 12.34 type in an integer: -3 type in a string: hello number = 12.34 number is a <class 'float'> number * 2 = 24.68 integer = -3 integer is a <class 'int'> integer * 2 = -6 text = hello text is a <class 'str'> text * 2 = hellohello notice that number was created with float(input()) ,int(input()) returns an integer, a number with no decimal point, while text created with input() returns a string(can be writen as str(input()), too). when you want the user to type in a decimal use float(input()), if you want the user to type in an integer use int(input()), but if you want the user to type in a string use input(). the second half of the program uses the type() function which tells what kind a variable is. numbers are of type int or float, which are short for integer and floating point (mostly used for decimal numbers), respectively. text strings are of type str, short for string. integers and floats can be worked on by mathematical functions, strings cannot. notice how when python multiplies a number by an integer the expected thing happens. however when a string is multiplied by an integer the result is that multiple copies of the string are produced (i.e., text * 2 = hellohello). operations with strings do different things than operations with numbers. as well, some operations only work with numbers (both integers and floating point numbers) and will give an error if a string is used. here are some interactive mode examples to show that some more. >>> print("this" + " " + "is" + " joined.") this is joined. >>> print("ha, " * 5) ha, ha, ha, ha, ha, >>> print("ha, " * 5 + "ha!") ha, ha, ha, ha, ha, ha! >>> print(3 - 1) 2 >>> print("3" - "1") traceback (most recent call last): file "<stdin>", line 1, in <module> typeerror: unsupported operand type(s) for -: 'str' and 'str' >>> here is the list of some string operations: operation symbol example repetition * "i" * 5 == "iiiii" concatenation + "hello, " + "world!" == "hello, world!" examples rate_times.py # this program calculates rate and distance problems print("input a rate and a distance") rate = float(input("rate: ")) distance = float(input("distance: ")) time=(distance/ rate) print("time:", time) sample runs: input a rate and a distance rate: 5 distance: 10 time: 2.0 input a rate and a distance rate: 3.52 distance: 45.6 time: 12.9545454545 area.py # this program calculates the perimeter and area of a rectangle print("calculate information about a rectangle") length = float(input("length: ")) width = float(input("width: ")) perimeter=(2 * length + 2 * width) print("area:", length * width) print("perimeter:",perimeter) sample runs: calculate information about a rectangle length: 4 width: 3 area: 12.0 perimeter: 14.0 calculate information about a rectangle length: 2.53 width: 5.2 area: 13.156 perimeter: 15.46 temperature.py # this program converts fahrenheit to celsius fahr_temp = float(input("fahrenheit temperature: ")) celc_temp = (fahr_temp - 32.0) *( 5.0 / 9.0) print("celsius temperature:", celc_temp) sample runs: fahrenheit temperature: 32 celsius temperature: 0.0 fahrenheit temperature: -40 celsius temperature: -40.0 fahrenheit temperature: 212 celsius temperature: 100.0 fahrenheit temperature: 98.6 celsius temperature: 37.0 exercises write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. solution write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. string1 = input('string 1: ') string2 = input('string 2: ') float1 = float(input('number 1: ')) float2 = float(input('number 2: ')) print(string1 + string2) print(float1 * float2) non-programmer's tutorial for python 3 ← hello, world print version count to 10 → 5. count to 10 while loops presenting our first control structure. ordinarily the computer starts with the first line and then goes down from there. control structures change the order that statements are executed or decide if a certain statement will be run. here's the source for a program that uses the while control structure: a = 0 # first, set the initial value of the variable a to 0(zero). while a < 10: # while the value of the variable a is less than 10 do the following: a = a + 1 # increase the value of the variable a by 1, as in: a = a + 1! print(a) # print to screen what the present value of the variable a is. # repeat! until the value of the variable a is equal to 9!? see note. # note: # the value of the variable a will increase by 1 # with each repeat, or loop of the 'while statement block'. # e.g. a = 1 then a = 2 then a = 3 etc. until a = 9 then... # the code will finish adding 1 to a (now a = 10), printing the # result, and then exiting the 'while statement block'. # -- # while a < 10: | # a = a + 1 |<--[ the while statement block ] # print (a) | # -- and here is the extremely exciting output: 1 2 3 4 5 6 7 8 9 10 (and you thought it couldn't get any worse after turning your computer into a five-dollar calculator?) so what does the program do? first it sees the line a = 0 and sets a to zero. then it sees while a < 10: and so the computer checks to see if a < 10. the first time the computer sees this statement, a is zero, so it is less than 10. in other words, as long as a is less than ten, the computer will run the tabbed in statements. this eventually makes a equal to ten (by adding one to a again and again) and the while a < 10 is not true any longer. reaching that point, the program will stop running the indented lines. always remember to put a colon ":" at the end of the while statement line! here is another example of the use of while: a = 1 s = 0 print('enter numbers to add to the sum.') print('enter 0 to quit.') while a != 0: print('current sum:', s) a = float(input('number? ')) s = s + a print('total sum =', s) enter numbers to add to the sum. enter 0 to quit. current sum: 0 number? 200 current sum: 200.0 number? -15.25 current sum: 184.75 number? -151.85 current sum: 32.9 number? 10.00 current sum: 42.9 number? 0 total sum = 42.9 notice how print('total sum =', s) is only run at the end. the while statement only affects the lines that are indented with whitespace. the != means does not equal so while a != 0: means as long as a is not zero run the tabbed statements that follow. note that a is a floating point number, and not all floating point numbers can be accurately represented, so using != on them can sometimes not work. try typing in 1.1 in interactive mode. infinite loops or never ending loop now that we have while loops, it is possible to have programs that run forever. an easy way to do this is to write a program like this: while 1 == 1: print("help, i'm stuck in a loop.") the "==" operator is used to test equality of the expressions on the two sides of the operator, just as "<" was used for "less than" before (you will get a complete list of all comparison operators in the next chapter). this program will output help, i'm stuck in a loop. until the heat death of the universe or you stop it, because 1 will forever be equal to 1. the way to stop it is to hit the control (or ctrl) button and c (the letter) at the same time. this will kill the program. (note: sometimes you will have to hit enter after the control-c.) on some systems, nothing will stop it, short of killing the process--so avoid! examples fibonacci sequence fibonacci-method1.py # this program calculates the fibonacci sequence a = 0 b = 1 count = 0 max_count = 20 while count < max_count: count = count + 1 print(a, end=" ") # notice the magic end=" " in the print function arguments # that keeps it from creating a new line. old_a = a # we need to keep track of a since we change it. a = b b = old_a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 note that the output is on a single line because of the extra argument end=" " in the print arguments. fibonacci-method2.py # simplified and faster method to calculate the fibonacci sequence a = 0 b = 1 count = 0 max_count = 10 while count < max_count: count = count + 1 print(a, b, end=" ") # notice the magic end=" " a = a + b b = a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 fibonacci-method3.py a = 0 b = 1 count = 0 maxcount = 20 #once loop is started we stay in it while count < maxcount: count += 1 olda = a a = a + b b = olda print(olda,end=" ") print() output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 enter password password.py # waits until a password has been entered. use control-c to break out without # the password #note that this must not be the password so that the # while loop runs at least once. password = str() # note that != means not equal while password != "unicorn": password = input("password: ") print("welcome in") sample run: password: auo password: y22 password: password password: open sesame password: unicorn welcome in exercises write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. solution write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. name = input("what is your username: ") password = input("what is your password: ") print("to lock your computer type lock.") command = none input1 = none input2 = none while command != "lock": command = input("what is your command: ") while input1 != name: input1 = input("what is your username: ") while input2 != password: input2 = input("what is your password: ") print("welcome back to your system!") if you would like the program to run continuously, just add a while 1 == 1: loop around the whole thing. you will have to indent the rest of the program when you add this at the top of the code, but don't worry, you don't have to do it manually for each line! just highlight everything you want to indent and click on "indent" under "format" in the top bar of the python window. another way of doing this could be: name = input('set name: ') password = input('set password: ') while 1 == 1: nameguess="" passwordguess="" key="" while (nameguess != name) or (passwordguess != password): nameguess = input('name? ') passwordguess = input('password? ') print("welcome,", name, ". type lock to lock.") while key != "lock": key = input("") notice the or in while (nameguess != name) or (passwordguess != password), which we haven't yet introduced. you can probably figure out how it works. non-programmer's tutorial for python 3 ← who goes there? print version decisions → 6. decisions if statement as always, i believe i should start each chapter with a warm-up typing exercise, so here is a short program to compute the absolute value of an integer: n = int(input("number? ")) if n < 0: print("the absolute value of", n, "is", -n) else: print("the absolute value of", n, "is", n) here is the output from the two times that i ran this program: number? -34 the absolute value of -34 is 34 number? 1 the absolute value of 1 is 1 so what does the computer do when it sees this piece of code? first it prompts the user for a number with the statement "n = int(input("number? "))". next it reads the line "if n < 0:". if n is less than zero python runs the line "print("the absolute value of", n, "is", -n)". otherwise it runs the line "print("the absolute value of", n, "is", n)". more formally python looks at whether the expression n < 0 is true or false. an if statement is followed by an indented block of statements that are run when the expression is true. optionally after the if statement is an else statement and another indented block of statements. this second block of statements is run if the expression is false. there are a number of different tests that an expression can have. here is a table of all of them: operator function < less than <= less than or equal to > greater than >= greater than or equal to == equal != not equal another feature of the if command is the elif statement. it stands for else if and means if the original if statement is false but the elif part is true, then do the elif part. and if neither the if or elif expressions are true, then do what's in the else block. here's an example: a = 0 while a < 10: a = a + 1 if a > 5: print(a, ">", 5) elif a <= 3: print(a, "<=", 3) else: print("neither test was true") and the output: 1 <= 3 2 <= 3 3 <= 3 neither test was true neither test was true 6 > 5 7 > 5 8 > 5 9 > 5 10 > 5 notice how the elif a <= 3 is only tested when the if statement fails to be true. there can be more than one elif expression, allowing multiple tests to be done in a single if statement. examples # this program demonstrates the use of the == operator # using numbers print(5 == 6) # using variables x = 5 y = 8 print(x == y) and the output false false high_low.py # plays the guessing game higher or lower # this should actually be something that is semi random like the # last digits of the time or something else, but that will have to # wait till a later chapter. (extra credit, modify it to be random # after the modules chapter) number = 7 guess = -1 print("guess the number!") while guess != number: guess = int(input("is it... ")) if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") sample run: guess the number! is it... 2 it's bigger... is it... 5 it's bigger... is it... 10 it's not so big. is it... 7 hooray! you guessed it right! even.py # asks for a number. # prints if it is even or odd number = float(input("tell me a number: ")) if number % 2 == 0: print(int(number), "is even.") elif number % 2 == 1: print(int(number), "is odd.") else: print(number, "is very strange.") sample runs: tell me a number: 3 3 is odd. tell me a number: 2 2 is even. tell me a number: 3.4895 3.4895 is very strange. average1.py # keeps asking for numbers until 0 is entered. # prints the average value. count = 0 sum = 0.0 number = 1 # set to something that will not exit the while loop immediately. print("enter 0 to exit the loop") while number != 0: number = float(input("enter a number: ")) if number != 0: count = count + 1 sum = sum + number if number == 0: print("the average was:", sum / count) sample runs sample runs: enter 0 to exit the loop enter a number: 3 enter a number: 5 enter a number: 0 the average was: 4.0 enter 0 to exit the loop enter a number: 1 enter a number: 4 enter a number: 3 enter a number: 0 the average was: 2.66666666667 average2.py # keeps asking for numbers until count numbers have been entered. # prints the average value. #notice that we use an integer to keep track of how many numbers, # but floating point numbers for the input of each number sum = 0.0 print("this program will take several numbers then average them") count = int(input("how many numbers would you like to average: ")) current_count = 0 while current_count < count: current_count = current_count + 1 print("number", current_count) number = float(input("enter a number: ")) sum = sum + number print("the average was:", sum / count) sample runs: this program will take several numbers then average them how many numbers would you like to average: 2 number 1 enter a number: 3 number 2 enter a number: 5 the average was: 4.0 this program will take several numbers then average them how many numbers would you like to average: 3 number 1 enter a number: 1 number 2 enter a number: 4 number 3 enter a number: 3 the average was: 2.66666666667 exercises write a program that asks the user their name, if they enter your name say "that is a nice name", if they enter "john cleese" or "michael palin", tell them how you feel about them ;), otherwise tell them "you have a nice name." solution name = input('your name: ') if name == 'bryn': print('that is a nice name.') elif name == 'john cleese': print('... some funny text.') elif name == 'michael palin': print('... some funny text.') else: print('you have a nice name.') modify the higher or lower program from this section to keep track of how many times the user has entered the wrong number. if it is more than 3 times, print "that must have been complicated." at the end, otherwise print "good job!" solution number = 7 guess = -1 count = 0 print("guess the number!") while guess != number: guess = int(input("is it... ")) count = count + 1 if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") if count > 3: print("that must have been complicated.") else: print("good job!") write a program that asks for two numbers. if the sum of the numbers is greater than 100, print "that is a big number." solution number1 = float(input('1st number: ')) number2 = float(input('2nd number: ')) if number1 + number2 > 100: print('that is a big number.') non-programmer's tutorial for python 3 ← count to 10 print version debugging → 7. debugging what is debugging? "as soon as we started programming, we found to our surprise that it wasn't as easy to get programs right as we had thought. debugging had to be discovered. i can remember the exact instant when i realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs." — maurice wilkes discovers debugging, 1949 by now if you have been messing around with the programs you have probably found that sometimes the program does something you didn't want it to do. this is fairly common. debugging is the process of figuring out what the computer is doing and then getting it to do what you want it to do. this can be tricky. i once spent nearly a week tracking down and fixing a bug that was caused by someone putting an x where a y should have been. this chapter will be more abstract than previous chapters. what should the program do? the first thing to do (this sounds obvious) is to figure out what the program should be doing if it is running correctly. come up with some test cases and see what happens. for example, let's say i have a program to compute the perimeter of a rectangle (the sum of the length of all the edges). i have the following test cases: height width perimeter 3 4 14 2 3 10 4 4 16 2 2 8 5 1 12 i now run my program on all of the test cases and see if the program does what i expect it to do. if it doesn't then i need to find out what the computer is doing. more commonly some of the test cases will work and some will not. if that is the case you should try and figure out what the working ones have in common. for example here is the output for a perimeter program (you get to see the code in a minute): height: 3 width: 4 perimeter = 15 height: 2 width: 3 perimeter = 11 height: 4 width: 4 perimeter = 16 height: 2 width: 2 perimeter = 8 height: 5 width: 1 perimeter = 8 notice that it didn't work for the first two inputs, it worked for the next two and it didn't work on the last one. try and figure out what is in common with the working ones. once you have some idea what the problem is finding the cause is easier. with your own programs you should try more test cases if you need them. what does the program do? the next thing to do is to look at the source code. one of the most important things to do while programming is reading source code. the primary way to do this is code walkthroughs. a code walkthrough starts at the first line, and works its way down until the program is done. while loops and if statements mean that some lines may never be run and some lines are run many times. at each line you figure out what python has done. lets start with the simple perimeter program. don't type it in, you are going to read it, not run it. the source code is: height = int(input("height: ")) width = int(input("width: ")) print("perimeter =", width + height + width + width) question: what is the first line python runs? answer: the first line is always run first. in this case it is: height = int(input("height: ")) what does that line do? prints height: , waits for the user to type a string in, and then converts the string to an integer variable height. what is the next line that runs? in general, it is the next line down which is: width = int(input("width: ")) what does that line do? prints width: , waits for the user to type a number in, and puts what the user types in the variable width. what is the next line that runs? when the next line is not indented more or less than the current line, it is the line right afterwards, so it is: print("perimeter = ", width + height + width + width) (it may also run a function in the current line, but that's a future chapter.) what does that line do? first it prints perimeter = , then it prints the sum of the values contained within the variables, width and height, from width + height + width + width. does width + height + width + width calculate the perimeter properly? let's see, perimeter of a rectangle is the bottom (width) plus the left side (height) plus the top (width) plus the right side (huh?). the last item should be the right side's length, or the height. do you understand why some of the times the perimeter was calculated "correctly"? it was calculated correctly when the width and the height were equal. the next program we will do a code walkthrough for is a program that is supposed to print out 5 dots on the screen. however, this is what the program is outputting: . . . . and here is the program: number = 5 while number > 1: print(".",end=" ") number = number - 1 print() this program will be more complex to walkthrough since it now has indented portions (or control structures). let us begin. what is the first line to be run? the first line of the file: number = 5 what does it do? puts the number 5 in the variable number. what is the next line? the next line is: while number > 1: what does it do? well, while statements in general look at their expression, and if it is true they do the next indented block of code, otherwise they skip the next indented block of code. so what does it do right now? if number > 1 is true then the next two lines will be run. so is number > 1? the last value put into number was 5 and 5 > 1 so yes. so what is the next line? since the while was true the next line is: print(".",end=" ") what does that line do? prints one dot and since the extra argument end=" " exists the next printed text will not be on a different screen line. what is the next line? number = number - 1 since that is following line and there are no indent changes. what does it do? it calculates number - 1, which is the current value of number (or 5) subtracts 1 from it, and makes that the new value of number. so basically it changes number's value from 5 to 4. what is the next line? well, the indent level decreases so we have to look at what type of control structure it is. it is a while loop, so we have to go back to the while clause which is while number > 1: what does it do? it looks at the value of number, which is 4, and compares it to 1 and since 4 > 1 the while loop continues. what is the next line? since the while loop was true, the next line is: print(".",end=" ") what does it do? it prints a second dot on the line, ending by a space. what is the next line? no indent change so it is: number = number - 1 and what does it do? it takes the current value of number (4), subtracts 1 from it, which gives it 3 and then finally makes 3 the new value of number. what is the next line? since there is an indent change caused by the end of the while loop, the next line is: while number > 1: what does it do? it compares the current value of number (3) to 1. 3 > 1 so the while loop continues. what is the next line? since the while loop condition was true the next line is: print(".",end=" ") and it does what? a third dot is printed on the line. what is the next line? it is: number = number - 1 what does it do? it takes the current value of number (3) subtracts from it 1 and makes the 2 the new value of number. what is the next line? back up to the start of the while loop: while number > 1: what does it do? it compares the current value of number (2) to 1. since 2 > 1 the while loop continues. what is the next line? since the while loop is continuing: print(".",end=" ") what does it do? it discovers the meaning of life, the universe and everything. i'm joking. (i had to make sure you were awake.) the line prints a fourth dot on the screen. what is the next line? it's: number = number - 1 what does it do? takes the current value of number (2) subtracts 1 and makes 1 the new value of number. what is the next line? back up to the while loop: while number > 1: what does the line do? it compares the current value of number (1) to 1. since 1 > 1 is false (one is not greater than one), the while loop exits. what is the next line? since the while loop condition was false the next line is the line after the while loop exits, or: print() what does that line do? makes the screen go to the next line. why doesn't the program print 5 dots? the loop exits 1 dot too soon. how can we fix that? make the loop exit 1 dot later. and how do we do that? there are several ways. one way would be to change the while loop to: while number > 0: another way would be to change the conditional to: number >= 1 there are a couple others. how do i fix my program? you need to figure out what the program is doing. you need to figure out what the program should do. figure out what the difference between the two is. debugging is a skill that has to be practiced to be learned. if you can't figure it out after an hour, take a break, talk to someone about the problem or contemplate the lint in your navel. come back in a while and you will probably have new ideas about the problem. good luck. non-programmer's tutorial for python 3 ← decisions print version defining functions → 8. defining functions creating functions to start off this chapter i am going to give you an example of what you could do but shouldn't (so don't type it in): a = 23 b = -23 if a < 0: a = -a if b < 0: b = -b if a == b: print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and 23 are equal. the program seems a little repetitive. programmers hate to repeat things -- that's what computers are for, after all! (note also that finding the absolute value changed the value of the variable, which is why it is printing out 23, and not -23 in the output.) fortunately python allows you to create functions to remove duplication. here is the rewritten example: a = 23 b = -23 def absolute_value(n): if n < 0: n = -n return n if absolute_value(a) == absolute_value(b): print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and -23 are equal. the key feature of this program is the def statement. def (short for define) starts a function definition. def is followed by the name of the function absolute_value. next comes a '(' followed by the parameter n (n is passed from the program into the function when the function is called). the statements after the ':' are executed when the function is used. the statements continue until either the indented statements end or a return is encountered. the return statement returns a value back to the place where the function was called. we already have encountered a function in our very first program, the print function. now we can make new functions. notice how the values of a and b are not changed. functions can be used to repeat tasks that don't return values. here are some examples: def hello(): print("hello") def area(width, height): return width * height def print_welcome(name): print("welcome", name) hello() hello() print_welcome("fred") w = 4 h = 5 print("width =", w, " height =", h, " area =", area(w, h)) with output being: hello hello welcome fred width = 4 height = 5 area = 20 that example shows some more stuff that you can do with functions. notice that you can use no arguments or two or more. notice also when a function doesn't need to send back a value, a return is optional. variables in functions when eliminating repeated code, you often have variables in the repeated code. in python, these are dealt with in a special way. so far all variables we have seen are global variables. functions have a special type of variable called local variables. these variables only exist while the function is running. when a local variable has the same name as another variable (such as a global variable), the local variable hides the other. sound confusing? well, these next examples (which are a bit contrived) should help clear things up. a = 4 def print_func(): a = 17 print("in print_func a =", a) print_func() print("a = ", a) when run, we will receive an output of: in print_func a = 17 a = 4 variable assignments inside a function do not override global variables, they exist only inside the function. even though a was assigned a new value inside the function, this newly assigned value was only relevant to print_func, when the function finishes running, and the a's values is printed again, we see the originally assigned values. here is another more complex example. a_var = 10 b_var = 15 e_var = 25 def a_func(a_var): print("in a_func a_var =", a_var) b_var = 100 + a_var d_var = 2 * a_var print("in a_func b_var =", b_var) print("in a_func d_var =", d_var) print("in a_func e_var =", e_var) return b_var + 10 c_var = a_func(b_var) print("a_var =", a_var) print("b_var =", b_var) print("c_var =", c_var) print("d_var =", d_var) output: in a_func a_var = 15 in a_func b_var = 115 in a_func d_var = 30 in a_func e_var = 25 a_var = 10 b_var = 15 c_var = 125 d_var = traceback (most recent call last): file "c:\def2.py", line 19, in <module> print("d_var = ", d_var) nameerror: name 'd_var' is not defined in this example the variables a_var, b_var, and d_var are all local variables when they are inside the function a_func. after the statement return b_var + 10 is run, they all cease to exist. the variable a_var is automatically a local variable since it is a parameter name. the variables b_var and d_var are local variables since they appear on the left of an equals sign in the function in the statements b_var = 100 + a_var and d_var = 2 * a_var . inside of the function a_var has no value assigned to it. when the function is called with c_var = a_func(b_var), 15 is assigned to a_var since at that point in time b_var is 15, making the call to the function a_func(15). this ends up setting a_var to 15 when it is inside of a_func. as you can see, once the function finishes running, the local variables a_var and b_var that had hidden the global variables of the same name are gone. then the statement print("a_var = ", a_var) prints the value 10 rather than the value 15 since the local variable that hid the global variable is gone. another thing to notice is the nameerror that happens at the end. this appears since the variable d_var no longer exists since a_func finished. all the local variables are deleted when the function exits. if you want to get something from a function, then you will have to use return something. one last thing to notice is that the value of e_var remains unchanged inside a_func since it is not a parameter and it never appears on the left of an equals sign inside of the function a_func. when a global variable is accessed inside a function it is the global variable from the outside. functions allow local variables that exist only inside the function and can hide other variables that are outside the function. examples temperature2.py #! /usr/bin/python #-*-coding: utf-8 -*- # converts temperature to fahrenheit or celsius def print_options(): print("options:") print(" 'p' print options") print(" 'c' convert from celsius") print(" 'f' convert from fahrenheit") print(" 'q' quit the program") def celsius_to_fahrenheit(c_temp): return 9.0 / 5.0 * c_temp + 32 def fahrenheit_to_celsius(f_temp): return (f_temp - 32.0) * 5.0 / 9.0 choice = "p" while choice != "q": if choice == "c": c_temp = float(input("celsius temperature: ")) print("fahrenheit:", celsius_to_fahrenheit(c_temp)) choice = input("option: ") elif choice == "f": f_temp = float(input("fahrenheit temperature: ")) print("celsius:", fahrenheit_to_celsius(f_temp)) choice = input("option: ") else: choice = "p" #alternatively choice != "q": so that print #when anything unexpected inputed print_options() choice = input("option: ") sample run: options: 'p' print options 'c' convert from celsius 'f' convert from fahrenheit 'q' quit the program option: c celsius temperature: 30 fahrenheit: 86.0 option: f fahrenheit temperature: 60 celsius: 15.5555555556 option: q area2.py #! /usr/bin/python #-*-coding: utf-8 -*- # calculates a given rectangle area def hello(): print('hello!') def area(width, height): return width * height def print_welcome(name): print('welcome,', name) def positive_input(prompt): number = float(input(prompt)) while number <= 0: print('must be a positive number') number = float(input(prompt)) return number name = input('your name: ') hello() print_welcome(name) print() print('to find the area of a rectangle,') print('enter the width and height below.') print() w = positive_input('width: ') h = positive_input('height: ') print('width =', w, ' height =', h, ' so area =', area(w, h)) sample run: your name: josh hello! welcome, josh to find the area of a rectangle, enter the width and height below. width: -4 must be a positive number width: 4 height: 3 width = 4 height = 3 so area = 12 exercises rewrite the area2.py program from the examples above to have a separate function for the area of a square, the area of a rectangle, and the area of a circle (3.14 * radius**2). this program should include a menu interface. solution def square(l): return l * l def rectangle(width , height): return width * height def circle(radius): return 3.14159 * radius ** 2 def options(): print() print("options:") print("s = calculate the area of a square.") print("c = calculate the area of a circle.") print("r = calculate the area of a rectangle.") print("q = quit") print() print("this program will calculate the area of a square, circle or rectangle.") choice = "x" options() while choice != "q": choice = input("please enter your choice: ") if choice == "s": l = float(input("length of square side: ")) print("the area of this square is", square(l)) options() elif choice == "c": radius = float(input("radius of the circle: ")) print("the area of the circle is", circle(radius)) options() elif choice == "r": width = float(input("width of the rectangle: ")) height = float(input("height of the rectangle: ")) print("the area of the rectangle is", rectangle(width, height)) options() elif choice == "q": print(" ",end="") else: print("unrecognized option.") options() non-programmer's tutorial for python 3 ← debugging print version advanced functions example → 9. advanced functions example some people find this section useful, and some find it confusing. if you find it confusing you can skip it. now we will do a walk through for the following program: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value result = mult(3, 2) print("3 * 2 = ", result) basically this program creates a positive integer multiplication function (that is far slower than the built in multiplication function) and then demonstrates this function with a use of the function. this program demonstrates the use of recursion, that is a form of iteration (repetition) in which there is a function that repeatedly calls itself until an exit condition is satisfied. it uses repeated additions to give the same result as mutiplication: e.g. 3 + 3 (addition) gives the same result as 3 * 2 (multiplication). question: what is the first thing the program does? answer: the first thing done is the function mult is defined with the lines: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value this creates a function that takes two parameters and returns a value when it is done. later this function can be run. what happens next? the next line after the function, result = mult(3, 2) is run. what does this line do? this line will assign the return value of mult(3, 2) to the variable result. and what does mult(3, 2) return? we need to do a walkthrough of the mult function to find out. what happens next? the variable a gets the value 3 assigned to it and the variable b gets the value 2 assigned to it. and then? the line if b == 0: is run. since b has the value 2 this is false so the line return 0 is skipped. and what then? the line rest = mult(a, b - 1) is run. this line sets the local variable rest to the value of mult(a, b - 1). the value of a is 3 and the value of b is 2 so the function call is mult(3,1) so what is the value of mult(3, 1) ? we will need to run the function mult with the parameters 3 and 1. so what happens next? the local variables in the new run of the function are set so that a has the value 3 and b has the value 1. since these are local values these do not affect the previous values of a and b. and then? since b has the value 1 the if statement is false, so the next line becomes rest = mult(a, b - 1). what does this line do? this line will assign the value of mult(3, 0) to rest. so what is that value? we will have to run the function one more time to find that out. this time a has the value 3 and b has the value 0. so what happens next? the first line in the function to run is if b == 0:. b has the value 0 so the next line to run is return 0 and what does the line return 0 do? this line returns the value 0 out of the function. so? so now we know that mult(3, 0) has the value 0. now we know what the line rest = mult(a, b - 1) did since we have run the function mult with the parameters 3 and 0. we have finished running mult(3, 0) and are now back to running mult(3, 1). the variable rest gets assigned the value 0. what line is run next? the line value = a + rest is run next. in this run of the function, a = 3 and rest = 0 so now value = 3. what happens next? the line return value is run. this returns 3 from the function. this also exits from the run of the function mult(3, 1). after return is called, we go back to running mult(3, 2). where were we in mult(3, 2)? we had the variables a = 3 and b = 2 and were examining the line rest = mult(a, b - 1). so what happens now? the variable rest get 3 assigned to it. the next line value = a + rest sets value to 3 + 3 or 6. so now what happens? the next line runs, this returns 6 from the function. we are now back to running the line result = mult(3, 2) which can now assign the value 6 to the variable result. what happens next? the next line after the function, print("3 * 2 = ", result) is run. and what does this do? it prints 3 * 2 = and the value of result which is 6. the complete line printed is 3 * 2 = 6. what is happening overall? basically we used two facts to calculate the multiple of the two numbers. the first is that any number times 0 is 0 (x * 0 = 0). the second is that a number times another number is equal to the first number plus the first number times one less than the second number (x * y = x + x * (y - 1)). so what happens is 3 * 2 is first converted into 3 + 3 * 1. then 3 * 1 is converted into 3 + 3 * 0. then we know that any number times 0 is 0 so 3 * 0 is 0. then we can calculate that 3 + 3 * 0 is 3 + 0 which is 3. now we know what 3 * 1 is so we can calculate that 3 + 3 * 1 is 3 + 3 which is 6. this is how the whole thing works: mult(3, 2) 3 + mult(3, 1) 3 + 3 + mult(3, 0) 3 + 3 + 0 3 + 3 6 recursion programming constructs solving a problem by solving a smaller version of the same problem are called recursive. in the examples in this chapter, recursion is realized by defining a function calling itself. this facilitates implementing solutions to programming tasks as it may be sufficient to consider the next step of a problem instead of the whole problem at once. it is also useful as it allows to express some mathematical concepts with straightforward, easy to read code. any problem that can be solved with recursion could be re-implemented with loops. using the latter usually results in better performance. however equivalent implementations using loops are usually harder to get done correctly. probably the most intuitive definition of recursion is: recursion if you still don't get it, see recursion. try walking through the factorial example if the multiplication example did not make sense. examples factorial.py #defines a function that calculates the factorial def factorial(n): if n == 0: return 1 if n<0: return "error, negative numbers do not have factorial values!!" return n * factorial(n - 1) print("2! =", factorial(2)) print("3! =", factorial(3)) print("4! =", factorial(4)) print("5! =", factorial(5)) print("-3! =", factorial(-3)) output: 2! = 2 3! = 6 4! = 24 5! = 120 -3! = error, negative values do not have factorial values!! countdown.py def count_down(n): print(n) if n > 0: return count_down(n-1) count_down(5) output: 5 4 3 2 1 0 non-programmer's tutorial for python 3 ← defining functions print version lists → 10. lists variables with more than one value you have already seen ordinary variables that store a single value. however other variable types can hold more than one value. these are called containers because they can contain more than one object. the simplest type is called a list. here is an example of a list being used: which_one = int(input("what month (1-12)? ")) months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'] if 1 <= which_one <= 12: print("the month is", months[which_one - 1]) and an output example: what month (1-12)? 3 the month is march in this example the months is a list. months is defined with the lines months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', and 'august', 'september', 'october', 'november', 'december'] (note that a \ could also be used to split a long line, but that is not necessary in this case because python is intelligent enough to recognize that everything within brackets belongs together). the [ and ] start and end the list with commas (,) separating the list items. the list is used in months[which_one - 1]. a list consists of items that are numbered starting at 0. in other words if you wanted january you would use months[0]. give a list a number and it will return the value that is stored at that location. the statement if 1 <= which_one <= 12: will only be true if which_one is between one and twelve inclusive (in other words it is what you would expect if you have seen that in algebra). lists can be thought of as a series of boxes. each box has a different value. for example, the boxes created by demolist = ['life', 42, 'the universe', 6, 'and', 9] would look like this: box number 0 1 2 3 4 5 demolist "life" 42 "the universe" 6 "and" 9 each box is referenced by its number so the statement demolist[0] would get 'life', demolist[1] would get 42 and so on up to demolist[5] getting 9. more features of lists the next example is just to show a lot of other stuff lists can do (for once i don't expect you to type it in, but you should probably play around with lists in interactive mode until you are comfortable with them.). here goes: demolist = ["life", 42, "the universe", 6, "and", 9] print("demolist = ",demolist) demolist.append("everything") print("after 'everything' was appended demolist is now:") print(demolist) print("len(demolist) =", len(demolist)) print("demolist.index(42) =", demolist.index(42)) print("demolist[1] =", demolist[1]) # next we will loop through the list for c in range(len(demolist)): print("demolist[", c, "] =", demolist[c]) del demolist[2] print("after 'the universe' was removed demolist is now:") print(demolist) if "life" in demolist: print("'life' was found in demolist") else: print("'life' was not found in demolist") if "amoeba" in demolist: print("'amoeba' was found in demolist") if "amoeba" not in demolist: print("'amoeba' was not found in demolist") another_list = [42,7,0,123] another_list.sort() print("the sorted another_list is", another_list) the output is: demolist = ['life', 42, 'the universe', 6, 'and', 9] after 'everything' was appended demolist is now: ['life', 42, 'the universe', 6, 'and', 9, 'everything'] len(demolist) = 7 demolist.index(42) = 1 demolist[1] = 42 demolist[ 0 ] = life demolist[ 1 ] = 42 demolist[ 2 ] = the universe demolist[ 3 ] = 6 demolist[ 4 ] = and demolist[ 5 ] = 9 demolist[ 6 ] = everything after 'the universe' was removed demolist is now: ['life', 42, 6, 'and', 9, 'everything'] 'life' was found in demolist 'amoeba' was not found in demolist the sorted another_list is [0, 7, 42, 123] this example uses a whole bunch of new functions. notice that you can just print a whole list. next the append function is used to add a new item to the end of the list. len returns how many items are in a list. the valid indexes (as in numbers that can be used inside of the []) of a list range from 0 to len - 1. the index function tells where the first location of an item is located in a list. notice how demolist.index(42) returns 1, and when demolist[1] is run it returns 42. to get help on all the functions a list provides for you, type help(list) in the interactive python interpreter. the line # next we will loop through the list is a just a reminder to the programmer (also called a comment). python ignores everything that is written after a # on the current line. next the lines: for c in range(len(demolist)): print('demolist[', c, '] =', demolist[c]) create a variable c, which starts at 0 and is incremented until it reaches the last index of the list. meanwhile the print statement prints out each element of the list. a much better way to do the above is: for c, x in enumerate(demolist): print("demolist[", c, "] =", x) the del command can be used to remove a given element in a list. the next few lines use the in operator to test if an element is in or is not in a list. the sort function sorts the list. this is useful if you need a list in order from smallest number to largest or alphabetical. note that this rearranges the list. in summary, for a list, the following operations occur: example explanation demolist[2] accesses the element at index 2 demolist[2] = 3 sets the element at index 2 to be 3 del demolist[2] removes the element at index 2 len(demolist) returns the length of demolist "value" in demolist is true if "value" is an element in demolist "value" not in demolist is true if "value" is not an element in demolist another_list.sort() sorts another_list. note that the list must be all numbers or all strings to be sorted. demolist.index("value") returns the index of the first place that "value" occurs demolist.append("value") adds an element "value" at the end of the list demolist.remove("value") removes the first occurrence of value from demolist (same as del demolist[demolist.index("value")]) this next example uses these features in a more useful way: menu_item = 0 namelist = [] while menu_item != 9: print("--------------------") print("1. print the list") print("2. add a name to the list") print("3. remove a name from the list") print("4. change an item in the list") print("9. quit") menu_item = int(input("pick an item from the menu: ")) if menu_item == 1: current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") elif menu_item == 2: name = input("type in a name to add: ") namelist.append(name) elif menu_item == 3: del_name = input("what name would you like to remove: ") if del_name in namelist: # namelist.remove(del_name) would work just as fine item_number = namelist.index(del_name) del namelist[item_number] # the code above only removes the first occurrence of # the name. the code below from gerald removes all. # while del_name in namelist: # item_number = namelist.index(del_name) # del namelist[item_number] else: print(del_name, "was not found") elif menu_item == 4: old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") print("goodbye") and here is part of the output: -------------------- 1. print the list 2. add a name to the list 3. remove a name from the list 4. change an item in the list 9. quit pick an item from the menu: 2 type in a name to add: jack pick an item from the menu: 2 type in a name to add: jill pick an item from the menu: 1 0 . jack 1 . jill pick an item from the menu: 3 what name would you like to remove: jack pick an item from the menu: 4 what name would you like to change: jill what is the new name: jill peters pick an item from the menu: 1 0 . jill peters pick an item from the menu: 9 goodbye that was a long program. let's take a look at the source code. the line namelist = [] makes the variable namelist a list with no items (or elements). the next important line is while menu_item != 9:. this line starts a loop that allows the menu system for this program. the next few lines display a menu and decide which part of the program to run. the section current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") goes through the list and prints each name. len(namelist) tells how many items are in the list. if len returns 0, then the list is empty. then, a few lines later, the statement namelist.append(name) appears. it uses the append function to add an item to the end of the list. jump down another two lines, and notice this section of code: item_number = namelist.index(del_name) del namelist[item_number] here the index function is used to find the index value that will be used later to remove the item. del namelist[item_number] is used to remove an element of the list. the next section old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") uses index to find the item_number and then puts new_name where the old_name was. congratulations, with lists under your belt, you now know enough of the language that you could do any computations that a computer can do (this is technically known as turing-completeness). of course, there are still many features that are used to make your life easier. examples test.py ## this program runs a test of knowledge # first get the test questions # later this will be modified to use file io. def get_questions(): # notice how the data is stored as a list of lists return [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list # this function takes a list with two elements, a question and an answer. question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the tester's answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question #note that this is extracting a question and answer list from the list of lists. if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions),\ "% right out of", len(questions)) # now let's get the questions from the get_questions function, and # send the returned list of lists as an argument to the run_test function. run_test(get_questions()) the values true and false point to 1 and 0, respectively. they are often used in sanity checks, loop conditions etc. you will learn more about this a little bit later (chapter boolean expressions). please note that get_questions() is essentially a list because even though it's technically a function, returning a list of lists is the only thing it does. sample output: what color is the daytime sky on a clear day? green incorrect, correct was: blue what is the answer to life, the universe and everything? 42 correct what is a three letter word for mouse trap? cat correct you got 66 % right out of 3 exercises expand the test.py program so it has a menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". solution expand the test.py program so it has menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". ## this program runs a test of knowledge questions = [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"], ["what noise does a truly advanced machine make?", "ping"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the testers answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions), "% right out of", len(questions)) #showing a list of questions and answers def showquestions(): q = 0 while q < len(questions): a = 0 print("q:" , questions[q][a]) a = 1 print("a:" , questions[q][a]) q = q + 1 # now let's define the menu function def menu(): print("-----------------") print("menu:") print("1 - take the test") print("2 - view a list of questions and answers") print("3 - view the menu") print("5 - quit") print("-----------------") choice = "3" while choice != "5": if choice == "1": run_test(questions) elif choice == "2": showquestions() elif choice == "3": menu() print() choice = input("choose your option from the menu above: ") non-programmer's tutorial for python 3 ← advanced functions example print version for loops → 11. for loops and here is the new typing exercise for this chapter: onetoten = range(1, 11) for count in onetoten: print(count) and the ever-present output: 1 2 3 4 5 6 7 8 9 10 the output looks awfully familiar but the program code looks different. the first line uses the range function. the range function uses two arguments like this range(start, finish). start is the first number that is produced. finish is one larger than the last number. note that this program could have been done in a shorter way: for count in range(1, 11): print(count) the range function returns an iterable. this can be converted into a list with the list function. which will then be the dominant number. here are some examples to show what happens with the range command: >>> range(1, 10) range(1, 10) >>> list(range(1, 10)) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(-32, -20)) [-32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21] >>> list(range(5,21)) [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] >>> list(range(5)) [0, 1, 2, 3, 4] >>> list(range(21, 5)) [] the next line for count in onetoten: uses the for control structure. a for control structure looks like for variable in list:. list is gone through starting with the first element of the list and going to the last. as for goes through each element in a list it puts each into variable. that allows variable to be used in each successive time the for loop is run through. here is another example (you don't have to type this) to demonstrate: demolist = ['life', 42, 'the universe', 6, 'and', 7, 'everything'] for item in demolist: print("the current item is:",item) the output is: the current item is: life the current item is: 42 the current item is: the universe the current item is: 6 the current item is: and the current item is: 7 the current item is: everything notice how the for loop goes through and sets item to each element in the list. so, what is for good for? the first use is to go through all the elements of a list and do something with each of them. here's a quick way to add up all the elements: list = [2, 4, 6, 8] sum = 0 for num in list: sum = sum + num print("the sum is:", sum) with the output simply being: the sum is: 20 or you could write a program to find out if there are any duplicates in a list like this program does: list = [4, 5, 7, 8, 9, 1, 0, 7, 10] list.sort() prev = none for item in list: if prev == item: print("duplicate of", prev, "found") prev = item and for good measure: duplicate of 7 found okay, so how does it work? here is a special debugging version to help you understand (you don't need to type this in): l = [4, 5, 7, 8, 9, 1, 0, 7, 10] print("l = [4, 5, 7, 8, 9, 1, 0, 7, 10]", "\t\tl:", l) l.sort() print("l.sort()", "\t\tl:", l) prev = l[0] print("prev = l[0]", "\t\tprev:", prev) del l[0] print("del l[0]", "\t\tl:", l) for item in l: if prev == item: print("duplicate of", prev, "found") print("if prev == item:", "\t\tprev:", prev, "\titem:", item) prev = item print("prev = item", "\t\tprev:", prev, "\titem:", item) with the output being: l = [4, 5, 7, 8, 9, 1, 0, 7, 10] l: [4, 5, 7, 8, 9, 1, 0, 7, 10] l.sort() l: [0, 1, 4, 5, 7, 7, 8, 9, 10] prev = l[0] prev: 0 del l[0] l: [1, 4, 5, 7, 7, 8, 9, 10] if prev == item: prev: 0 item: 1 prev = item prev: 1 item: 1 if prev == item: prev: 1 item: 4 prev = item prev: 4 item: 4 if prev == item: prev: 4 item: 5 prev = item prev: 5 item: 5 if prev == item: prev: 5 item: 7 prev = item prev: 7 item: 7 duplicate of 7 found if prev == item: prev: 7 item: 7 prev = item prev: 7 item: 7 if prev == item: prev: 7 item: 8 prev = item prev: 8 item: 8 if prev == item: prev: 8 item: 9 prev = item prev: 9 item: 9 if prev == item: prev: 9 item: 10 prev = item prev: 10 item: 10 the reason i put so many print statements in the code was so that you can see what is happening in each line. (by the way, if you can't figure out why a program is not working, try putting in lots of print statements in places where you want to know what is happening.) first the program starts with a boring old list. next the program sorts the list. this is so that any duplicates get put next to each other. the program then initializes a prev(ious) variable. next the first element of the list is deleted so that the first item is not incorrectly thought to be a duplicate. next a for loop is gone into. each item of the list is checked to see if it is the same as the previous. if it is a duplicate was found. the value of prev is then changed so that the next time the for loop is run through prev is the previous item to the current. sure enough, the 7 is found to be a duplicate. (notice how \t is used to print a tab.) the other way to use for loops is to do something a certain number of times. here is some code to print out the first 9 numbers of the fibonacci series: a = 1 b = 1 for c in range(1, 10): print(a, end=" ") n = a + b a = b b = n with the surprising output: 1 1 2 3 5 8 13 21 34 everything that can be done with for loops can also be done with while loops but for loops give an easy way to go through all the elements in a list or to do something a certain number of times. non-programmer's tutorial for python 3 ← lists print version boolean expressions → 12. boolean expressions here is a little example of boolean expressions (you don't have to type it in): a = 6 b = 7 c = 42 print(1, a == 6) print(2, a == 7) print(3, a == 6 and b == 7) print(4, a == 7 and b == 7) print(5, not a == 7 and b == 7) print(6, a == 7 or b == 7) print(7, a == 7 or b == 6) print(8, not (a == 7 and b == 6)) print(9, not a == 7 and b == 6) with the output being: 1 true 2 false 3 true 4 false 5 true 6 true 7 false 8 true 9 false what is going on? the program consists of a bunch of funny looking print statements. each print statement prints a number and an expression. the number is to help keep track of which statement i am dealing with. notice how each expression ends up being either false or true. in python false can also be written as 0 and true as 1. the lines: print(1, a == 6) print(2, a == 7) print out a true and a false respectively just as expected since the first is true and the second is false. the third print, print(3, a == 6 and b == 7), is a little different. the operator and means if both the statement before and the statement after are true then the whole expression is true otherwise the whole expression is false. the next line, print(4, a == 7 and b == 7), shows how if part of an and expression is false, the whole thing is false. the behavior of and can be summarized as follows: expression result true and true true true and false false false and true false false and false false notice that if the first expression is false python does not check the second expression since it knows the whole expression is false. try running false and print("hi") and compare this to running true and print("hi") the technical term for this is short-circuit evaluation the next line, print(5, not a == 7 and b == 7), uses the not operator. not just gives the opposite of the expression. (the expression could be rewritten as print(5, a != 7 and b == 7)). here is the table: expression result not true false not false true the two following lines, print(6, a == 7 or b == 7) and print(7, a == 7 or b == 6), use the or operator. the or operator returns true if the first expression is true, or if the second expression is true or both are true. if neither are true it returns false. here's the table: expression result true or true true true or false true false or true true false or false false notice that if the first expression is true python doesn't check the second expression since it knows the whole expression is true. this works since or is true if at least one half of the expression is true. the first part is true so the second part could be either false or true, but the whole expression is still true. the next two lines, print(8, not (a == 7 and b == 6)) and print(9, not a == 7 and b == 6), show that parentheses can be used to group expressions and force one part to be evaluated first. notice that the parentheses changed the expression from false to true. this occurred since the parentheses forced the not to apply to the whole expression instead of just the a == 7 portion. here is an example of using a boolean expression: list = ["life", "the universe", "everything", "jack", "jill", "life", "jill"] # make a copy of the list. see the more on lists chapter to explain what [:] means. copy = list[:] # sort the copy copy.sort() prev = copy[0] del copy[0] count = 0 # go through the list searching for a match while count < len(copy) and copy[count] != prev: prev = copy[count] count = count + 1 # if a match was not found then count can't be < len # since the while loop continues while count is < len # and no match is found if count < len(copy): print("first match:", prev) and here is the output: first match: jill this program works by continuing to check for match while count < len(copy) and copy[count] is not equal to prev. when either count is greater than the last index of copy or a match has been found the and is no longer true so the loop exits. the if simply checks to make sure that the while exited because a match was found. the other "trick" of and is used in this example. if you look at the table for and notice that the third entry is "false and false". if count >= len(copy) (in other words count < len(copy) is false) then copy[count] is never looked at. this is because python knows that if the first is false then they can't both be true. this is known as a short circuit and is useful if the second half of the and will cause an error if something is wrong. i used the first expression (count < len(copy)) to check and see if count was a valid index for copy. (if you don't believe me remove the matches "jill" and "life", check that it still works and then reverse the order of count < len(copy) and copy[count] != prev to copy[count] != prev and count < len(copy).) boolean expressions can be used when you need to check two or more different things at once. a note on boolean operators a common mistake for people new to programming is a misunderstanding of the way that boolean operators works, which stems from the way the python interpreter reads these expressions. for example, after initially learning about "and " and "or" statements, one might assume that the expression x == ('a' or 'b') would check to see if the variable x was equivalent to one of the strings 'a' or 'b'. this is not so. to see what i'm talking about, start an interactive session with the interpreter and enter the following expressions: >>> 'a' == ('a' or 'b') >>> 'b' == ('a' or 'b') >>> 'a' == ('a' and 'b') >>> 'b' == ('a' and 'b') and this will be the unintuitive result: >>> 'a' == ('a' or 'b') true >>> 'b' == ('a' or 'b') false >>> 'a' == ('a' and 'b') false >>> 'b' == ('a' and 'b') true at this point, the and and or operators seem to be broken. it doesn't make sense that, for the first two expressions, 'a' is equivalent to 'a' or 'b' while 'b' is not. furthermore, it doesn't make any sense that 'b' is equivalent to 'a' and 'b'. after examining what the interpreter does with boolean operators, these results do in fact exactly what you are asking of them, it's just not the same as what you think you are asking. when the python interpreter looks at an or expression, it takes the first statement and checks to see if it is true. if the first statement is true, then python returns that object's value without checking the second statement. this is because for an or expression, the whole thing is true if one of the values is true; the program does not need to bother with the second statement. on the other hand, if the first value is evaluated as false python checks the second half and returns that value. that second half determines the truth value of the whole expression since the first half was false. this "laziness" on the part of the interpreter is called "short circuiting" and is a common way of evaluating boolean expressions in many programming languages. similarly, for an and expression, python uses a short circuit technique to speed truth value evaluation. if the first statement is false then the whole thing must be false, so it returns that value. otherwise if the first value is true it checks the second and returns that value. one thing to note at this point is that the boolean expression returns a value indicating true or false, but that python considers a number of different things to have a truth value assigned to them. to check the truth value of any given object x, you can use the function bool(x) to see its truth value. below is a table with examples of the truth values of various objects: true false true false 1 0 numbers other than zero the string 'none' nonempty strings empty strings nonempty lists empty lists nonempty dictionaries empty dictionaries now it is possible to understand the perplexing results we were getting when we tested those boolean expressions before. let's take a look at what the interpreter "sees" as it goes through that code: first case: >>> 'a' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'a' == 'a' # the string 'a' is equivalent to the string 'a', so expression is true true second case: >>> 'b' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'b' == 'a' # the string 'b' is not equivalent to the string 'a', so expression is false false third case: >>> 'a' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'a' == 'b' # the string 'a' is not equivalent to the string 'b', so expression is false false fourth case: >>> 'b' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'b' == 'b' # the string 'b' is equivalent to the string 'b', so expression is true true so python was really doing its job when it gave those apparently bogus results. as mentioned previously, the important thing is to recognize what value your boolean expression will return when it is evaluated, because it isn't always obvious. going back to those initial expressions, this is how you would write them out so they behaved in a way that you want: >>> 'a' == 'a' or 'a' == 'b' true >>> 'b' == 'a' or 'b' == 'b' true >>> 'a' == 'a' and 'a' == 'b' false >>> 'b' == 'a' and 'b' == 'b' false when these comparisons are evaluated they return truth values in terms of true or false, not strings, so we get the proper results. examples password1.py ## this program asks a user for a name and a password. # it then checks them to make sure that the user is allowed in. name = input("what is your name? ") password = input("what is the password? ") if name == "josh" and password == "friday": print("welcome josh") elif name == "fred" and password == "rock": print("welcome fred") else: print("i don't know you.") sample runs what is your name? josh what is the password? friday welcome josh what is your name? bill what is the password? money i don't know you. exercises write a program that has a user guess your name, but they only get 3 chances to do so until the program quits. solution print("try to guess my name!") count = 1 name = "guilherme" guess = input("what is my name? ") while count < 3 and guess.lower() != name: # .lower allows things like guilherme to still match print("you are wrong!") guess = input("what is my name? ") count = count + 1 if guess.lower() != name: print("you are wrong!") # this message isn't printed in the third chance, so we print it now print("you ran out of chances.") else: print("yes! my name is", name + "!") non-programmer's tutorial for python 3 ← for loops print version dictionaries → 13. dictionaries this chapter is about dictionaries. dictionaries have keys and values. the keys are used to find the values. here is an example of a dictionary in use: def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() and here is my output: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. quit type in a number (1-5): 2 add name and number name: joe number: 545-4464 type in a number (1-5): 2 add name and number name: jill number: 979-4654 type in a number (1-5): 2 add name and number name: fred number: 132-9874 type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 name: fred number: 132-9874 type in a number (1-5): 4 lookup number name: joe the number is 545-4464 type in a number (1-5): 3 remove name and number name: fred type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 type in a number (1-5): 5 this program is similar to the name list earlier in the chapter on lists. here's how the program works. first the function print_menu is defined. print_menu just prints a menu that is later used twice in the program. next comes the funny looking line numbers = {}. all that this line does is to tell python that numbers is a dictionary. the next few lines just make the menu work. the lines for x in numbers.keys(): print("name:", x, "\tnumber:", numbers[x]) go through the dictionary and print all the information. the function numbers.keys() returns a list that is then used by the for loop. the list returned by keys() is not in any particular order so if you want it in alphabetic order it must be sorted. similar to lists the statement numbers[x] is used to access a specific member of the dictionary. of course in this case x is a string. next the line numbers[name] = phone adds a name and phone number to the dictionary. if name had already been in the dictionary phone would replace whatever was there before. next the lines if name in numbers: del numbers[name] see if a name is in the dictionary and remove it if it is. the operator name in numbers returns true if name is in numbers but otherwise returns false. the line del numbers[name] removes the key name and the value associated with that key. the lines if name in numbers: print("the number is", numbers[name]) check to see if the dictionary has a certain key and if it does prints out the number associated with it. lastly if the menu choice is invalid it reprints the menu for your viewing pleasure. a recap: dictionaries have keys and values. keys can be strings or numbers. keys point to values. values can be any type of variable (including lists or even dictionaries (those dictionaries or lists of course can contain dictionaries or lists themselves (scary right? :-) ))). here is an example of using a list in a dictionary: max_points = [25, 25, 50, 25, 100] assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = {'#max': max_points} def print_menu(): print("1. add student") print("2. remove student") print("3. print grades") print("4. record grade") print("5. print menu") print("6. exit") def print_all_grades(): print('\t', end=' ') for i in range(len(assignments)): print(assignments[i], '\t', end=' ') print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) def print_grades(grades): for i in range(len(grades)): print(grades[i], '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 6: print() menu_choice = int(input("menu choice (1-6): ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(max_points) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: print_all_grades() elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i in range(len(assignments)): print(i + 1, assignments[i], '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 #same as which = which - 1 if 0 <= which < len(grades): grade = int(input("grade: ")) grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice != 6: print_menu() and here is a sample output: 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 menu choice (1-6): 5 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 1 student to add: bill menu choice (1-6): 4 record grade student: bill type in the number of the grade to record type a 0 (zero) to exit 1 hw ch 1 2 hw ch 2 3 quiz 4 hw ch 3 5 test 0 0 0 0 0 change which grade: 1 grade: 25 change which grade: 2 grade: 24 change which grade: 3 grade: 45 change which grade: 4 grade: 23 change which grade: 5 grade: 95 change which grade: 0 menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 bill 25 24 45 23 95 menu choice (1-6): 6 heres how the program works. basically the variable students is a dictionary with the keys being the name of the students and the values being their grades. the first two lines just create two lists. the next line students = {'#max': max_points} creates a new dictionary with the key {#max} and the value is set to be [25, 25, 50, 25, 100] (since thats what max_points was when the assignment is made) (i use the key #max since # is sorted ahead of any alphabetic characters). next print_menu is defined. next the print_all_grades function is defined in the lines: def print_all_grades(): print('\t',end=" ") for i in range(len(assignments)): print(assignments[i], '\t',end=" ") print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t',end=' ') grades = students[x] print_grades(grades) notice how first the keys are gotten out of the students dictionary with the keys function in the line keys = list(students.keys()). keys is an iterable, and it is converted to list so all the functions for lists can be used on it. next the keys are sorted in the line keys.sort(). for is used to go through all the keys. the grades are stored as a list inside the dictionary so the assignment grades = students[x] gives grades the list that is stored at the key x. the function print_grades just prints a list and is defined a few lines later. the later lines of the program implement the various options of the menu. the line students[name] = [0] * len(max_points) adds a student to the key of their name. the notation [0] * len(max_points) just creates a list of 0's that is the same length as the max_points list. the remove student entry just deletes a student similar to the telephone book example. the record grades choice is a little more complex. the grades are retrieved in the line grades = students[name] gets a reference to the grades of the student name. a grade is then recorded in the line grades[which] = grade. you may notice that grades is never put back into the students dictionary (as in no students[name] = grades). the reason for the missing statement is that grades is actually another name for students[name] and so changing grades changes student[name]. dictionaries provide an easy way to link keys to values. this can be used to easily keep track of data that is attached to various keys. non-programmer's tutorial for python 3 ← boolean expressions print version using modules → 14. using modules here's this chapter's typing exercise (name it cal.py (import actually looks for a file named calendar.py and reads it in. if the file is named calendar.py and it sees a "import calendar" it tries to read in itself which works poorly at best.)): import calendar year = int(input("type in the year number: ")) calendar.prcal(year) and here is part of the output i got: type in the year number: 2001 2001 january february march mo tu we th fr sa su mo tu we th fr sa su mo tu we th fr sa su 1 2 3 4 5 6 7 1 2 3 4 1 2 3 4 8 9 10 11 12 13 14 5 6 7 8 9 10 11 5 6 7 8 9 10 11 15 16 17 18 19 20 21 12 13 14 15 16 17 18 12 13 14 15 16 17 18 22 23 24 25 26 27 28 19 20 21 22 23 24 25 19 20 21 22 23 24 25 29 30 31 26 27 28 26 27 28 29 30 31 (i skipped some of the output, but i think you get the idea.) so what does the program do? the first line import calendar uses a new command import. the command import loads a module (in this case the calendar module). to see the commands available in the standard modules either look in the library reference for python (if you downloaded it) or go to http://docs.python.org/3/library/. if you look at the documentation for the calendar module, it lists a function called prcal that prints a calendar for a year. the line calendar.prcal(year) uses this function. in summary to use a module import it and then use module_name.function for functions in the module. another way to write the program is: from calendar import prcal year = int(input("type in the year number: ")) prcal(year) this version imports a specific function from a module. here is another program that uses the python library (name it something like clock.py) (press ctrl and the 'c' key at the same time to terminate the program): from time import time, ctime prev_time = "" while true: the_time = ctime(time()) if prev_time != the_time: print("the time is:", ctime(time())) prev_time = the_time with some output being: the time is: sun aug 20 13:40:04 2000 the time is: sun aug 20 13:40:05 2000 the time is: sun aug 20 13:40:06 2000 the time is: sun aug 20 13:40:07 2000 traceback (innermost last): file "clock.py", line 5, in ? the_time = ctime(time()) keyboardinterrupt the output is infinite of course so i cancelled it (or the output at least continues until ctrl+c is pressed). the program just does an infinite loop (true is always true, so while true: goes forever) and each time checks to see if the time has changed and prints it if it has. notice how multiple names after the import statement are used in the line from time import time, ctime. the python library contains many useful functions. these functions give your programs more abilities and many of them can simplify programming in python. exercises rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. solution rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. from random import randint number = randint(0, 99) guess = -1 while guess != number: guess = int(input ("guess a number: ")) if guess > number: print("too high") elif guess < number: print("too low") print("just right") other modules sometimes you want to use a python module that does not come with the python installation. you can also import those, but you have to have them installed on your computer. creating your own module when python reads the import command, it first checks files in your directory, then site-packages or pre installed modules. to make your own module, just create a .py file in the current directory and use the command: import module this will try to import the file module.py from your current directory and if not found, from site-packages and prepackaged modules. changing module to the name of the .py file you created will import that file. however, when it imports the module, it will basically start the file as a program, so any code on there will be run. you want to group all code into functions. the __name__ == __main__ trick in python, the variable __name__ will give you the current name of the program. if a module you import prints the __name__ variable, then it will print the name of the module. if the current file prints the __name__ variable, it will print __main__, to show it is the main program. if an if statement checks the name variable and runs code if the program is main, it can bypass the unintentional run problem created when a module is imported. say for example you have a file, which runs some code. it also has a function you want to use in another program. however, you only want the function, not to run the code. by setting up the code below, it will only run the code if it is the file that was clicked on or started, not if it was imported. if __name__ == '__main__': pass in this instance, if the file is run but not imported, it will run the pass command. you can replace the pass command with the code you want to be run when not imported. just remember to indent the code. the pip module the pip module is a module that comes with the python installation and acts as a module downloader/manager. you can download other modules from the internet with pip. the pip module is not used in the python interpreter, but is run through the command line. to use it, open up your command line interpreter (for windows it is command prompt, for mac/linux it is terminal) and type in the following code: py3 -m pip install module or the alternate code pip install module this will try to download and install module from the user-submitted python modules database. module can be changed to the name of the module. non-programmer's tutorial for python 3 ← dictionaries print version more on lists → 15. more on lists we have already seen lists and how they can be used. now that you have some more background i will go into more detail about lists. first we will look at more ways to get at the elements in a list and then we will talk about copying them. here are some examples of using indexing to access a single element of a list: >>> some_numbers = ['zero', 'one', 'two', 'three', 'four', 'five'] >>> some_numbers[0] 'zero' >>> some_numbers[4] 'four' >>> some_numbers[5] 'five' all those examples should look familiar to you. if you want the first item in the list just look at index 0. the second item is index 1 and so on through the list. however what if you want the last item in the list? one way could be to use the len() function like some_numbers[len(some_numbers) - 1]. this way works since the len() function always returns the last index plus one. the second from the last would then be some_numbers[len(some_numbers) - 2]. there is an easier way to do this. in python the last item is always index -1. the second to the last is index -2 and so on. here are some more examples: >>> some_numbers[len(some_numbers) - 1] 'five' >>> some_numbers[len(some_numbers) - 2] 'four' >>> some_numbers[-1] 'five' >>> some_numbers[-2] 'four' >>> some_numbers[-6] 'zero' thus any item in the list can be indexed in two ways: from the front and from the back. another useful way to get into parts of lists is using slicing. here is another example to give you an idea what they can be used for: >>> things = [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, "jack", "jill"] >>> things[0] 0 >>> things[7] 'jill' >>> things[0:8] [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, 'jack', 'jill'] >>> things[2:4] [2, 's.p.a.m.'] >>> things[4:7] ['stocking', 42, 'jack'] >>> things[1:5] ['fred', 2, 's.p.a.m.', 'stocking'] slicing is used to return part of a list. the slicing operator is in the form things[first_index:last_index]. slicing cuts the list before the first_index and before the last_index and returns the parts in between. you can use both types of indexing: >>> things[-4:-2] ['stocking', 42] >>> things[-4] 'stocking' >>> things[-4:6] ['stocking', 42] another trick with slicing is the unspecified index. if the first index is not specified the beginning of the list is assumed. if the last index is not specified the whole rest of the list is assumed. here are some examples: >>> things[:2] [0, 'fred'] >>> things[-2:] ['jack', 'jill'] >>> things[:3] [0, 'fred', 2] >>> things[:-5] [0, 'fred', 2] here is a (html inspired) program example (copy and paste in the poem definition if you want): poem = ["<b>", "jack", "and", "jill", "</b>", "went", "up", "the", "hill", "to", "<b>", "fetch", "a", "pail", "of", "</b>", "water.", "jack", "fell", "<b>", "down", "and", "broke", "</b>", "his", "crown", "and", "<b>", "jill", "came", "</b>", "tumbling", "after"] def get_bolds(text): true = 1 false = 0 ## is_bold tells whether or not we are currently looking at ## a bold section of text. is_bold = false ## start_block is the index of the start of either an unbolded ## segment of text or a bolded segment. start_block = 0 for index in range(len(text)): ## handle a starting of bold text if text[index] == "<b>": if is_bold: print("error: extra bold") ## print "not bold:", text[start_block:index] is_bold = true start_block = index + 1 ## handle end of bold text ## remember that the last number in a slice is the index ## after the last index used. if text[index] == "</b>": if not is_bold: print("error: extra close bold") print("bold [", start_block, ":", index, "]", text[start_block:index]) is_bold = false start_block = index + 1 get_bolds(poem) with the output being: bold [ 1 : 4 ] ['jack', 'and', 'jill'] bold [ 11 : 15 ] ['fetch', 'a', 'pail', 'of'] bold [ 20 : 23 ] ['down', 'and', 'broke'] bold [ 28 : 30 ] ['jill', 'came'] the get_bold() function takes in a list that is broken into words and tokens. the tokens that it looks for are <b> which starts the bold text and </b> which ends bold text. the function get_bold() goes through and searches for the start and end tokens. the next feature of lists is copying them. if you try something simple like: >>> a = [1, 2, 3] >>> b = a >>> print(b) [1, 2, 3] >>> b[1] = 10 >>> print(b) [1, 10, 3] >>> print(a) [1, 10, 3] this probably looks surprising since a modification to b resulted in a being changed as well. what happened is that the statement b = a makes b a reference to a. this means that b can be thought of as another name for a. hence any modification to b changes a as well. however some assignments don't create two names for one list: >>> a = [1, 2, 3] >>> b = a * 2 >>> print(a) [1, 2, 3] >>> print(b) [1, 2, 3, 1, 2, 3] >>> a[1] = 10 >>> print(a) [1, 10, 3] >>> print(b) [1, 2, 3, 1, 2, 3] in this case b is not a reference to a since the expression a * 2 creates a new list. then the statement b = a * 2 gives b a reference to a * 2 rather than a reference to a. all assignment operations create a reference. when you pass a list as an argument to a function you create a reference as well. most of the time you don't have to worry about creating references rather than copies. however when you need to make modifications to one list without changing another name of the list you have to make sure that you have actually created a copy. there are several ways to make a copy of a list. the simplest that works most of the time is the slice operator since it always makes a new list even if it is a slice of a whole list: >>> a = [1, 2, 3] >>> b = a[:] >>> b[1] = 10 >>> print(a) [1, 2, 3] >>> print(b) [1, 10, 3] taking the slice [:] creates a new copy of the list. however it only copies the outer list. any sublist inside is still a references to the sublist in the original list. therefore, when the list contains lists, the inner lists have to be copied as well. you could do that manually but python already contains a module to do it. you use the deepcopy function of the copy module: >>> import copy >>> a = [[1, 2, 3], [4, 5, 6]] >>> b = a[:] >>> c = copy.deepcopy(a) >>> b[0][1] = 10 >>> c[1][1] = 12 >>> print(a) [[1, 10, 3], [4, 5, 6]] >>> print(b) [[1, 10, 3], [4, 5, 6]] >>> print(c) [[1, 2, 3], [4, 12, 6]] first of all notice that a is a list of lists. then notice that when b[0][1] = 10 is run both a and b are changed, but c is not. this happens because the inner arrays are still references when the slice operator is used. however with deepcopy c was fully copied. so, should i worry about references every time i use a function or =? the good news is that you only have to worry about references when using dictionaries and lists. numbers and strings create references when assigned but every operation on numbers and strings that modifies them creates a new copy so you can never modify them unexpectedly. you do have to think about references when you are modifying a list or a dictionary. by now you are probably wondering why are references used at all? the basic reason is speed. it is much faster to make a reference to a thousand element list than to copy all the elements. the other reason is that it allows you to have a function to modify the inputed list or dictionary. just remember about references if you ever have some weird problem with data being changed when it shouldn't be. non-programmer's tutorial for python 3 ← using modules print version revenge of the strings → 16. revenge of the strings and now presenting a cool trick that can be done with strings: def shout(string): for character in string: print("gimme a " + character) print("'" + character + "'") shout("lose") def middle(string): print("the middle character is:", string[len(string) // 2]) middle("abcdefg") middle("the python programming language") middle("atlanta") and the output is: gimme a l 'l' gimme a o 'o' gimme a s 's' gimme a e 'e' the middle character is: d the middle character is: r the middle character is: a what these programs demonstrate is that strings are similar to lists in several ways. the shout() function shows that for loops can be used with strings just as they can be used with lists. the middle procedure shows that that strings can also use the len() function and array indexes and slices. most list features work on strings as well. the next feature demonstrates some string specific features: def to_upper(string): ## converts a string to upper case upper_case = "" for character in string: if 'a' <= character <= 'z': location = ord(character) - ord('a') new_ascii = location + ord('a') character = chr(new_ascii) upper_case = upper_case + character return upper_case print(to_upper("this is text")) with the output being: this is text this works because the computer represents the characters of a string as numbers from 0 to 1,114,111. for example 'a' is 65, 'b' is 66 and א is 1488. the values are the unicode value. python has a function called ord() (short for ordinal) that returns a character as a number. there is also a corresponding function called chr() that converts a number into a character. with this in mind the program should start to be clear. the first detail is the line: if 'a' <= character <= 'z': which checks to see if a letter is lower case. if it is then the next lines are used. first it is converted into a location so that a = 0, b = 1, c = 2 and so on with the line: location = ord(character) - ord('a'). next the new value is found with new_ascii = location + ord('a'). this value is converted back to a character that is now upper case. note that if you really need the upper case of a letter, you should use u=var.upper() which will work with other languages as well. now for some interactive typing exercise: >>> # integer to string >>> 2 2 >>> repr(2) '2' >>> -123 -123 >>> repr(-123) '-123' >>> # string to integer >>> "23" '23' >>> int("23") 23 >>> "23" * 2 '2323' >>> int("23") * 2 46 >>> # float to string >>> 1.23 1.23 >>> repr(1.23) '1.23' >>> # float to integer >>> 1.23 1.23 >>> int(1.23) 1 >>> int(-1.23) -1 >>> # string to float >>> float("1.23") 1.23 >>> "1.23" '1.23' >>> float("123") 123.0 if you haven't guessed already the function repr() can convert an integer to a string and the function int() can convert a string to an integer. the function float() can convert a string to a float. the repr() function returns a printable representation of something. here are some examples of this: >>> repr(1) '1' >>> repr(234.14) '234.14' >>> repr([4, 42, 10]) '[4, 42, 10]' the int() function tries to convert a string (or a float) into an integer. there is also a similar function called float() that will convert an integer or a string into a float. another function that python has is the eval() function. the eval() function takes a string and returns data of the type that python thinks it found. for example: >>> v = eval('123') >>> print(v, type(v)) 123 <type 'int'> >>> v = eval('645.123') >>> print(v, type(v)) 645.123 <type 'float'> >>> v = eval('[1, 2, 3]') >>> print(v, type(v)) [1, 2, 3] <type 'list'> if you use the eval() function you should check that it returns the type that you expect. one useful string function is the split() method. here's an example: >>> "this is a bunch of words".split() ['this', 'is', 'a', 'bunch', 'of', 'words'] >>> text = "first batch, second batch, third, fourth" >>> text.split(",") ['first batch', ' second batch', ' third', ' fourth'] notice how split() converts a string into a list of strings. the string is split by whitespace by default or by the optional argument (in this case a comma). you can also add another argument that tells split() how many times the separator will be used to split the text. for example: >>> list = text.split(",") >>> len(list) 4 >>> list[-1] ' fourth' >>> list = text.split(",", 2) >>> len(list) 3 >>> list[-1] ' third, fourth' slicing strings (and lists) strings can be cut into pieces — in the same way as it was shown for lists in the previous chapter — by using the slicing "operator" []. the slicing operator works in the same way as before: text[first_index:last_index] (in very rare cases there can be another colon and a third argument, as in the example shown below). in order not to get confused by the index numbers, it is easiest to see them as clipping places, possibilities to cut a string into parts. here is an example, which shows the clipping places (in yellow) and their index numbers (red and blue) for a simple text string: 0 1 2 ... -2 -1 ↓ ↓ ↓ ↓ ↓ ↓ ↓ text = " s t r i n g " ↑ ↑ [: :] note that the red indexes are counted from the beginning of the string and the blue ones from the end of the string backwards. (note that there is no blue -0, which could seem to be logical at the end of the string. because -0 == 0, -0 means "beginning of the string" as well.) now we are ready to use the indexes for slicing operations: text[1:4] → "tri" text[:5] → "strin" text[:-1] → "strin" text[-4:] → "ring" text[2] → "r" text[:] → "string" text[::-1] → "gnirts" text[1:4] gives us all of the text string between clipping places 1 and 4, "tri". if you omit one of the [first_index:last_index] arguments, you get the beginning or end of the string as default: text[:5] gives "strin". for both first_index and last_index we can use both the red and the blue numbering schema: text[:-1] gives the same as text[:5], because the index -1 is at the same place as 5 in this case. if we do not use an argument containing a colon, the number is treated in a different way: text[2] gives us one character following the second clipping point, "r". the special slicing operation text[:] means "from the beginning to the end" and produces a copy of the entire string (or list, as shown in the previous chapter). last but not least, the slicing operation can have a second colon and a third argument, which is interpreted as the "step size": text[::-1] is text from beginning to the end, with a step size of -1. -1 means "every character, but in the other direction". "string" backwards is "gnirts" (test a step length of 2, if you have not got the point here). all these slicing operations work with lists as well. in that sense strings are just a special case of lists, where the list elements are single characters. just remember the concept of clipping places, and the indexes for slicing things will get a lot less confusing. examples # this program requires an excellent understanding of decimal numbers. def to_string(in_int): """converts an integer to a string""" out_str = "" prefix = "" if in_int < 0: prefix = "-" in_int = -in_int while in_int // 10 != 0: out_str = str(in_int % 10) + out_str in_int = in_int // 10 out_str = str(in_int % 10) + out_str return prefix + out_str def to_int(in_str): """converts a string to an integer""" out_num = 0 if in_str[0] == "-": multiplier = -1 in_str = in_str[1:] else: multiplier = 1 for c in in_str: out_num = out_num * 10 + int(c) return out_num * multiplier print(to_string(2)) print(to_string(23445)) print(to_string(-23445)) print(to_int("14234")) print(to_int("12345")) print(to_int("-3512")) the output is: 2 23445 -23445 14234 12345 -3512 non-programmer's tutorial for python 3 ← more on lists print version file io → 17. file io file i/o here is a simple example of file i/o (input/output): # write a file with open("test.txt", "wt") as out_file: out_file.write("this text is going to out file\nlook at it and see!") # read a file with open("test.txt", "rt") as in_file: text = in_file.read() print(text) the output and the contents of the file test.txt are: this text is going to out file look at it and see! notice that it wrote a file called test.txt in the directory that you ran the program from. the \n in the string tells python to put a newline where it is. an overview of file i/o is: get a file object with the open function read or write to the file object (depending on how it was opened) if you did not use with to open the file, you'd have to close it manually the first step is to get a file object. the way to do this is to use the open function. the format is file_object = open(filename, mode) where file_object is the variable to put the file object, filename is a string with the filename, and mode is "rt" to read a file as text or "wt" to write a file as text (and a few others we will skip here). next the file objects functions can be called. the two most common functions are read and write. the write function adds a string to the end of the file. the read function reads the next thing in the file and returns it as a string. if no argument is given it will return the whole file (as done in the example). now here is a new version of the phone numbers program that we made earlier: def print_numbers(numbers): print("telephone numbers:") for k, v in numbers.items(): print("name:", k, "\tnumber:", v) print() def add_number(numbers, name, number): numbers[name] = number def lookup_number(numbers, name): if name in numbers: return "the number is " + numbers[name] else: return name + " was not found" def remove_number(numbers, name): if name in numbers: del numbers[name] else: print(name," was not found") def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. load numbers') print('6. save numbers') print('7. quit') print() phone_list = {} menu_choice = 0 print_menu() while true: menu_choice = int(input("type in a number (1-7): ")) if menu_choice == 1: print_numbers(phone_list) elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") add_number(phone_list, name, phone) elif menu_choice == 3: print("remove name and number") name = input("name: ") remove_number(phone_list, name) elif menu_choice == 4: print("lookup number") name = input("name: ") print(lookup_number(phone_list, name)) elif menu_choice == 5: filename = input("filename to load: ") load_numbers(phone_list, filename) elif menu_choice == 6: filename = input("filename to save: ") save_numbers(phone_list, filename) elif menu_choice == 7: break else: print_menu() print("goodbye") notice that it now includes saving and loading files. here is some output of my running it twice: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 2 add name and number name: jill number: 1234 type in a number (1-7): 2 add name and number name: fred number: 4321 type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 6 filename to save: numbers.txt type in a number (1-7): 7 goodbye 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 5 filename to load: numbers.txt type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 7 goodbye the new portions of this program are: def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() first we will look at the save portion of the program. first it creates a file object with the command open(filename, "wt"). next it goes through and creates a line for each of the phone numbers with the command out_file.write(k + "," + v + "\n"). this writes out a line that contains the name, a comma, the number and follows it by a newline. the loading portion is a little more complicated. it starts by getting a file object. then it uses a while true: loop to keep looping until a break statement is encountered. next it gets a line with the line in_line = in_file.readline(). the readline function will return an empty string when the end of the file is reached. the if statement checks for this and breaks out of the while loop when that happens. of course if the readline function did not return the newline at the end of the line there would be no way to tell if an empty string was an empty line or the end of the file so the newline is left in what readline returns. hence we have to get rid of the newline. the line in_line = in_line[:-1] does this for us by dropping the last character. next the line name, number = in_line.split(",") splits the line at the comma into a name and a number. this is then added to the numbers dictionary. advanced use of .txt files you might be saying to yourself, "well i know how to read and write to a textfile, but what if i want to print the file without opening out another program?" there are a few different ways to accomplish this. the easiest way does open another program, but everything is taken care of in the python code, and doesn't require the user to specify a file to be printed. this method involves invoking the subprocess of another program. remember the file we wrote output to in the above program? let's use that file. keep in mind, in order to prevent some errors, this program uses concepts from the next chapter. please feel free to revisit this example after the next chapter. import subprocess def main(): try: print("this small program invokes the print function in the notepad application") #lets print the file we created in the program above subprocess.call(['notepad','/p','numbers.txt']) except windowserror: print("the called subprocess does not exist, or cannot be called.") main() the subprocess.call takes three arguments. the first argument in the context of this example, should be the name of the program which you would like to invoke the printing subprocess from. the second argument should be the specific subprocess within that program. for simplicity, just understand that in this program, '/p' is the subprocess used to access your printer through the specified application. the last argument should be the name of the file you want to send to the printing subprocess. in this case, it is the same file used earlier in this chapter. exercises now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. solution now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = { } def load_grades(gradesfile): inputfile = open(gradesfile, "r") grades = [ ] while true: student_and_grade = inputfile.readline() student_and_grade = student_and_grade[:-1] if not student_and_grade: break else: studentname, studentgrades = student_and_grade.split(",") studentgrades = studentgrades.split(" ") students[studentname] = studentgrades inputfile.close() print("grades loaded.") def save_grades(gradesfile): outputfile = open(gradesfile, "w") for k, v in students.items(): outputfile.write(k + ",") for x in v: outputfile.write(str(x) + " ") outputfile.write("\n") outputfile.close() print("grades saved.") def print_menu(): print("1. add student") print("2. remove student") print("3. load grades") print("4. record grade") print("5. print grades") print("6. save grades") print("7. print menu") print("9. quit") def print_all_grades(): if students: keys = sorted(students.keys()) print('\t', end=' ') for x in assignments: print(x, '\t', end=' ') print() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) else: print("there are no grades to print.") def print_grades(grades): for x in grades: print(x, '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 9: print() menu_choice = int(input("menu choice: ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(assignments) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: gradesfile = input("load grades from which file? ") load_grades(gradesfile) elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i,x in enumerate(assignments): print(i + 1, x, '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 if 0 <= which < len(grades): grade = input("grade: ") # change from float(input()) to input() to avoid an error when saving grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice == 5: print_all_grades() elif menu_choice == 6: gradesfile = input("save grades to which file? ") save_grades(gradesfile) elif menu_choice != 9: print_menu() non-programmer's tutorial for python 3 ← revenge of the strings print version dealing with the imperfect → 18. dealing with the imperfect ...or how to handle errors closing files with with we use the "with" statement to open and close files.[1][2] with open("in_test.txt", "rt") as in_file: with open("out_test.txt", "wt") as out_file: text = in_file.read() data = parse(text) results = encode(data) out_file.write(results) print( "all done." ) if some sort of error happens anywhere in this code (one of the files is inaccessible, the parse() function chokes on corrupt data, etc.) the "with" statements guarantee that all the files will eventually be properly closed. closing a file just means that the file is "cleaned up" and "released" by our program so that it can be used in another program. to do: is the "closing files with with" section too much detail for a non-programmers tutorial? if so, move it to some other python wikibook (subject:python programming language) catching errors with try so you now have the perfect program, it runs flawlessly, except for one detail, it will crash on invalid user input. have no fear, for python has a special control structure for you. it's called try and it tries to do something. here is an example of a program with a problem: print("type control c or -1 to exit") number = 1 while number != -1: number = int(input("enter a number: ")) print("you entered:", number) notice how when you enter @#& it outputs something like: traceback (most recent call last): file "try_less.py", line 4, in <module> number = int(input("enter a number: ")) valueerror: invalid literal for int() with base 10: '\\@#&' as you can see the int() function is unhappy with the number @#& (as well it should be). the last line shows what the problem is; python found a valueerror. how can our program deal with this? what we do is first: put the place where errors may occur in a try block, and second: tell python how we want valueerrors handled. the following program does this: print("type control c or -1 to exit") number = 1 while number != -1: try: number = int(input("enter a number: ")) print("you entered:", number) except valueerror: print("that was not a number.") now when we run the new program and give it @#& it tells us "that was not a number." and continues with what it was doing before. when your program keeps having some error that you know how to handle, put code in a try block, and put the way to handle the error in the except block. exercises update at least the phone numbers program (in section dictionaries) so it doesn't crash if a user doesn't enter any data at the menu. solution def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: try: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() except valueerror: print("that was not a number.") non-programmer's tutorial for python 3 ← file io print version recursion → 19. the end so here we are at the end, or maybe the beginning. this tutorial is on wikibooks, so feel free to make improvements to it. if you want to learn more about python, the python tutorial by guido van rossum has more topics that you can learn about. if you have been following this tutorial, you should be able to understand a fair amount of it. the python programming wikibook can be worth looking at, too. here are few other books which cover python 3: a byte of python by swaroop c h datacamp interactive python 3 tutorial - online hands-on python tutorial by dr. andrew n. harrington subject:python programming language lists other wikibooks related to python. hopefully this book covers everything you have needed to get started programming. thanks to everyone who has sent me emails about it. i enjoyed reading them, even when i have not always been the best replier. happy programming, may it change your life and the world. non-programmer's tutorial for python 3 ← intro to imported libraries and other functions print version faq → 20. faq how do i make a gui in python? you can use one of these library: tkinter, pyqt, pygobject. for really simple graphics, you can use the turtle graphics mode import turtle how do i make a game in python? the best method is probably to use pygame at http://pygame.org/ how do i make an executable from a python program? short answer: python is an interepreted language so that is impossible. long answer is that something similar to an executable can be created by taking the python interpreter and the file and joining them together and distributing that. for more on that problem see http://www.python.org/doc/faq/programming/#how-can-i-create-a-stand-alone-binary-from-a-python-script (ifaq) why do you use first person in this tutorial? once upon a time in a different millenia, (1999 to be exact), an earlier version was written entirely by josh cogliati, and it was up on his webpage http://www.honors.montana.edu/~jjc/easytut and it was good. then the server rupert, like all good things than have a beginning came to an end, and josh moved it to wikibooks, but the first person writing stuck. if someone really wants to change it, i will not revert it, but i don't see much point. (the webpage has since moved to http://jjc.freeshell.org/easytut/ and http://jjc.freeshell.org/easytut3/ ) my question is not answered. ask on the discussion page or add it to this faq, or email one of the authors. for other faqs, you may want to see the python 2.6 version of this page non-programmer's tutorial for python 2.6/faq, or the python faq. non-programmer's tutorial for python 3 ← the end print version ↑ "the 'with' statement" ↑ 'the python "with" statement by example' retrieved from "https://en.wikibooks.org/w/index.php?title=non-programmer%27s_tutorial_for_python_3/print_version&oldid=3412786" this is the print version of non-programmer's tutorial for python 3you won't see this message or any elements not part of the book's content when you print or preview this page. non-programmer's tutorial for python 3 the current, editable version of this book is available in wikibooks, the open-content textbooks collection, at https://en.wikibooks.org/wiki/non-programmer%27s_tutorial_for_python_3 permission is granted to copy, distribute, and/or modify this document under the terms of the creative commons attribution-sharealike 3.0 license. contents 1 1. front matter 1.1 other resources 2 2. intro 2.1 first things first 2.2 installing python 2.2.1 linux, bsd, and unix users 2.2.2 mac users 2.2.3 windows users 2.2.3.1 configuring your path environment variable 2.3 interactive mode 2.4 creating and running programs 2.4.1 program file names 2.5 using python from the command line 2.5.1 running python programs in *nix 2.6 where to get help 2.6.1 python documentation 2.6.2 python user community 3 3. hello, world 3.1 what you should know 3.2 printing 3.2.1 terminology 3.2.2 \n in printing 3.3 expressions 3.3.1 arithmetic expressions 3.4 commenting in python 3.5 examples 3.6 exercises 3.6.1 footnotes 4 4. who goes there? 4.1 input and variables 4.2 assignment 4.3 examples 4.4 exercises 5 5. count to 10 5.1 while loops 5.1.1 infinite loops or never ending loop 5.2 examples 5.2.1 fibonacci sequence 5.2.2 enter password 5.3 exercises 6 6. decisions 6.1 if statement 6.2 examples 6.3 exercises 7 7. debugging 7.1 what is debugging? 7.2 what should the program do? 7.3 what does the program do? 7.4 how do i fix my program? 8 8. defining functions 8.1 creating functions 8.2 variables in functions 8.3 examples 8.4 exercises 9 9. advanced functions example 9.1 recursion 9.2 examples 10 10. lists 10.1 variables with more than one value 10.2 more features of lists 10.3 examples 10.4 exercises 11 11. for loops 12 12. boolean expressions 12.1 a note on boolean operators 12.2 examples 12.3 exercises 13 13. dictionaries 14 14. using modules 14.1 exercises 14.2 other modules 14.2.1 creating your own module 14.2.1.1 the __name__ == __main__ trick 14.2.2 the pip module 15 15. more on lists 16 16. revenge of the strings 16.1 slicing strings (and lists) 16.2 examples 17 17. file io 17.1 file i/o 17.2 advanced use of .txt files 17.3 exercises 18 18. dealing with the imperfect 18.1 ...or how to handle errors 18.2 closing files with with 18.3 catching errors with try 18.4 exercises 19 19. the end 20 20. faq 1. front matter all example python source code in this tutorial is granted to the public domain. therefore you may modify it and relicense it under any license you please. since you are expected to learn programming, the creative commons attribution-sharealike license would require you to keep all programs that are derived from the source code in this tutorial under that license. since the python source code is granted to the public domain, that requirement is waived. this tutorial is more or less a conversion of non-programmer's tutorial for python 2.6. older versions and some versions in korean, spanish, italian and greek are available from http://jjc.freeshell.org/easytut/ the non-programmers' tutorial for python 3 is a tutorial designed to be an introduction to the python programming language. this guide is for someone with no programming experience. if you have programmed in other languages i recommend using python tutorial for programmers written by guido van rossum. if you have any questions or comments please use the discussion pages or see authors page for author contact information. i welcome questions and comments about this tutorial. i will try to answer any questions you have as best i can. thanks go to james a. brown for writing most of the windows install info. thanks also to elizabeth cogliati for complaining enough :) about the original tutorial (that is almost unusable for a non-programmer), for proofreading, and for many ideas and comments on it. thanks to joe oppegaard for writing almost all the exercises. thanks to everyone i have missed. other resources python home page python 3 documentation a byte of python by swaroop c h porting to python 3: an in-depth guide non-programmer's tutorial for python 3 ← authors print version intro → 2. intro first things first so, you've never programmed before. as we go through this tutorial, i will attempt to teach you how to program. there really is only one way to learn to program. you must read code and write code (as computer programs are often called). i'm going to show you lots of code. you should type in code that i show you to see what happens. play around with it and make changes. the worst that can happen is that it won't work. when i type in code it will be formatted like this: # python is easy to learn print("hello, world!") that's so it is easy to distinguish from the other text. if you're reading this on the web, you'll notice the code is in color -- that's just to make it stand out, and to make the different parts of the code stand out from each other. the code you enter will probably not be colored, or the colors may be different, but it won't affect the code as long as you enter it the same way as it's printed here. if the computer prints something out it will be formatted like this: hello, world! (note that printed text goes to your screen, and does not involve paper. before computers had screens, the output of computer programs would be printed on paper.) note that this is a python 3 tutorial, which means that most of the examples will not work in python 2.7 and before. as well, all but a small number of the extra python 2.7 libraries (third-party libraries) have been converted to python 3. most likely you will want to learn python 3, but if you are learning python for a specific package or set of modules that are only written in python 2.7, you may want to consider learning from the non-programmer's tutorial for python 2.6. however, the differences between python 2 and 3 are not particularly large, so if you learn one, you should be able to read programs written for the other without much difficulty. there will often be a mixture of the text you type (which is shown in bold) and the text the program prints to the screen, which would look like this: halt! who goes there? josh you may pass, josh (some of the tutorial has not been converted to this format. since this is a wiki, you can convert it when you find it.) i will also introduce you to the terminology of programming - for example, that programming is often referred to as coding or hacking. this will not only help you understand what programmers are talking about, but also help the learning process. now, on to more important things. in order to program in python you need the python 3 software. if you don't already have the python software go to www.python.org/download and get the proper version for your platform. download it, read the instructions and get it installed. installing python for python programming you need a working python installation and a text editor. python comes with its own editor, idle, which is quite nice and totally sufficient for the beginning. as you get more into programming, you will probably switch to some other editor like nano, emacs, vi or another. the python download page is http://www.python.org/download. the most recent version is python 3.8.5 (as of july 2020); python 2.7 and older versions will not work with this tutorial. there are various different installation files for different computer platforms available on the download site. here are some specific instructions for the most common operating systems: linux, bsd, and unix users you are probably lucky and python is already installed on your machine. to test it type python3 on a command line. if you see something like what is shown in the following section, you are set. idle may need to be installed separately, from its own package such as idle3 or as part of python-tools. if you have to install python, first try to use the operating system's package manager or go to the repository where your packages are available and get python 3. python 3.0 was released in december 2008; all distributions should have python 3 available, so you may not need to compile it from scratch. ubuntu and fedora do have python 3 binary packages available, but they are not yet the default, so they need to be installed specially. roughly, here are the steps to compile python from source code in unix (if these totally don't make sense, you may want to read another introduction to *nix, such as introduction to linux): download the .tgz file (use your web browser to get the gzipped tar file from https://www.python.org/ftp/python/3.7.4/python-3.7.4.tgz) uncompress the tar file (put in the correct path to where you downloaded it): $ tar -xvzf ~/download/python-3.7.4.tgz ... list of files as they are uncompressed change to the directory and tell the computer to compile and install the program $ cd python-3.7/ $ ./configure --prefix=$home/python3_install ... lots of output. watch for error messages here ... $ make ... even more output. hopefully no error messages ... $ make install add python 3 to your path. you can test it first by specifying the full path. you should add $home/python3_install/bin to your path bash variable. $ ~/python3_install/bin/python3 python 3.7.4 (... size and date information ...) [gcc 9.1.0] on linux type "help", "copyright", "credits" or "license" for more information. >>> the above commands will install python 3 to your home directory, which is probably what you want, but if you skip the --prefix=$home/python3_install, it will install it to /usr/local. if you want to use the idle graphical code editor, you need to make sure that the tk and tcl libraries, together with their development files, are installed on the system. you will get a warning during the make phase if these are not available. mac users starting from mac os x tiger (10.4), versions of python 2 shipped with the operating system by default, but you will need to also install python 3 unless mac os starts including python 3 (check the version by starting python3 in a command line terminal). also idle (the python editor) might be missing in the standard installation. if you want to (re-)install python, get the mac os installer from the python download site. windows users download the appropriate windows installer (the x86 msi installer, if you do not have a 64-bit amd or intel chip). start the installer by double-clicking it and follow the prompts. see https://docs.python.org/3/using/windows.html#installing-python for more information. configuring your path environment variable the path environment variable is a list of folders, separated by semicolons, in which windows will look for a program whenever you try to execute one by typing its name at a command prompt. you can see the current value of your path by typing this command at a command prompt: echo %path% the easiest way to permanently change environment variables is to bring up the built-in environment variable editor in windows. how you get to this editor is slightly different on different versions of windows. on windows 8 or windows 10: press the windows key and type control panel to locate the windows control panel. once you've opened the control panel, select view by: large icons, then click on system. in the window that pops up, click the advanced system settings link, then click the environment variables... button. on windows 7 or vista: click the start button in the lower-left corner of the screen, move your mouse over computer, right-click, and select properties from the pop-up menu. click the advanced system settings link, then click the environment variables... button. once you've brought up the environment variable editor, you'll do the same thing regardless of which version of windows you're running. under system variables in the bottom half of the editor, find a variable called path. if there is is one, select it and click edit.... assuming your python root is c:\python37, add these two folders to your path (and make sure you get the semicolons right; there should be a semicolon between each folder in the list): c:\python37 c:\python37\scripts note: if you want to double-click and start your python programs from a windows folder and not have the console window disappear, you can add the following code to the bottom of each script: #stops console from exiting end_prog = "" while end_prog != "q": end_prog = input("type q to quit") interactive mode go into idle (also called the python gui). you should see a window that has some text like this: python 3.0 (r30:67503, dec 29 2008, 21:31:07) [gcc 4.3.2 20081105 (red hat 4.3.2-7)] on linux2 type "copyright", "credits" or "license()" for more information. **************************************************************** personal firewall software may warn about the connection idle makes to its subprocess using this computer's internal loopback interface. this connection is not visible on any external interface and no data is sent to or received from the internet. **************************************************************** idle 3.0 >>> the >>> is python's way of telling you that you are in interactive mode. in interactive mode what you type is immediately run. try typing 1+1 in. python will respond with 2. interactive mode allows you to test out and see what python will do. if you ever feel you need to play with new python statements, go into interactive mode and try them out. creating and running programs go into idle if you are not already. in the menu at the top, select file then new file. in the new window that appears, type the following: print("hello, world!") now save the program: select file from the menu, then save. save it as "hello.py" (you can save it in any folder you want). now that it is saved it can be run. next run the program by going to run then run module (or if you have an older version of idle use edit then run script). this will output hello, world! on the *python shell* window. for a more in-depth introduction to idle, a longer tutorial with screenshots can be found at http://hkn.eecs.berkeley.edu/~dyoo/python/idle_intro/index.html. program file names it is very useful to stick to some rules regarding the file names of python programs. otherwise some things might go wrong unexpectedly. these don't matter as much for programs, but you can have weird problems if you don't follow them for module names (modules will be discussed later). always save the program with the extension .py. do not put another dot anywhere else in the file name. only use standard characters for file names: letters, numbers, dash (-) and underscore (_). white space (" ") should not be used at all (use underscores instead). do not use anything other than a letter (particularly no numbers!) at the beginning of a file name. do not use "non-english" characters (such as å, ɓ, ç, ð, é, õ, ü) in your file names—or, even better, do not use them at all when programming. do not use module names for file names (such as print.py, math.py, list.py) using python from the command line if you don't want to use python from the command line, you don't have to, just use idle. to get into interactive mode just type python3 without any arguments. to run a program, create it with a text editor (emacs has a good python mode) and then run it with python3 program_name. running python programs in *nix if you are using unix (such as linux, mac os, or bsd), if you make the program executable with chmod, and have as the first line: #!/usr/bin/env python3 you can run the python program with ./hello.py like any other command. where to get help at some point in your python career you will probably get stuck and have no clue about how to solve the problem you are supposed to work on. this tutorial only covers the basics of python programming, but there is a lot of further information available. python documentation first of all, python is very well documented. there might even be copies of these documents on your computer that came with your python installation: the official python 3 tutorial by guido van rossum is often a good starting point for general questions. for questions about standard modules (you will learn what these are later), the python 3 library reference is the place to look. if you really want to get to know something about the details of the language, the python 3 reference manual is comprehensive but quite complex for beginners. python user community there are a lot of other python users out there, and usually they are nice and willing to help you. this very active user community is organised mostly through mailing lists and a newsgroup: the tutor mailing list is for folks who want to ask questions regarding how to learn computer programming with the python language. the python-help mailing list is python.org's help desk. you can ask a group of knowledgeable volunteers questions about all your python problems. the python newsgroup comp.lang.python (google groups archive) is the place for general python discussions, questions and the central meeting point of the community. python wiki has a list of local user groups, you can join the group mailing list and ask questions. you can also participate in the user group meetings. learnpython subreddit is another location where beginner level questions can be asked. in order not to reinvent the wheel and discuss the same questions again and again, people will appreciate very much if you do a web search for a solution to your problem before contacting these lists! non-programmer's tutorial for python 3 ← front matter print version hello, world → 3. hello, world what you should know once you've read and mastered this chapter, you should know how to edit programs in a text editor or idle, save them to the hard disk, and run them once they have been saved. printing programming tutorials since the beginning of time have started with a little program called "hello, world!"[1] so here it is: print("hello, world!") if you are using the command line to run programs then type it in with a text editor, save it as hello.py and run it with python3 hello.py otherwise go into idle, create a new window, and create the program as in section creating and running programs. when this program is run here's what it prints: hello, world! now i'm not going to tell you this every time, but when i show you a program i recommend that you type it in and run it. i learn better when i type it in and you probably do too. now here is a more complicated program: print("jack and jill went up a hill") print("to fetch a pail of water;") print("jack fell down, and broke his crown,") print("and jill came tumbling after.") when you run this program it prints out: jack and jill went up a hill to fetch a pail of water; jack fell down, and broke his crown, and jill came tumbling after. when the computer runs this program it first sees the line: print("jack and jill went up a hill") so the computer prints: jack and jill went up a hill then the computer goes down to the next line and sees: print("to fetch a pail of water;") so the computer prints to the screen: to fetch a pail of water; the computer keeps looking at each line, follows the command and then goes on to the next line. the computer keeps running commands until it reaches the end of the program. terminology now is probably a good time to give you a bit of an explanation of what is happening - and a little bit of programming terminology. what we were doing above was using a function called print. the function's name - print - is followed by parentheses containing zero or more arguments. so in this example print("hello, world!") there is one argument, which is "hello, world!". note that this argument is a group of characters enclosed in double quotes (""). this is commonly referred to as a string of characters, or string, for short. another example of a string is "jack and jill went up a hill". the combination of a function and parentheses with the arguments is a function call. a function and its arguments are one type of statement that python has, so print("hello, world!") is an example of a statement. basically, you can think of a statement as a single line in a program. that's probably more than enough terminology for now. \n in printing \n in printing makes the strings after the \n in a new line,here is an example: print("hello, world!\nwhat should i do?") here is the output: hello, world! what should i do? it can be used to put a bunch of strings that are supposed to be on different lines into 1 print statement instead of making multiple print statements expressions here is another program: print("2 + 2 is", 2 + 2) print("3 * 4 is", 3 * 4) print("100 - 1 is", 100 - 1) print("(33 + 2) / 5 + 11.5 is", (33 + 2) / 5 + 11.5) and here is the output when the program is run: 2 + 2 is 4 3 * 4 is 12 100 - 1 is 99 (33 + 2) / 5 + 11.5 is 18.5 as you can see, python can turn your thousand-dollar computer into a five-dollar calculator. arithmetic expressions in this example, the print function is followed by two arguments, with each of the arguments separated by a comma. so with the first line of the program print("2 + 2 is", 2 + 2) the first argument is the string "2 + 2 is" and the second argument is the arithmetic expression 2 + 2, which is one kind of expression. what is important to note is that a string is printed as is (without the enclosing double quotes), but an expression is evaluated, or converted to its actual value. python has seven basic operations for numbers: operation symbol example power (exponentiation) ** 5 ** 2 == 25 multiplication * 2 * 3 == 6 division / 14 / 3 == 4.666666666666667 integer division // 14 // 3 == 4 remainder (modulo) % 14 % 3 == 2 addition + 1 + 2 == 3 subtraction - 4 - 3 == 1 notice that there are two ways to do division, one that returns the repeating decimal, and the other that can get the remainder and the whole number. the order of operations is the same as in math: parentheses () exponents ** multiplication *, division /, integer division //, and remainder % addition + and subtraction - so use parentheses to structure your formulas when needed. commenting in python often in programming, you are doing something complicated and may not in the future remember what you did. when this happens the program should probably be commented. a comment is a note to you and other programmers explaining what is happening. for example: # not quite pi, but a credible simulation print(22 / 7) which outputs 3.14285714286 notice that the comment starts with a hash: #. comments are used to communicate with others who read the program and your future self to make clear what is complicated. note that any text can follow comment and that when the program is run, the text after the # through to the end of that line is ignored. the # does not have to be at the beginning of a new line: # output pi on the screen print(22 / 7) # well, just a good approximation examples each chapter (eventually) will contain examples of the programming features introduced in the chapter. you should at least look over them and see if you understand them. if you don't, you may want to type them in and see what happens. mess around with them, change them and see what happens. denmark.py print("something's rotten in the state of denmark.") print(" -- shakespeare") output: something's rotten in the state of denmark. -- shakespeare school.py # this is not quite true outside of usa # and is based on my dim memories of my younger years print("firstish grade") print("1 + 1 =", 1 + 1) print("2 + 4 =", 2 + 4) print("5 - 2 =", 5 - 2) print() print("thirdish grade") print("243 - 23 =", 243 - 23) print("12 * 4 =", 12 * 4) print("12 / 3 =", 12 / 3) print("13 / 3 =", 13 // 3, "r", 13 % 3) print() print("junior high") print("123.56 - 62.12 =", 123.56 - 62.12) print("(4 + 3) * 2 =", (4 + 3) * 2) print("4 + 3 * 2 =", 4 + 3 * 2) print("3 ** 2 =", 3 ** 2) output: firstish grade 1 + 1 = 2 2 + 4 = 6 5 - 2 = 3 thirdish grade 243 - 23 = 220 12 * 4 = 48 12 / 3 = 4 13 / 3 = 4 r 1 junior high 123.56 - 62.12 = 61.44 (4 + 3) * 2 = 14 4 + 3 * 2 = 10 3 ** 2 = 9 exercises write a program that prints your full name and your birthday as separate strings. write a program that shows the use of all 7 arithmetic operations. solution 1. write a program that prints your full name and your birthday as separate strings. print("ada lovelace", "born on", "november 27, 1852") print("albert einstein", "born on", "14 march 1879") print(("john smith"), ("born on"), ("14 march 1879")) solution 2. write a program that shows the use of all 7 arithmetic operations. print("5**5 = ", 5**5) print("6*7 = ", 6*7) print("56/8 = ", 56/8) print("14//6 = ", 14//6) print("14%6 = ", 14%6) print("5+6 = ", 5+6) print("9-0 = ", 9-0) footnotes ↑ here is a great list of the famous "hello, world!" program in many programming languages. just so you know how simple python can be... non-programmer's tutorial for python 3 ← intro print version who goes there? → 4. who goes there? input and variables now i feel it is time for a really complicated program. here it is: print("halt!") user_input = input("who goes there? ") print("you may pass,", user_input) when i ran it, here is what my screen showed: halt! who goes there? josh you may pass, josh note: after running the code by pressing f5, the python shell will only give output: halt! who goes there? you need to enter your name in the python shell, and then press enter for the rest of the output. of course when you run the program your screen will look different because of the input() statement. when you ran the program you probably noticed (you did run the program, right?) how you had to type in your name and then press enter. then the program printed out some more text and also your name. this is an example of input. the program reaches a certain point and then waits for the user to input some data that the program can use later. of course, getting information from the user would be useless if we didn't have anywhere to put that information and this is where variables come in. in the previous program user_input is a variable. variables are like a box that can store some piece of data. here is a program to show examples of variables: a = 123.4 b23 = 'spam' first_name = "bill" b = 432 c = a + b print("a + b is",c) print("first_name is",first_name) print("sorted parts, after midnight or",b23) and here is the output: a + b is 555.4 first_name is bill sorted parts, after midnight or spam variables store data. the variables in the above program are a, b23, first_name, b, and c. the two basic types are strings and numbers. strings are a sequence of letters, numbers and other characters. in this example b23 and first_name are variables that are storing strings. spam, bill, a + b is, first_name is, and sorted parts, after midnight or are the strings in this program. the characters are surrounded by " or '. the other type of variables are numbers. remember that variables are used to store a value, they do not use quotation marks (" and '). if you want to use an actual value, you must use quotation marks. value1 == pim value2 == "pim" both look the same, but in the first one python checks if the value stored in the variable value1 is the same as the value stored in the variable pim. in the second one, python checks if the string (the actual letters p,i, and m) are the same as in value2 (continue this tutorial for more explanation about strings and about the ==). assignment okay, so we have these boxes called variables and also data that can go into the variable. the computer will see a line like first_name = "bill" and it reads it as "put the string bill into the box (or variable) first_name". later on it sees the statement c = a + b and it reads it as "put the sum of a + b or 123.4 + 432 which equals 555.4 into c". the right hand side of the statement (a + b) is evaluated and the result is stored in the variable on the left hand side (c). this is called assignment, and you should not confuse the assignment equal sign (=) with "equality" in a mathematical sense here (that's what == will be used for later). here is another example of variable usage: a = 1 print(a) a = a + 1 print(a) a = a * 2 print(a) and of course here is the output: 1 2 4 even if the same variable appears on both sides of the equals sign (e.g., spam = spam), the computer still reads it as, "first find out the data to store and then find out where the data goes." one more program before i end this chapter: number = float(input("type in a number: ")) integer = int(input("type in an integer: ")) text = input("type in a string: ") print("number =", number) print("number is a", type(number)) print("number * 2 =", number * 2) print("integer =", integer) print("integer is a", type(integer)) print("integer * 2 =", integer * 2) print("text =", text) print("text is a", type(text)) print("text * 2 =", text * 2) the output i got was: type in a number: 12.34 type in an integer: -3 type in a string: hello number = 12.34 number is a <class 'float'> number * 2 = 24.68 integer = -3 integer is a <class 'int'> integer * 2 = -6 text = hello text is a <class 'str'> text * 2 = hellohello notice that number was created with float(input()) ,int(input()) returns an integer, a number with no decimal point, while text created with input() returns a string(can be writen as str(input()), too). when you want the user to type in a decimal use float(input()), if you want the user to type in an integer use int(input()), but if you want the user to type in a string use input(). the second half of the program uses the type() function which tells what kind a variable is. numbers are of type int or float, which are short for integer and floating point (mostly used for decimal numbers), respectively. text strings are of type str, short for string. integers and floats can be worked on by mathematical functions, strings cannot. notice how when python multiplies a number by an integer the expected thing happens. however when a string is multiplied by an integer the result is that multiple copies of the string are produced (i.e., text * 2 = hellohello). operations with strings do different things than operations with numbers. as well, some operations only work with numbers (both integers and floating point numbers) and will give an error if a string is used. here are some interactive mode examples to show that some more. >>> print("this" + " " + "is" + " joined.") this is joined. >>> print("ha, " * 5) ha, ha, ha, ha, ha, >>> print("ha, " * 5 + "ha!") ha, ha, ha, ha, ha, ha! >>> print(3 - 1) 2 >>> print("3" - "1") traceback (most recent call last): file "<stdin>", line 1, in <module> typeerror: unsupported operand type(s) for -: 'str' and 'str' >>> here is the list of some string operations: operation symbol example repetition * "i" * 5 == "iiiii" concatenation + "hello, " + "world!" == "hello, world!" examples rate_times.py # this program calculates rate and distance problems print("input a rate and a distance") rate = float(input("rate: ")) distance = float(input("distance: ")) time=(distance/ rate) print("time:", time) sample runs: input a rate and a distance rate: 5 distance: 10 time: 2.0 input a rate and a distance rate: 3.52 distance: 45.6 time: 12.9545454545 area.py # this program calculates the perimeter and area of a rectangle print("calculate information about a rectangle") length = float(input("length: ")) width = float(input("width: ")) perimeter=(2 * length + 2 * width) print("area:", length * width) print("perimeter:",perimeter) sample runs: calculate information about a rectangle length: 4 width: 3 area: 12.0 perimeter: 14.0 calculate information about a rectangle length: 2.53 width: 5.2 area: 13.156 perimeter: 15.46 temperature.py # this program converts fahrenheit to celsius fahr_temp = float(input("fahrenheit temperature: ")) celc_temp = (fahr_temp - 32.0) *( 5.0 / 9.0) print("celsius temperature:", celc_temp) sample runs: fahrenheit temperature: 32 celsius temperature: 0.0 fahrenheit temperature: -40 celsius temperature: -40.0 fahrenheit temperature: 212 celsius temperature: 100.0 fahrenheit temperature: 98.6 celsius temperature: 37.0 exercises write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. solution write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. string1 = input('string 1: ') string2 = input('string 2: ') float1 = float(input('number 1: ')) float2 = float(input('number 2: ')) print(string1 + string2) print(float1 * float2) non-programmer's tutorial for python 3 ← hello, world print version count to 10 → 5. count to 10 while loops presenting our first control structure. ordinarily the computer starts with the first line and then goes down from there. control structures change the order that statements are executed or decide if a certain statement will be run. here's the source for a program that uses the while control structure: a = 0 # first, set the initial value of the variable a to 0(zero). while a < 10: # while the value of the variable a is less than 10 do the following: a = a + 1 # increase the value of the variable a by 1, as in: a = a + 1! print(a) # print to screen what the present value of the variable a is. # repeat! until the value of the variable a is equal to 9!? see note. # note: # the value of the variable a will increase by 1 # with each repeat, or loop of the 'while statement block'. # e.g. a = 1 then a = 2 then a = 3 etc. until a = 9 then... # the code will finish adding 1 to a (now a = 10), printing the # result, and then exiting the 'while statement block'. # -- # while a < 10: | # a = a + 1 |<--[ the while statement block ] # print (a) | # -- and here is the extremely exciting output: 1 2 3 4 5 6 7 8 9 10 (and you thought it couldn't get any worse after turning your computer into a five-dollar calculator?) so what does the program do? first it sees the line a = 0 and sets a to zero. then it sees while a < 10: and so the computer checks to see if a < 10. the first time the computer sees this statement, a is zero, so it is less than 10. in other words, as long as a is less than ten, the computer will run the tabbed in statements. this eventually makes a equal to ten (by adding one to a again and again) and the while a < 10 is not true any longer. reaching that point, the program will stop running the indented lines. always remember to put a colon ":" at the end of the while statement line! here is another example of the use of while: a = 1 s = 0 print('enter numbers to add to the sum.') print('enter 0 to quit.') while a != 0: print('current sum:', s) a = float(input('number? ')) s = s + a print('total sum =', s) enter numbers to add to the sum. enter 0 to quit. current sum: 0 number? 200 current sum: 200.0 number? -15.25 current sum: 184.75 number? -151.85 current sum: 32.9 number? 10.00 current sum: 42.9 number? 0 total sum = 42.9 notice how print('total sum =', s) is only run at the end. the while statement only affects the lines that are indented with whitespace. the != means does not equal so while a != 0: means as long as a is not zero run the tabbed statements that follow. note that a is a floating point number, and not all floating point numbers can be accurately represented, so using != on them can sometimes not work. try typing in 1.1 in interactive mode. infinite loops or never ending loop now that we have while loops, it is possible to have programs that run forever. an easy way to do this is to write a program like this: while 1 == 1: print("help, i'm stuck in a loop.") the "==" operator is used to test equality of the expressions on the two sides of the operator, just as "<" was used for "less than" before (you will get a complete list of all comparison operators in the next chapter). this program will output help, i'm stuck in a loop. until the heat death of the universe or you stop it, because 1 will forever be equal to 1. the way to stop it is to hit the control (or ctrl) button and c (the letter) at the same time. this will kill the program. (note: sometimes you will have to hit enter after the control-c.) on some systems, nothing will stop it, short of killing the process--so avoid! examples fibonacci sequence fibonacci-method1.py # this program calculates the fibonacci sequence a = 0 b = 1 count = 0 max_count = 20 while count < max_count: count = count + 1 print(a, end=" ") # notice the magic end=" " in the print function arguments # that keeps it from creating a new line. old_a = a # we need to keep track of a since we change it. a = b b = old_a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 note that the output is on a single line because of the extra argument end=" " in the print arguments. fibonacci-method2.py # simplified and faster method to calculate the fibonacci sequence a = 0 b = 1 count = 0 max_count = 10 while count < max_count: count = count + 1 print(a, b, end=" ") # notice the magic end=" " a = a + b b = a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 fibonacci-method3.py a = 0 b = 1 count = 0 maxcount = 20 #once loop is started we stay in it while count < maxcount: count += 1 olda = a a = a + b b = olda print(olda,end=" ") print() output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 enter password password.py # waits until a password has been entered. use control-c to break out without # the password #note that this must not be the password so that the # while loop runs at least once. password = str() # note that != means not equal while password != "unicorn": password = input("password: ") print("welcome in") sample run: password: auo password: y22 password: password password: open sesame password: unicorn welcome in exercises write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. solution write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. name = input("what is your username: ") password = input("what is your password: ") print("to lock your computer type lock.") command = none input1 = none input2 = none while command != "lock": command = input("what is your command: ") while input1 != name: input1 = input("what is your username: ") while input2 != password: input2 = input("what is your password: ") print("welcome back to your system!") if you would like the program to run continuously, just add a while 1 == 1: loop around the whole thing. you will have to indent the rest of the program when you add this at the top of the code, but don't worry, you don't have to do it manually for each line! just highlight everything you want to indent and click on "indent" under "format" in the top bar of the python window. another way of doing this could be: name = input('set name: ') password = input('set password: ') while 1 == 1: nameguess="" passwordguess="" key="" while (nameguess != name) or (passwordguess != password): nameguess = input('name? ') passwordguess = input('password? ') print("welcome,", name, ". type lock to lock.") while key != "lock": key = input("") notice the or in while (nameguess != name) or (passwordguess != password), which we haven't yet introduced. you can probably figure out how it works. non-programmer's tutorial for python 3 ← who goes there? print version decisions → 6. decisions if statement as always, i believe i should start each chapter with a warm-up typing exercise, so here is a short program to compute the absolute value of an integer: n = int(input("number? ")) if n < 0: print("the absolute value of", n, "is", -n) else: print("the absolute value of", n, "is", n) here is the output from the two times that i ran this program: number? -34 the absolute value of -34 is 34 number? 1 the absolute value of 1 is 1 so what does the computer do when it sees this piece of code? first it prompts the user for a number with the statement "n = int(input("number? "))". next it reads the line "if n < 0:". if n is less than zero python runs the line "print("the absolute value of", n, "is", -n)". otherwise it runs the line "print("the absolute value of", n, "is", n)". more formally python looks at whether the expression n < 0 is true or false. an if statement is followed by an indented block of statements that are run when the expression is true. optionally after the if statement is an else statement and another indented block of statements. this second block of statements is run if the expression is false. there are a number of different tests that an expression can have. here is a table of all of them: operator function < less than <= less than or equal to > greater than >= greater than or equal to == equal != not equal another feature of the if command is the elif statement. it stands for else if and means if the original if statement is false but the elif part is true, then do the elif part. and if neither the if or elif expressions are true, then do what's in the else block. here's an example: a = 0 while a < 10: a = a + 1 if a > 5: print(a, ">", 5) elif a <= 3: print(a, "<=", 3) else: print("neither test was true") and the output: 1 <= 3 2 <= 3 3 <= 3 neither test was true neither test was true 6 > 5 7 > 5 8 > 5 9 > 5 10 > 5 notice how the elif a <= 3 is only tested when the if statement fails to be true. there can be more than one elif expression, allowing multiple tests to be done in a single if statement. examples # this program demonstrates the use of the == operator # using numbers print(5 == 6) # using variables x = 5 y = 8 print(x == y) and the output false false high_low.py # plays the guessing game higher or lower # this should actually be something that is semi random like the # last digits of the time or something else, but that will have to # wait till a later chapter. (extra credit, modify it to be random # after the modules chapter) number = 7 guess = -1 print("guess the number!") while guess != number: guess = int(input("is it... ")) if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") sample run: guess the number! is it... 2 it's bigger... is it... 5 it's bigger... is it... 10 it's not so big. is it... 7 hooray! you guessed it right! even.py # asks for a number. # prints if it is even or odd number = float(input("tell me a number: ")) if number % 2 == 0: print(int(number), "is even.") elif number % 2 == 1: print(int(number), "is odd.") else: print(number, "is very strange.") sample runs: tell me a number: 3 3 is odd. tell me a number: 2 2 is even. tell me a number: 3.4895 3.4895 is very strange. average1.py # keeps asking for numbers until 0 is entered. # prints the average value. count = 0 sum = 0.0 number = 1 # set to something that will not exit the while loop immediately. print("enter 0 to exit the loop") while number != 0: number = float(input("enter a number: ")) if number != 0: count = count + 1 sum = sum + number if number == 0: print("the average was:", sum / count) sample runs sample runs: enter 0 to exit the loop enter a number: 3 enter a number: 5 enter a number: 0 the average was: 4.0 enter 0 to exit the loop enter a number: 1 enter a number: 4 enter a number: 3 enter a number: 0 the average was: 2.66666666667 average2.py # keeps asking for numbers until count numbers have been entered. # prints the average value. #notice that we use an integer to keep track of how many numbers, # but floating point numbers for the input of each number sum = 0.0 print("this program will take several numbers then average them") count = int(input("how many numbers would you like to average: ")) current_count = 0 while current_count < count: current_count = current_count + 1 print("number", current_count) number = float(input("enter a number: ")) sum = sum + number print("the average was:", sum / count) sample runs: this program will take several numbers then average them how many numbers would you like to average: 2 number 1 enter a number: 3 number 2 enter a number: 5 the average was: 4.0 this program will take several numbers then average them how many numbers would you like to average: 3 number 1 enter a number: 1 number 2 enter a number: 4 number 3 enter a number: 3 the average was: 2.66666666667 exercises write a program that asks the user their name, if they enter your name say "that is a nice name", if they enter "john cleese" or "michael palin", tell them how you feel about them ;), otherwise tell them "you have a nice name." solution name = input('your name: ') if name == 'bryn': print('that is a nice name.') elif name == 'john cleese': print('... some funny text.') elif name == 'michael palin': print('... some funny text.') else: print('you have a nice name.') modify the higher or lower program from this section to keep track of how many times the user has entered the wrong number. if it is more than 3 times, print "that must have been complicated." at the end, otherwise print "good job!" solution number = 7 guess = -1 count = 0 print("guess the number!") while guess != number: guess = int(input("is it... ")) count = count + 1 if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") if count > 3: print("that must have been complicated.") else: print("good job!") write a program that asks for two numbers. if the sum of the numbers is greater than 100, print "that is a big number." solution number1 = float(input('1st number: ')) number2 = float(input('2nd number: ')) if number1 + number2 > 100: print('that is a big number.') non-programmer's tutorial for python 3 ← count to 10 print version debugging → 7. debugging what is debugging? "as soon as we started programming, we found to our surprise that it wasn't as easy to get programs right as we had thought. debugging had to be discovered. i can remember the exact instant when i realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs." — maurice wilkes discovers debugging, 1949 by now if you have been messing around with the programs you have probably found that sometimes the program does something you didn't want it to do. this is fairly common. debugging is the process of figuring out what the computer is doing and then getting it to do what you want it to do. this can be tricky. i once spent nearly a week tracking down and fixing a bug that was caused by someone putting an x where a y should have been. this chapter will be more abstract than previous chapters. what should the program do? the first thing to do (this sounds obvious) is to figure out what the program should be doing if it is running correctly. come up with some test cases and see what happens. for example, let's say i have a program to compute the perimeter of a rectangle (the sum of the length of all the edges). i have the following test cases: height width perimeter 3 4 14 2 3 10 4 4 16 2 2 8 5 1 12 i now run my program on all of the test cases and see if the program does what i expect it to do. if it doesn't then i need to find out what the computer is doing. more commonly some of the test cases will work and some will not. if that is the case you should try and figure out what the working ones have in common. for example here is the output for a perimeter program (you get to see the code in a minute): height: 3 width: 4 perimeter = 15 height: 2 width: 3 perimeter = 11 height: 4 width: 4 perimeter = 16 height: 2 width: 2 perimeter = 8 height: 5 width: 1 perimeter = 8 notice that it didn't work for the first two inputs, it worked for the next two and it didn't work on the last one. try and figure out what is in common with the working ones. once you have some idea what the problem is finding the cause is easier. with your own programs you should try more test cases if you need them. what does the program do? the next thing to do is to look at the source code. one of the most important things to do while programming is reading source code. the primary way to do this is code walkthroughs. a code walkthrough starts at the first line, and works its way down until the program is done. while loops and if statements mean that some lines may never be run and some lines are run many times. at each line you figure out what python has done. lets start with the simple perimeter program. don't type it in, you are going to read it, not run it. the source code is: height = int(input("height: ")) width = int(input("width: ")) print("perimeter =", width + height + width + width) question: what is the first line python runs? answer: the first line is always run first. in this case it is: height = int(input("height: ")) what does that line do? prints height: , waits for the user to type a string in, and then converts the string to an integer variable height. what is the next line that runs? in general, it is the next line down which is: width = int(input("width: ")) what does that line do? prints width: , waits for the user to type a number in, and puts what the user types in the variable width. what is the next line that runs? when the next line is not indented more or less than the current line, it is the line right afterwards, so it is: print("perimeter = ", width + height + width + width) (it may also run a function in the current line, but that's a future chapter.) what does that line do? first it prints perimeter = , then it prints the sum of the values contained within the variables, width and height, from width + height + width + width. does width + height + width + width calculate the perimeter properly? let's see, perimeter of a rectangle is the bottom (width) plus the left side (height) plus the top (width) plus the right side (huh?). the last item should be the right side's length, or the height. do you understand why some of the times the perimeter was calculated "correctly"? it was calculated correctly when the width and the height were equal. the next program we will do a code walkthrough for is a program that is supposed to print out 5 dots on the screen. however, this is what the program is outputting: . . . . and here is the program: number = 5 while number > 1: print(".",end=" ") number = number - 1 print() this program will be more complex to walkthrough since it now has indented portions (or control structures). let us begin. what is the first line to be run? the first line of the file: number = 5 what does it do? puts the number 5 in the variable number. what is the next line? the next line is: while number > 1: what does it do? well, while statements in general look at their expression, and if it is true they do the next indented block of code, otherwise they skip the next indented block of code. so what does it do right now? if number > 1 is true then the next two lines will be run. so is number > 1? the last value put into number was 5 and 5 > 1 so yes. so what is the next line? since the while was true the next line is: print(".",end=" ") what does that line do? prints one dot and since the extra argument end=" " exists the next printed text will not be on a different screen line. what is the next line? number = number - 1 since that is following line and there are no indent changes. what does it do? it calculates number - 1, which is the current value of number (or 5) subtracts 1 from it, and makes that the new value of number. so basically it changes number's value from 5 to 4. what is the next line? well, the indent level decreases so we have to look at what type of control structure it is. it is a while loop, so we have to go back to the while clause which is while number > 1: what does it do? it looks at the value of number, which is 4, and compares it to 1 and since 4 > 1 the while loop continues. what is the next line? since the while loop was true, the next line is: print(".",end=" ") what does it do? it prints a second dot on the line, ending by a space. what is the next line? no indent change so it is: number = number - 1 and what does it do? it takes the current value of number (4), subtracts 1 from it, which gives it 3 and then finally makes 3 the new value of number. what is the next line? since there is an indent change caused by the end of the while loop, the next line is: while number > 1: what does it do? it compares the current value of number (3) to 1. 3 > 1 so the while loop continues. what is the next line? since the while loop condition was true the next line is: print(".",end=" ") and it does what? a third dot is printed on the line. what is the next line? it is: number = number - 1 what does it do? it takes the current value of number (3) subtracts from it 1 and makes the 2 the new value of number. what is the next line? back up to the start of the while loop: while number > 1: what does it do? it compares the current value of number (2) to 1. since 2 > 1 the while loop continues. what is the next line? since the while loop is continuing: print(".",end=" ") what does it do? it discovers the meaning of life, the universe and everything. i'm joking. (i had to make sure you were awake.) the line prints a fourth dot on the screen. what is the next line? it's: number = number - 1 what does it do? takes the current value of number (2) subtracts 1 and makes 1 the new value of number. what is the next line? back up to the while loop: while number > 1: what does the line do? it compares the current value of number (1) to 1. since 1 > 1 is false (one is not greater than one), the while loop exits. what is the next line? since the while loop condition was false the next line is the line after the while loop exits, or: print() what does that line do? makes the screen go to the next line. why doesn't the program print 5 dots? the loop exits 1 dot too soon. how can we fix that? make the loop exit 1 dot later. and how do we do that? there are several ways. one way would be to change the while loop to: while number > 0: another way would be to change the conditional to: number >= 1 there are a couple others. how do i fix my program? you need to figure out what the program is doing. you need to figure out what the program should do. figure out what the difference between the two is. debugging is a skill that has to be practiced to be learned. if you can't figure it out after an hour, take a break, talk to someone about the problem or contemplate the lint in your navel. come back in a while and you will probably have new ideas about the problem. good luck. non-programmer's tutorial for python 3 ← decisions print version defining functions → 8. defining functions creating functions to start off this chapter i am going to give you an example of what you could do but shouldn't (so don't type it in): a = 23 b = -23 if a < 0: a = -a if b < 0: b = -b if a == b: print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and 23 are equal. the program seems a little repetitive. programmers hate to repeat things -- that's what computers are for, after all! (note also that finding the absolute value changed the value of the variable, which is why it is printing out 23, and not -23 in the output.) fortunately python allows you to create functions to remove duplication. here is the rewritten example: a = 23 b = -23 def absolute_value(n): if n < 0: n = -n return n if absolute_value(a) == absolute_value(b): print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and -23 are equal. the key feature of this program is the def statement. def (short for define) starts a function definition. def is followed by the name of the function absolute_value. next comes a '(' followed by the parameter n (n is passed from the program into the function when the function is called). the statements after the ':' are executed when the function is used. the statements continue until either the indented statements end or a return is encountered. the return statement returns a value back to the place where the function was called. we already have encountered a function in our very first program, the print function. now we can make new functions. notice how the values of a and b are not changed. functions can be used to repeat tasks that don't return values. here are some examples: def hello(): print("hello") def area(width, height): return width * height def print_welcome(name): print("welcome", name) hello() hello() print_welcome("fred") w = 4 h = 5 print("width =", w, " height =", h, " area =", area(w, h)) with output being: hello hello welcome fred width = 4 height = 5 area = 20 that example shows some more stuff that you can do with functions. notice that you can use no arguments or two or more. notice also when a function doesn't need to send back a value, a return is optional. variables in functions when eliminating repeated code, you often have variables in the repeated code. in python, these are dealt with in a special way. so far all variables we have seen are global variables. functions have a special type of variable called local variables. these variables only exist while the function is running. when a local variable has the same name as another variable (such as a global variable), the local variable hides the other. sound confusing? well, these next examples (which are a bit contrived) should help clear things up. a = 4 def print_func(): a = 17 print("in print_func a =", a) print_func() print("a = ", a) when run, we will receive an output of: in print_func a = 17 a = 4 variable assignments inside a function do not override global variables, they exist only inside the function. even though a was assigned a new value inside the function, this newly assigned value was only relevant to print_func, when the function finishes running, and the a's values is printed again, we see the originally assigned values. here is another more complex example. a_var = 10 b_var = 15 e_var = 25 def a_func(a_var): print("in a_func a_var =", a_var) b_var = 100 + a_var d_var = 2 * a_var print("in a_func b_var =", b_var) print("in a_func d_var =", d_var) print("in a_func e_var =", e_var) return b_var + 10 c_var = a_func(b_var) print("a_var =", a_var) print("b_var =", b_var) print("c_var =", c_var) print("d_var =", d_var) output: in a_func a_var = 15 in a_func b_var = 115 in a_func d_var = 30 in a_func e_var = 25 a_var = 10 b_var = 15 c_var = 125 d_var = traceback (most recent call last): file "c:\def2.py", line 19, in <module> print("d_var = ", d_var) nameerror: name 'd_var' is not defined in this example the variables a_var, b_var, and d_var are all local variables when they are inside the function a_func. after the statement return b_var + 10 is run, they all cease to exist. the variable a_var is automatically a local variable since it is a parameter name. the variables b_var and d_var are local variables since they appear on the left of an equals sign in the function in the statements b_var = 100 + a_var and d_var = 2 * a_var . inside of the function a_var has no value assigned to it. when the function is called with c_var = a_func(b_var), 15 is assigned to a_var since at that point in time b_var is 15, making the call to the function a_func(15). this ends up setting a_var to 15 when it is inside of a_func. as you can see, once the function finishes running, the local variables a_var and b_var that had hidden the global variables of the same name are gone. then the statement print("a_var = ", a_var) prints the value 10 rather than the value 15 since the local variable that hid the global variable is gone. another thing to notice is the nameerror that happens at the end. this appears since the variable d_var no longer exists since a_func finished. all the local variables are deleted when the function exits. if you want to get something from a function, then you will have to use return something. one last thing to notice is that the value of e_var remains unchanged inside a_func since it is not a parameter and it never appears on the left of an equals sign inside of the function a_func. when a global variable is accessed inside a function it is the global variable from the outside. functions allow local variables that exist only inside the function and can hide other variables that are outside the function. examples temperature2.py #! /usr/bin/python #-*-coding: utf-8 -*- # converts temperature to fahrenheit or celsius def print_options(): print("options:") print(" 'p' print options") print(" 'c' convert from celsius") print(" 'f' convert from fahrenheit") print(" 'q' quit the program") def celsius_to_fahrenheit(c_temp): return 9.0 / 5.0 * c_temp + 32 def fahrenheit_to_celsius(f_temp): return (f_temp - 32.0) * 5.0 / 9.0 choice = "p" while choice != "q": if choice == "c": c_temp = float(input("celsius temperature: ")) print("fahrenheit:", celsius_to_fahrenheit(c_temp)) choice = input("option: ") elif choice == "f": f_temp = float(input("fahrenheit temperature: ")) print("celsius:", fahrenheit_to_celsius(f_temp)) choice = input("option: ") else: choice = "p" #alternatively choice != "q": so that print #when anything unexpected inputed print_options() choice = input("option: ") sample run: options: 'p' print options 'c' convert from celsius 'f' convert from fahrenheit 'q' quit the program option: c celsius temperature: 30 fahrenheit: 86.0 option: f fahrenheit temperature: 60 celsius: 15.5555555556 option: q area2.py #! /usr/bin/python #-*-coding: utf-8 -*- # calculates a given rectangle area def hello(): print('hello!') def area(width, height): return width * height def print_welcome(name): print('welcome,', name) def positive_input(prompt): number = float(input(prompt)) while number <= 0: print('must be a positive number') number = float(input(prompt)) return number name = input('your name: ') hello() print_welcome(name) print() print('to find the area of a rectangle,') print('enter the width and height below.') print() w = positive_input('width: ') h = positive_input('height: ') print('width =', w, ' height =', h, ' so area =', area(w, h)) sample run: your name: josh hello! welcome, josh to find the area of a rectangle, enter the width and height below. width: -4 must be a positive number width: 4 height: 3 width = 4 height = 3 so area = 12 exercises rewrite the area2.py program from the examples above to have a separate function for the area of a square, the area of a rectangle, and the area of a circle (3.14 * radius**2). this program should include a menu interface. solution def square(l): return l * l def rectangle(width , height): return width * height def circle(radius): return 3.14159 * radius ** 2 def options(): print() print("options:") print("s = calculate the area of a square.") print("c = calculate the area of a circle.") print("r = calculate the area of a rectangle.") print("q = quit") print() print("this program will calculate the area of a square, circle or rectangle.") choice = "x" options() while choice != "q": choice = input("please enter your choice: ") if choice == "s": l = float(input("length of square side: ")) print("the area of this square is", square(l)) options() elif choice == "c": radius = float(input("radius of the circle: ")) print("the area of the circle is", circle(radius)) options() elif choice == "r": width = float(input("width of the rectangle: ")) height = float(input("height of the rectangle: ")) print("the area of the rectangle is", rectangle(width, height)) options() elif choice == "q": print(" ",end="") else: print("unrecognized option.") options() non-programmer's tutorial for python 3 ← debugging print version advanced functions example → 9. advanced functions example some people find this section useful, and some find it confusing. if you find it confusing you can skip it. now we will do a walk through for the following program: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value result = mult(3, 2) print("3 * 2 = ", result) basically this program creates a positive integer multiplication function (that is far slower than the built in multiplication function) and then demonstrates this function with a use of the function. this program demonstrates the use of recursion, that is a form of iteration (repetition) in which there is a function that repeatedly calls itself until an exit condition is satisfied. it uses repeated additions to give the same result as mutiplication: e.g. 3 + 3 (addition) gives the same result as 3 * 2 (multiplication). question: what is the first thing the program does? answer: the first thing done is the function mult is defined with the lines: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value this creates a function that takes two parameters and returns a value when it is done. later this function can be run. what happens next? the next line after the function, result = mult(3, 2) is run. what does this line do? this line will assign the return value of mult(3, 2) to the variable result. and what does mult(3, 2) return? we need to do a walkthrough of the mult function to find out. what happens next? the variable a gets the value 3 assigned to it and the variable b gets the value 2 assigned to it. and then? the line if b == 0: is run. since b has the value 2 this is false so the line return 0 is skipped. and what then? the line rest = mult(a, b - 1) is run. this line sets the local variable rest to the value of mult(a, b - 1). the value of a is 3 and the value of b is 2 so the function call is mult(3,1) so what is the value of mult(3, 1) ? we will need to run the function mult with the parameters 3 and 1. so what happens next? the local variables in the new run of the function are set so that a has the value 3 and b has the value 1. since these are local values these do not affect the previous values of a and b. and then? since b has the value 1 the if statement is false, so the next line becomes rest = mult(a, b - 1). what does this line do? this line will assign the value of mult(3, 0) to rest. so what is that value? we will have to run the function one more time to find that out. this time a has the value 3 and b has the value 0. so what happens next? the first line in the function to run is if b == 0:. b has the value 0 so the next line to run is return 0 and what does the line return 0 do? this line returns the value 0 out of the function. so? so now we know that mult(3, 0) has the value 0. now we know what the line rest = mult(a, b - 1) did since we have run the function mult with the parameters 3 and 0. we have finished running mult(3, 0) and are now back to running mult(3, 1). the variable rest gets assigned the value 0. what line is run next? the line value = a + rest is run next. in this run of the function, a = 3 and rest = 0 so now value = 3. what happens next? the line return value is run. this returns 3 from the function. this also exits from the run of the function mult(3, 1). after return is called, we go back to running mult(3, 2). where were we in mult(3, 2)? we had the variables a = 3 and b = 2 and were examining the line rest = mult(a, b - 1). so what happens now? the variable rest get 3 assigned to it. the next line value = a + rest sets value to 3 + 3 or 6. so now what happens? the next line runs, this returns 6 from the function. we are now back to running the line result = mult(3, 2) which can now assign the value 6 to the variable result. what happens next? the next line after the function, print("3 * 2 = ", result) is run. and what does this do? it prints 3 * 2 = and the value of result which is 6. the complete line printed is 3 * 2 = 6. what is happening overall? basically we used two facts to calculate the multiple of the two numbers. the first is that any number times 0 is 0 (x * 0 = 0). the second is that a number times another number is equal to the first number plus the first number times one less than the second number (x * y = x + x * (y - 1)). so what happens is 3 * 2 is first converted into 3 + 3 * 1. then 3 * 1 is converted into 3 + 3 * 0. then we know that any number times 0 is 0 so 3 * 0 is 0. then we can calculate that 3 + 3 * 0 is 3 + 0 which is 3. now we know what 3 * 1 is so we can calculate that 3 + 3 * 1 is 3 + 3 which is 6. this is how the whole thing works: mult(3, 2) 3 + mult(3, 1) 3 + 3 + mult(3, 0) 3 + 3 + 0 3 + 3 6 recursion programming constructs solving a problem by solving a smaller version of the same problem are called recursive. in the examples in this chapter, recursion is realized by defining a function calling itself. this facilitates implementing solutions to programming tasks as it may be sufficient to consider the next step of a problem instead of the whole problem at once. it is also useful as it allows to express some mathematical concepts with straightforward, easy to read code. any problem that can be solved with recursion could be re-implemented with loops. using the latter usually results in better performance. however equivalent implementations using loops are usually harder to get done correctly. probably the most intuitive definition of recursion is: recursion if you still don't get it, see recursion. try walking through the factorial example if the multiplication example did not make sense. examples factorial.py #defines a function that calculates the factorial def factorial(n): if n == 0: return 1 if n<0: return "error, negative numbers do not have factorial values!!" return n * factorial(n - 1) print("2! =", factorial(2)) print("3! =", factorial(3)) print("4! =", factorial(4)) print("5! =", factorial(5)) print("-3! =", factorial(-3)) output: 2! = 2 3! = 6 4! = 24 5! = 120 -3! = error, negative values do not have factorial values!! countdown.py def count_down(n): print(n) if n > 0: return count_down(n-1) count_down(5) output: 5 4 3 2 1 0 non-programmer's tutorial for python 3 ← defining functions print version lists → 10. lists variables with more than one value you have already seen ordinary variables that store a single value. however other variable types can hold more than one value. these are called containers because they can contain more than one object. the simplest type is called a list. here is an example of a list being used: which_one = int(input("what month (1-12)? ")) months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'] if 1 <= which_one <= 12: print("the month is", months[which_one - 1]) and an output example: what month (1-12)? 3 the month is march in this example the months is a list. months is defined with the lines months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', and 'august', 'september', 'october', 'november', 'december'] (note that a \ could also be used to split a long line, but that is not necessary in this case because python is intelligent enough to recognize that everything within brackets belongs together). the [ and ] start and end the list with commas (,) separating the list items. the list is used in months[which_one - 1]. a list consists of items that are numbered starting at 0. in other words if you wanted january you would use months[0]. give a list a number and it will return the value that is stored at that location. the statement if 1 <= which_one <= 12: will only be true if which_one is between one and twelve inclusive (in other words it is what you would expect if you have seen that in algebra). lists can be thought of as a series of boxes. each box has a different value. for example, the boxes created by demolist = ['life', 42, 'the universe', 6, 'and', 9] would look like this: box number 0 1 2 3 4 5 demolist "life" 42 "the universe" 6 "and" 9 each box is referenced by its number so the statement demolist[0] would get 'life', demolist[1] would get 42 and so on up to demolist[5] getting 9. more features of lists the next example is just to show a lot of other stuff lists can do (for once i don't expect you to type it in, but you should probably play around with lists in interactive mode until you are comfortable with them.). here goes: demolist = ["life", 42, "the universe", 6, "and", 9] print("demolist = ",demolist) demolist.append("everything") print("after 'everything' was appended demolist is now:") print(demolist) print("len(demolist) =", len(demolist)) print("demolist.index(42) =", demolist.index(42)) print("demolist[1] =", demolist[1]) # next we will loop through the list for c in range(len(demolist)): print("demolist[", c, "] =", demolist[c]) del demolist[2] print("after 'the universe' was removed demolist is now:") print(demolist) if "life" in demolist: print("'life' was found in demolist") else: print("'life' was not found in demolist") if "amoeba" in demolist: print("'amoeba' was found in demolist") if "amoeba" not in demolist: print("'amoeba' was not found in demolist") another_list = [42,7,0,123] another_list.sort() print("the sorted another_list is", another_list) the output is: demolist = ['life', 42, 'the universe', 6, 'and', 9] after 'everything' was appended demolist is now: ['life', 42, 'the universe', 6, 'and', 9, 'everything'] len(demolist) = 7 demolist.index(42) = 1 demolist[1] = 42 demolist[ 0 ] = life demolist[ 1 ] = 42 demolist[ 2 ] = the universe demolist[ 3 ] = 6 demolist[ 4 ] = and demolist[ 5 ] = 9 demolist[ 6 ] = everything after 'the universe' was removed demolist is now: ['life', 42, 6, 'and', 9, 'everything'] 'life' was found in demolist 'amoeba' was not found in demolist the sorted another_list is [0, 7, 42, 123] this example uses a whole bunch of new functions. notice that you can just print a whole list. next the append function is used to add a new item to the end of the list. len returns how many items are in a list. the valid indexes (as in numbers that can be used inside of the []) of a list range from 0 to len - 1. the index function tells where the first location of an item is located in a list. notice how demolist.index(42) returns 1, and when demolist[1] is run it returns 42. to get help on all the functions a list provides for you, type help(list) in the interactive python interpreter. the line # next we will loop through the list is a just a reminder to the programmer (also called a comment). python ignores everything that is written after a # on the current line. next the lines: for c in range(len(demolist)): print('demolist[', c, '] =', demolist[c]) create a variable c, which starts at 0 and is incremented until it reaches the last index of the list. meanwhile the print statement prints out each element of the list. a much better way to do the above is: for c, x in enumerate(demolist): print("demolist[", c, "] =", x) the del command can be used to remove a given element in a list. the next few lines use the in operator to test if an element is in or is not in a list. the sort function sorts the list. this is useful if you need a list in order from smallest number to largest or alphabetical. note that this rearranges the list. in summary, for a list, the following operations occur: example explanation demolist[2] accesses the element at index 2 demolist[2] = 3 sets the element at index 2 to be 3 del demolist[2] removes the element at index 2 len(demolist) returns the length of demolist "value" in demolist is true if "value" is an element in demolist "value" not in demolist is true if "value" is not an element in demolist another_list.sort() sorts another_list. note that the list must be all numbers or all strings to be sorted. demolist.index("value") returns the index of the first place that "value" occurs demolist.append("value") adds an element "value" at the end of the list demolist.remove("value") removes the first occurrence of value from demolist (same as del demolist[demolist.index("value")]) this next example uses these features in a more useful way: menu_item = 0 namelist = [] while menu_item != 9: print("--------------------") print("1. print the list") print("2. add a name to the list") print("3. remove a name from the list") print("4. change an item in the list") print("9. quit") menu_item = int(input("pick an item from the menu: ")) if menu_item == 1: current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") elif menu_item == 2: name = input("type in a name to add: ") namelist.append(name) elif menu_item == 3: del_name = input("what name would you like to remove: ") if del_name in namelist: # namelist.remove(del_name) would work just as fine item_number = namelist.index(del_name) del namelist[item_number] # the code above only removes the first occurrence of # the name. the code below from gerald removes all. # while del_name in namelist: # item_number = namelist.index(del_name) # del namelist[item_number] else: print(del_name, "was not found") elif menu_item == 4: old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") print("goodbye") and here is part of the output: -------------------- 1. print the list 2. add a name to the list 3. remove a name from the list 4. change an item in the list 9. quit pick an item from the menu: 2 type in a name to add: jack pick an item from the menu: 2 type in a name to add: jill pick an item from the menu: 1 0 . jack 1 . jill pick an item from the menu: 3 what name would you like to remove: jack pick an item from the menu: 4 what name would you like to change: jill what is the new name: jill peters pick an item from the menu: 1 0 . jill peters pick an item from the menu: 9 goodbye that was a long program. let's take a look at the source code. the line namelist = [] makes the variable namelist a list with no items (or elements). the next important line is while menu_item != 9:. this line starts a loop that allows the menu system for this program. the next few lines display a menu and decide which part of the program to run. the section current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") goes through the list and prints each name. len(namelist) tells how many items are in the list. if len returns 0, then the list is empty. then, a few lines later, the statement namelist.append(name) appears. it uses the append function to add an item to the end of the list. jump down another two lines, and notice this section of code: item_number = namelist.index(del_name) del namelist[item_number] here the index function is used to find the index value that will be used later to remove the item. del namelist[item_number] is used to remove an element of the list. the next section old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") uses index to find the item_number and then puts new_name where the old_name was. congratulations, with lists under your belt, you now know enough of the language that you could do any computations that a computer can do (this is technically known as turing-completeness). of course, there are still many features that are used to make your life easier. examples test.py ## this program runs a test of knowledge # first get the test questions # later this will be modified to use file io. def get_questions(): # notice how the data is stored as a list of lists return [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list # this function takes a list with two elements, a question and an answer. question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the tester's answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question #note that this is extracting a question and answer list from the list of lists. if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions),\ "% right out of", len(questions)) # now let's get the questions from the get_questions function, and # send the returned list of lists as an argument to the run_test function. run_test(get_questions()) the values true and false point to 1 and 0, respectively. they are often used in sanity checks, loop conditions etc. you will learn more about this a little bit later (chapter boolean expressions). please note that get_questions() is essentially a list because even though it's technically a function, returning a list of lists is the only thing it does. sample output: what color is the daytime sky on a clear day? green incorrect, correct was: blue what is the answer to life, the universe and everything? 42 correct what is a three letter word for mouse trap? cat correct you got 66 % right out of 3 exercises expand the test.py program so it has a menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". solution expand the test.py program so it has menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". ## this program runs a test of knowledge questions = [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"], ["what noise does a truly advanced machine make?", "ping"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the testers answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions), "% right out of", len(questions)) #showing a list of questions and answers def showquestions(): q = 0 while q < len(questions): a = 0 print("q:" , questions[q][a]) a = 1 print("a:" , questions[q][a]) q = q + 1 # now let's define the menu function def menu(): print("-----------------") print("menu:") print("1 - take the test") print("2 - view a list of questions and answers") print("3 - view the menu") print("5 - quit") print("-----------------") choice = "3" while choice != "5": if choice == "1": run_test(questions) elif choice == "2": showquestions() elif choice == "3": menu() print() choice = input("choose your option from the menu above: ") non-programmer's tutorial for python 3 ← advanced functions example print version for loops → 11. for loops and here is the new typing exercise for this chapter: onetoten = range(1, 11) for count in onetoten: print(count) and the ever-present output: 1 2 3 4 5 6 7 8 9 10 the output looks awfully familiar but the program code looks different. the first line uses the range function. the range function uses two arguments like this range(start, finish). start is the first number that is produced. finish is one larger than the last number. note that this program could have been done in a shorter way: for count in range(1, 11): print(count) the range function returns an iterable. this can be converted into a list with the list function. which will then be the dominant number. here are some examples to show what happens with the range command: >>> range(1, 10) range(1, 10) >>> list(range(1, 10)) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(-32, -20)) [-32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21] >>> list(range(5,21)) [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] >>> list(range(5)) [0, 1, 2, 3, 4] >>> list(range(21, 5)) [] the next line for count in onetoten: uses the for control structure. a for control structure looks like for variable in list:. list is gone through starting with the first element of the list and going to the last. as for goes through each element in a list it puts each into variable. that allows variable to be used in each successive time the for loop is run through. here is another example (you don't have to type this) to demonstrate: demolist = ['life', 42, 'the universe', 6, 'and', 7, 'everything'] for item in demolist: print("the current item is:",item) the output is: the current item is: life the current item is: 42 the current item is: the universe the current item is: 6 the current item is: and the current item is: 7 the current item is: everything notice how the for loop goes through and sets item to each element in the list. so, what is for good for? the first use is to go through all the elements of a list and do something with each of them. here's a quick way to add up all the elements: list = [2, 4, 6, 8] sum = 0 for num in list: sum = sum + num print("the sum is:", sum) with the output simply being: the sum is: 20 or you could write a program to find out if there are any duplicates in a list like this program does: list = [4, 5, 7, 8, 9, 1, 0, 7, 10] list.sort() prev = none for item in list: if prev == item: print("duplicate of", prev, "found") prev = item and for good measure: duplicate of 7 found okay, so how does it work? here is a special debugging version to help you understand (you don't need to type this in): l = [4, 5, 7, 8, 9, 1, 0, 7, 10] print("l = [4, 5, 7, 8, 9, 1, 0, 7, 10]", "\t\tl:", l) l.sort() print("l.sort()", "\t\tl:", l) prev = l[0] print("prev = l[0]", "\t\tprev:", prev) del l[0] print("del l[0]", "\t\tl:", l) for item in l: if prev == item: print("duplicate of", prev, "found") print("if prev == item:", "\t\tprev:", prev, "\titem:", item) prev = item print("prev = item", "\t\tprev:", prev, "\titem:", item) with the output being: l = [4, 5, 7, 8, 9, 1, 0, 7, 10] l: [4, 5, 7, 8, 9, 1, 0, 7, 10] l.sort() l: [0, 1, 4, 5, 7, 7, 8, 9, 10] prev = l[0] prev: 0 del l[0] l: [1, 4, 5, 7, 7, 8, 9, 10] if prev == item: prev: 0 item: 1 prev = item prev: 1 item: 1 if prev == item: prev: 1 item: 4 prev = item prev: 4 item: 4 if prev == item: prev: 4 item: 5 prev = item prev: 5 item: 5 if prev == item: prev: 5 item: 7 prev = item prev: 7 item: 7 duplicate of 7 found if prev == item: prev: 7 item: 7 prev = item prev: 7 item: 7 if prev == item: prev: 7 item: 8 prev = item prev: 8 item: 8 if prev == item: prev: 8 item: 9 prev = item prev: 9 item: 9 if prev == item: prev: 9 item: 10 prev = item prev: 10 item: 10 the reason i put so many print statements in the code was so that you can see what is happening in each line. (by the way, if you can't figure out why a program is not working, try putting in lots of print statements in places where you want to know what is happening.) first the program starts with a boring old list. next the program sorts the list. this is so that any duplicates get put next to each other. the program then initializes a prev(ious) variable. next the first element of the list is deleted so that the first item is not incorrectly thought to be a duplicate. next a for loop is gone into. each item of the list is checked to see if it is the same as the previous. if it is a duplicate was found. the value of prev is then changed so that the next time the for loop is run through prev is the previous item to the current. sure enough, the 7 is found to be a duplicate. (notice how \t is used to print a tab.) the other way to use for loops is to do something a certain number of times. here is some code to print out the first 9 numbers of the fibonacci series: a = 1 b = 1 for c in range(1, 10): print(a, end=" ") n = a + b a = b b = n with the surprising output: 1 1 2 3 5 8 13 21 34 everything that can be done with for loops can also be done with while loops but for loops give an easy way to go through all the elements in a list or to do something a certain number of times. non-programmer's tutorial for python 3 ← lists print version boolean expressions → 12. boolean expressions here is a little example of boolean expressions (you don't have to type it in): a = 6 b = 7 c = 42 print(1, a == 6) print(2, a == 7) print(3, a == 6 and b == 7) print(4, a == 7 and b == 7) print(5, not a == 7 and b == 7) print(6, a == 7 or b == 7) print(7, a == 7 or b == 6) print(8, not (a == 7 and b == 6)) print(9, not a == 7 and b == 6) with the output being: 1 true 2 false 3 true 4 false 5 true 6 true 7 false 8 true 9 false what is going on? the program consists of a bunch of funny looking print statements. each print statement prints a number and an expression. the number is to help keep track of which statement i am dealing with. notice how each expression ends up being either false or true. in python false can also be written as 0 and true as 1. the lines: print(1, a == 6) print(2, a == 7) print out a true and a false respectively just as expected since the first is true and the second is false. the third print, print(3, a == 6 and b == 7), is a little different. the operator and means if both the statement before and the statement after are true then the whole expression is true otherwise the whole expression is false. the next line, print(4, a == 7 and b == 7), shows how if part of an and expression is false, the whole thing is false. the behavior of and can be summarized as follows: expression result true and true true true and false false false and true false false and false false notice that if the first expression is false python does not check the second expression since it knows the whole expression is false. try running false and print("hi") and compare this to running true and print("hi") the technical term for this is short-circuit evaluation the next line, print(5, not a == 7 and b == 7), uses the not operator. not just gives the opposite of the expression. (the expression could be rewritten as print(5, a != 7 and b == 7)). here is the table: expression result not true false not false true the two following lines, print(6, a == 7 or b == 7) and print(7, a == 7 or b == 6), use the or operator. the or operator returns true if the first expression is true, or if the second expression is true or both are true. if neither are true it returns false. here's the table: expression result true or true true true or false true false or true true false or false false notice that if the first expression is true python doesn't check the second expression since it knows the whole expression is true. this works since or is true if at least one half of the expression is true. the first part is true so the second part could be either false or true, but the whole expression is still true. the next two lines, print(8, not (a == 7 and b == 6)) and print(9, not a == 7 and b == 6), show that parentheses can be used to group expressions and force one part to be evaluated first. notice that the parentheses changed the expression from false to true. this occurred since the parentheses forced the not to apply to the whole expression instead of just the a == 7 portion. here is an example of using a boolean expression: list = ["life", "the universe", "everything", "jack", "jill", "life", "jill"] # make a copy of the list. see the more on lists chapter to explain what [:] means. copy = list[:] # sort the copy copy.sort() prev = copy[0] del copy[0] count = 0 # go through the list searching for a match while count < len(copy) and copy[count] != prev: prev = copy[count] count = count + 1 # if a match was not found then count can't be < len # since the while loop continues while count is < len # and no match is found if count < len(copy): print("first match:", prev) and here is the output: first match: jill this program works by continuing to check for match while count < len(copy) and copy[count] is not equal to prev. when either count is greater than the last index of copy or a match has been found the and is no longer true so the loop exits. the if simply checks to make sure that the while exited because a match was found. the other "trick" of and is used in this example. if you look at the table for and notice that the third entry is "false and false". if count >= len(copy) (in other words count < len(copy) is false) then copy[count] is never looked at. this is because python knows that if the first is false then they can't both be true. this is known as a short circuit and is useful if the second half of the and will cause an error if something is wrong. i used the first expression (count < len(copy)) to check and see if count was a valid index for copy. (if you don't believe me remove the matches "jill" and "life", check that it still works and then reverse the order of count < len(copy) and copy[count] != prev to copy[count] != prev and count < len(copy).) boolean expressions can be used when you need to check two or more different things at once. a note on boolean operators a common mistake for people new to programming is a misunderstanding of the way that boolean operators works, which stems from the way the python interpreter reads these expressions. for example, after initially learning about "and " and "or" statements, one might assume that the expression x == ('a' or 'b') would check to see if the variable x was equivalent to one of the strings 'a' or 'b'. this is not so. to see what i'm talking about, start an interactive session with the interpreter and enter the following expressions: >>> 'a' == ('a' or 'b') >>> 'b' == ('a' or 'b') >>> 'a' == ('a' and 'b') >>> 'b' == ('a' and 'b') and this will be the unintuitive result: >>> 'a' == ('a' or 'b') true >>> 'b' == ('a' or 'b') false >>> 'a' == ('a' and 'b') false >>> 'b' == ('a' and 'b') true at this point, the and and or operators seem to be broken. it doesn't make sense that, for the first two expressions, 'a' is equivalent to 'a' or 'b' while 'b' is not. furthermore, it doesn't make any sense that 'b' is equivalent to 'a' and 'b'. after examining what the interpreter does with boolean operators, these results do in fact exactly what you are asking of them, it's just not the same as what you think you are asking. when the python interpreter looks at an or expression, it takes the first statement and checks to see if it is true. if the first statement is true, then python returns that object's value without checking the second statement. this is because for an or expression, the whole thing is true if one of the values is true; the program does not need to bother with the second statement. on the other hand, if the first value is evaluated as false python checks the second half and returns that value. that second half determines the truth value of the whole expression since the first half was false. this "laziness" on the part of the interpreter is called "short circuiting" and is a common way of evaluating boolean expressions in many programming languages. similarly, for an and expression, python uses a short circuit technique to speed truth value evaluation. if the first statement is false then the whole thing must be false, so it returns that value. otherwise if the first value is true it checks the second and returns that value. one thing to note at this point is that the boolean expression returns a value indicating true or false, but that python considers a number of different things to have a truth value assigned to them. to check the truth value of any given object x, you can use the function bool(x) to see its truth value. below is a table with examples of the truth values of various objects: true false true false 1 0 numbers other than zero the string 'none' nonempty strings empty strings nonempty lists empty lists nonempty dictionaries empty dictionaries now it is possible to understand the perplexing results we were getting when we tested those boolean expressions before. let's take a look at what the interpreter "sees" as it goes through that code: first case: >>> 'a' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'a' == 'a' # the string 'a' is equivalent to the string 'a', so expression is true true second case: >>> 'b' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'b' == 'a' # the string 'b' is not equivalent to the string 'a', so expression is false false third case: >>> 'a' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'a' == 'b' # the string 'a' is not equivalent to the string 'b', so expression is false false fourth case: >>> 'b' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'b' == 'b' # the string 'b' is equivalent to the string 'b', so expression is true true so python was really doing its job when it gave those apparently bogus results. as mentioned previously, the important thing is to recognize what value your boolean expression will return when it is evaluated, because it isn't always obvious. going back to those initial expressions, this is how you would write them out so they behaved in a way that you want: >>> 'a' == 'a' or 'a' == 'b' true >>> 'b' == 'a' or 'b' == 'b' true >>> 'a' == 'a' and 'a' == 'b' false >>> 'b' == 'a' and 'b' == 'b' false when these comparisons are evaluated they return truth values in terms of true or false, not strings, so we get the proper results. examples password1.py ## this program asks a user for a name and a password. # it then checks them to make sure that the user is allowed in. name = input("what is your name? ") password = input("what is the password? ") if name == "josh" and password == "friday": print("welcome josh") elif name == "fred" and password == "rock": print("welcome fred") else: print("i don't know you.") sample runs what is your name? josh what is the password? friday welcome josh what is your name? bill what is the password? money i don't know you. exercises write a program that has a user guess your name, but they only get 3 chances to do so until the program quits. solution print("try to guess my name!") count = 1 name = "guilherme" guess = input("what is my name? ") while count < 3 and guess.lower() != name: # .lower allows things like guilherme to still match print("you are wrong!") guess = input("what is my name? ") count = count + 1 if guess.lower() != name: print("you are wrong!") # this message isn't printed in the third chance, so we print it now print("you ran out of chances.") else: print("yes! my name is", name + "!") non-programmer's tutorial for python 3 ← for loops print version dictionaries → 13. dictionaries this chapter is about dictionaries. dictionaries have keys and values. the keys are used to find the values. here is an example of a dictionary in use: def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() and here is my output: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. quit type in a number (1-5): 2 add name and number name: joe number: 545-4464 type in a number (1-5): 2 add name and number name: jill number: 979-4654 type in a number (1-5): 2 add name and number name: fred number: 132-9874 type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 name: fred number: 132-9874 type in a number (1-5): 4 lookup number name: joe the number is 545-4464 type in a number (1-5): 3 remove name and number name: fred type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 type in a number (1-5): 5 this program is similar to the name list earlier in the chapter on lists. here's how the program works. first the function print_menu is defined. print_menu just prints a menu that is later used twice in the program. next comes the funny looking line numbers = {}. all that this line does is to tell python that numbers is a dictionary. the next few lines just make the menu work. the lines for x in numbers.keys(): print("name:", x, "\tnumber:", numbers[x]) go through the dictionary and print all the information. the function numbers.keys() returns a list that is then used by the for loop. the list returned by keys() is not in any particular order so if you want it in alphabetic order it must be sorted. similar to lists the statement numbers[x] is used to access a specific member of the dictionary. of course in this case x is a string. next the line numbers[name] = phone adds a name and phone number to the dictionary. if name had already been in the dictionary phone would replace whatever was there before. next the lines if name in numbers: del numbers[name] see if a name is in the dictionary and remove it if it is. the operator name in numbers returns true if name is in numbers but otherwise returns false. the line del numbers[name] removes the key name and the value associated with that key. the lines if name in numbers: print("the number is", numbers[name]) check to see if the dictionary has a certain key and if it does prints out the number associated with it. lastly if the menu choice is invalid it reprints the menu for your viewing pleasure. a recap: dictionaries have keys and values. keys can be strings or numbers. keys point to values. values can be any type of variable (including lists or even dictionaries (those dictionaries or lists of course can contain dictionaries or lists themselves (scary right? :-) ))). here is an example of using a list in a dictionary: max_points = [25, 25, 50, 25, 100] assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = {'#max': max_points} def print_menu(): print("1. add student") print("2. remove student") print("3. print grades") print("4. record grade") print("5. print menu") print("6. exit") def print_all_grades(): print('\t', end=' ') for i in range(len(assignments)): print(assignments[i], '\t', end=' ') print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) def print_grades(grades): for i in range(len(grades)): print(grades[i], '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 6: print() menu_choice = int(input("menu choice (1-6): ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(max_points) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: print_all_grades() elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i in range(len(assignments)): print(i + 1, assignments[i], '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 #same as which = which - 1 if 0 <= which < len(grades): grade = int(input("grade: ")) grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice != 6: print_menu() and here is a sample output: 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 menu choice (1-6): 5 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 1 student to add: bill menu choice (1-6): 4 record grade student: bill type in the number of the grade to record type a 0 (zero) to exit 1 hw ch 1 2 hw ch 2 3 quiz 4 hw ch 3 5 test 0 0 0 0 0 change which grade: 1 grade: 25 change which grade: 2 grade: 24 change which grade: 3 grade: 45 change which grade: 4 grade: 23 change which grade: 5 grade: 95 change which grade: 0 menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 bill 25 24 45 23 95 menu choice (1-6): 6 heres how the program works. basically the variable students is a dictionary with the keys being the name of the students and the values being their grades. the first two lines just create two lists. the next line students = {'#max': max_points} creates a new dictionary with the key {#max} and the value is set to be [25, 25, 50, 25, 100] (since thats what max_points was when the assignment is made) (i use the key #max since # is sorted ahead of any alphabetic characters). next print_menu is defined. next the print_all_grades function is defined in the lines: def print_all_grades(): print('\t',end=" ") for i in range(len(assignments)): print(assignments[i], '\t',end=" ") print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t',end=' ') grades = students[x] print_grades(grades) notice how first the keys are gotten out of the students dictionary with the keys function in the line keys = list(students.keys()). keys is an iterable, and it is converted to list so all the functions for lists can be used on it. next the keys are sorted in the line keys.sort(). for is used to go through all the keys. the grades are stored as a list inside the dictionary so the assignment grades = students[x] gives grades the list that is stored at the key x. the function print_grades just prints a list and is defined a few lines later. the later lines of the program implement the various options of the menu. the line students[name] = [0] * len(max_points) adds a student to the key of their name. the notation [0] * len(max_points) just creates a list of 0's that is the same length as the max_points list. the remove student entry just deletes a student similar to the telephone book example. the record grades choice is a little more complex. the grades are retrieved in the line grades = students[name] gets a reference to the grades of the student name. a grade is then recorded in the line grades[which] = grade. you may notice that grades is never put back into the students dictionary (as in no students[name] = grades). the reason for the missing statement is that grades is actually another name for students[name] and so changing grades changes student[name]. dictionaries provide an easy way to link keys to values. this can be used to easily keep track of data that is attached to various keys. non-programmer's tutorial for python 3 ← boolean expressions print version using modules → 14. using modules here's this chapter's typing exercise (name it cal.py (import actually looks for a file named calendar.py and reads it in. if the file is named calendar.py and it sees a "import calendar" it tries to read in itself which works poorly at best.)): import calendar year = int(input("type in the year number: ")) calendar.prcal(year) and here is part of the output i got: type in the year number: 2001 2001 january february march mo tu we th fr sa su mo tu we th fr sa su mo tu we th fr sa su 1 2 3 4 5 6 7 1 2 3 4 1 2 3 4 8 9 10 11 12 13 14 5 6 7 8 9 10 11 5 6 7 8 9 10 11 15 16 17 18 19 20 21 12 13 14 15 16 17 18 12 13 14 15 16 17 18 22 23 24 25 26 27 28 19 20 21 22 23 24 25 19 20 21 22 23 24 25 29 30 31 26 27 28 26 27 28 29 30 31 (i skipped some of the output, but i think you get the idea.) so what does the program do? the first line import calendar uses a new command import. the command import loads a module (in this case the calendar module). to see the commands available in the standard modules either look in the library reference for python (if you downloaded it) or go to http://docs.python.org/3/library/. if you look at the documentation for the calendar module, it lists a function called prcal that prints a calendar for a year. the line calendar.prcal(year) uses this function. in summary to use a module import it and then use module_name.function for functions in the module. another way to write the program is: from calendar import prcal year = int(input("type in the year number: ")) prcal(year) this version imports a specific function from a module. here is another program that uses the python library (name it something like clock.py) (press ctrl and the 'c' key at the same time to terminate the program): from time import time, ctime prev_time = "" while true: the_time = ctime(time()) if prev_time != the_time: print("the time is:", ctime(time())) prev_time = the_time with some output being: the time is: sun aug 20 13:40:04 2000 the time is: sun aug 20 13:40:05 2000 the time is: sun aug 20 13:40:06 2000 the time is: sun aug 20 13:40:07 2000 traceback (innermost last): file "clock.py", line 5, in ? the_time = ctime(time()) keyboardinterrupt the output is infinite of course so i cancelled it (or the output at least continues until ctrl+c is pressed). the program just does an infinite loop (true is always true, so while true: goes forever) and each time checks to see if the time has changed and prints it if it has. notice how multiple names after the import statement are used in the line from time import time, ctime. the python library contains many useful functions. these functions give your programs more abilities and many of them can simplify programming in python. exercises rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. solution rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. from random import randint number = randint(0, 99) guess = -1 while guess != number: guess = int(input ("guess a number: ")) if guess > number: print("too high") elif guess < number: print("too low") print("just right") other modules sometimes you want to use a python module that does not come with the python installation. you can also import those, but you have to have them installed on your computer. creating your own module when python reads the import command, it first checks files in your directory, then site-packages or pre installed modules. to make your own module, just create a .py file in the current directory and use the command: import module this will try to import the file module.py from your current directory and if not found, from site-packages and prepackaged modules. changing module to the name of the .py file you created will import that file. however, when it imports the module, it will basically start the file as a program, so any code on there will be run. you want to group all code into functions. the __name__ == __main__ trick in python, the variable __name__ will give you the current name of the program. if a module you import prints the __name__ variable, then it will print the name of the module. if the current file prints the __name__ variable, it will print __main__, to show it is the main program. if an if statement checks the name variable and runs code if the program is main, it can bypass the unintentional run problem created when a module is imported. say for example you have a file, which runs some code. it also has a function you want to use in another program. however, you only want the function, not to run the code. by setting up the code below, it will only run the code if it is the file that was clicked on or started, not if it was imported. if __name__ == '__main__': pass in this instance, if the file is run but not imported, it will run the pass command. you can replace the pass command with the code you want to be run when not imported. just remember to indent the code. the pip module the pip module is a module that comes with the python installation and acts as a module downloader/manager. you can download other modules from the internet with pip. the pip module is not used in the python interpreter, but is run through the command line. to use it, open up your command line interpreter (for windows it is command prompt, for mac/linux it is terminal) and type in the following code: py3 -m pip install module or the alternate code pip install module this will try to download and install module from the user-submitted python modules database. module can be changed to the name of the module. non-programmer's tutorial for python 3 ← dictionaries print version more on lists → 15. more on lists we have already seen lists and how they can be used. now that you have some more background i will go into more detail about lists. first we will look at more ways to get at the elements in a list and then we will talk about copying them. here are some examples of using indexing to access a single element of a list: >>> some_numbers = ['zero', 'one', 'two', 'three', 'four', 'five'] >>> some_numbers[0] 'zero' >>> some_numbers[4] 'four' >>> some_numbers[5] 'five' all those examples should look familiar to you. if you want the first item in the list just look at index 0. the second item is index 1 and so on through the list. however what if you want the last item in the list? one way could be to use the len() function like some_numbers[len(some_numbers) - 1]. this way works since the len() function always returns the last index plus one. the second from the last would then be some_numbers[len(some_numbers) - 2]. there is an easier way to do this. in python the last item is always index -1. the second to the last is index -2 and so on. here are some more examples: >>> some_numbers[len(some_numbers) - 1] 'five' >>> some_numbers[len(some_numbers) - 2] 'four' >>> some_numbers[-1] 'five' >>> some_numbers[-2] 'four' >>> some_numbers[-6] 'zero' thus any item in the list can be indexed in two ways: from the front and from the back. another useful way to get into parts of lists is using slicing. here is another example to give you an idea what they can be used for: >>> things = [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, "jack", "jill"] >>> things[0] 0 >>> things[7] 'jill' >>> things[0:8] [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, 'jack', 'jill'] >>> things[2:4] [2, 's.p.a.m.'] >>> things[4:7] ['stocking', 42, 'jack'] >>> things[1:5] ['fred', 2, 's.p.a.m.', 'stocking'] slicing is used to return part of a list. the slicing operator is in the form things[first_index:last_index]. slicing cuts the list before the first_index and before the last_index and returns the parts in between. you can use both types of indexing: >>> things[-4:-2] ['stocking', 42] >>> things[-4] 'stocking' >>> things[-4:6] ['stocking', 42] another trick with slicing is the unspecified index. if the first index is not specified the beginning of the list is assumed. if the last index is not specified the whole rest of the list is assumed. here are some examples: >>> things[:2] [0, 'fred'] >>> things[-2:] ['jack', 'jill'] >>> things[:3] [0, 'fred', 2] >>> things[:-5] [0, 'fred', 2] here is a (html inspired) program example (copy and paste in the poem definition if you want): poem = ["<b>", "jack", "and", "jill", "</b>", "went", "up", "the", "hill", "to", "<b>", "fetch", "a", "pail", "of", "</b>", "water.", "jack", "fell", "<b>", "down", "and", "broke", "</b>", "his", "crown", "and", "<b>", "jill", "came", "</b>", "tumbling", "after"] def get_bolds(text): true = 1 false = 0 ## is_bold tells whether or not we are currently looking at ## a bold section of text. is_bold = false ## start_block is the index of the start of either an unbolded ## segment of text or a bolded segment. start_block = 0 for index in range(len(text)): ## handle a starting of bold text if text[index] == "<b>": if is_bold: print("error: extra bold") ## print "not bold:", text[start_block:index] is_bold = true start_block = index + 1 ## handle end of bold text ## remember that the last number in a slice is the index ## after the last index used. if text[index] == "</b>": if not is_bold: print("error: extra close bold") print("bold [", start_block, ":", index, "]", text[start_block:index]) is_bold = false start_block = index + 1 get_bolds(poem) with the output being: bold [ 1 : 4 ] ['jack', 'and', 'jill'] bold [ 11 : 15 ] ['fetch', 'a', 'pail', 'of'] bold [ 20 : 23 ] ['down', 'and', 'broke'] bold [ 28 : 30 ] ['jill', 'came'] the get_bold() function takes in a list that is broken into words and tokens. the tokens that it looks for are <b> which starts the bold text and </b> which ends bold text. the function get_bold() goes through and searches for the start and end tokens. the next feature of lists is copying them. if you try something simple like: >>> a = [1, 2, 3] >>> b = a >>> print(b) [1, 2, 3] >>> b[1] = 10 >>> print(b) [1, 10, 3] >>> print(a) [1, 10, 3] this probably looks surprising since a modification to b resulted in a being changed as well. what happened is that the statement b = a makes b a reference to a. this means that b can be thought of as another name for a. hence any modification to b changes a as well. however some assignments don't create two names for one list: >>> a = [1, 2, 3] >>> b = a * 2 >>> print(a) [1, 2, 3] >>> print(b) [1, 2, 3, 1, 2, 3] >>> a[1] = 10 >>> print(a) [1, 10, 3] >>> print(b) [1, 2, 3, 1, 2, 3] in this case b is not a reference to a since the expression a * 2 creates a new list. then the statement b = a * 2 gives b a reference to a * 2 rather than a reference to a. all assignment operations create a reference. when you pass a list as an argument to a function you create a reference as well. most of the time you don't have to worry about creating references rather than copies. however when you need to make modifications to one list without changing another name of the list you have to make sure that you have actually created a copy. there are several ways to make a copy of a list. the simplest that works most of the time is the slice operator since it always makes a new list even if it is a slice of a whole list: >>> a = [1, 2, 3] >>> b = a[:] >>> b[1] = 10 >>> print(a) [1, 2, 3] >>> print(b) [1, 10, 3] taking the slice [:] creates a new copy of the list. however it only copies the outer list. any sublist inside is still a references to the sublist in the original list. therefore, when the list contains lists, the inner lists have to be copied as well. you could do that manually but python already contains a module to do it. you use the deepcopy function of the copy module: >>> import copy >>> a = [[1, 2, 3], [4, 5, 6]] >>> b = a[:] >>> c = copy.deepcopy(a) >>> b[0][1] = 10 >>> c[1][1] = 12 >>> print(a) [[1, 10, 3], [4, 5, 6]] >>> print(b) [[1, 10, 3], [4, 5, 6]] >>> print(c) [[1, 2, 3], [4, 12, 6]] first of all notice that a is a list of lists. then notice that when b[0][1] = 10 is run both a and b are changed, but c is not. this happens because the inner arrays are still references when the slice operator is used. however with deepcopy c was fully copied. so, should i worry about references every time i use a function or =? the good news is that you only have to worry about references when using dictionaries and lists. numbers and strings create references when assigned but every operation on numbers and strings that modifies them creates a new copy so you can never modify them unexpectedly. you do have to think about references when you are modifying a list or a dictionary. by now you are probably wondering why are references used at all? the basic reason is speed. it is much faster to make a reference to a thousand element list than to copy all the elements. the other reason is that it allows you to have a function to modify the inputed list or dictionary. just remember about references if you ever have some weird problem with data being changed when it shouldn't be. non-programmer's tutorial for python 3 ← using modules print version revenge of the strings → 16. revenge of the strings and now presenting a cool trick that can be done with strings: def shout(string): for character in string: print("gimme a " + character) print("'" + character + "'") shout("lose") def middle(string): print("the middle character is:", string[len(string) // 2]) middle("abcdefg") middle("the python programming language") middle("atlanta") and the output is: gimme a l 'l' gimme a o 'o' gimme a s 's' gimme a e 'e' the middle character is: d the middle character is: r the middle character is: a what these programs demonstrate is that strings are similar to lists in several ways. the shout() function shows that for loops can be used with strings just as they can be used with lists. the middle procedure shows that that strings can also use the len() function and array indexes and slices. most list features work on strings as well. the next feature demonstrates some string specific features: def to_upper(string): ## converts a string to upper case upper_case = "" for character in string: if 'a' <= character <= 'z': location = ord(character) - ord('a') new_ascii = location + ord('a') character = chr(new_ascii) upper_case = upper_case + character return upper_case print(to_upper("this is text")) with the output being: this is text this works because the computer represents the characters of a string as numbers from 0 to 1,114,111. for example 'a' is 65, 'b' is 66 and א is 1488. the values are the unicode value. python has a function called ord() (short for ordinal) that returns a character as a number. there is also a corresponding function called chr() that converts a number into a character. with this in mind the program should start to be clear. the first detail is the line: if 'a' <= character <= 'z': which checks to see if a letter is lower case. if it is then the next lines are used. first it is converted into a location so that a = 0, b = 1, c = 2 and so on with the line: location = ord(character) - ord('a'). next the new value is found with new_ascii = location + ord('a'). this value is converted back to a character that is now upper case. note that if you really need the upper case of a letter, you should use u=var.upper() which will work with other languages as well. now for some interactive typing exercise: >>> # integer to string >>> 2 2 >>> repr(2) '2' >>> -123 -123 >>> repr(-123) '-123' >>> # string to integer >>> "23" '23' >>> int("23") 23 >>> "23" * 2 '2323' >>> int("23") * 2 46 >>> # float to string >>> 1.23 1.23 >>> repr(1.23) '1.23' >>> # float to integer >>> 1.23 1.23 >>> int(1.23) 1 >>> int(-1.23) -1 >>> # string to float >>> float("1.23") 1.23 >>> "1.23" '1.23' >>> float("123") 123.0 if you haven't guessed already the function repr() can convert an integer to a string and the function int() can convert a string to an integer. the function float() can convert a string to a float. the repr() function returns a printable representation of something. here are some examples of this: >>> repr(1) '1' >>> repr(234.14) '234.14' >>> repr([4, 42, 10]) '[4, 42, 10]' the int() function tries to convert a string (or a float) into an integer. there is also a similar function called float() that will convert an integer or a string into a float. another function that python has is the eval() function. the eval() function takes a string and returns data of the type that python thinks it found. for example: >>> v = eval('123') >>> print(v, type(v)) 123 <type 'int'> >>> v = eval('645.123') >>> print(v, type(v)) 645.123 <type 'float'> >>> v = eval('[1, 2, 3]') >>> print(v, type(v)) [1, 2, 3] <type 'list'> if you use the eval() function you should check that it returns the type that you expect. one useful string function is the split() method. here's an example: >>> "this is a bunch of words".split() ['this', 'is', 'a', 'bunch', 'of', 'words'] >>> text = "first batch, second batch, third, fourth" >>> text.split(",") ['first batch', ' second batch', ' third', ' fourth'] notice how split() converts a string into a list of strings. the string is split by whitespace by default or by the optional argument (in this case a comma). you can also add another argument that tells split() how many times the separator will be used to split the text. for example: >>> list = text.split(",") >>> len(list) 4 >>> list[-1] ' fourth' >>> list = text.split(",", 2) >>> len(list) 3 >>> list[-1] ' third, fourth' slicing strings (and lists) strings can be cut into pieces — in the same way as it was shown for lists in the previous chapter — by using the slicing "operator" []. the slicing operator works in the same way as before: text[first_index:last_index] (in very rare cases there can be another colon and a third argument, as in the example shown below). in order not to get confused by the index numbers, it is easiest to see them as clipping places, possibilities to cut a string into parts. here is an example, which shows the clipping places (in yellow) and their index numbers (red and blue) for a simple text string: 0 1 2 ... -2 -1 ↓ ↓ ↓ ↓ ↓ ↓ ↓ text = " s t r i n g " ↑ ↑ [: :] note that the red indexes are counted from the beginning of the string and the blue ones from the end of the string backwards. (note that there is no blue -0, which could seem to be logical at the end of the string. because -0 == 0, -0 means "beginning of the string" as well.) now we are ready to use the indexes for slicing operations: text[1:4] → "tri" text[:5] → "strin" text[:-1] → "strin" text[-4:] → "ring" text[2] → "r" text[:] → "string" text[::-1] → "gnirts" text[1:4] gives us all of the text string between clipping places 1 and 4, "tri". if you omit one of the [first_index:last_index] arguments, you get the beginning or end of the string as default: text[:5] gives "strin". for both first_index and last_index we can use both the red and the blue numbering schema: text[:-1] gives the same as text[:5], because the index -1 is at the same place as 5 in this case. if we do not use an argument containing a colon, the number is treated in a different way: text[2] gives us one character following the second clipping point, "r". the special slicing operation text[:] means "from the beginning to the end" and produces a copy of the entire string (or list, as shown in the previous chapter). last but not least, the slicing operation can have a second colon and a third argument, which is interpreted as the "step size": text[::-1] is text from beginning to the end, with a step size of -1. -1 means "every character, but in the other direction". "string" backwards is "gnirts" (test a step length of 2, if you have not got the point here). all these slicing operations work with lists as well. in that sense strings are just a special case of lists, where the list elements are single characters. just remember the concept of clipping places, and the indexes for slicing things will get a lot less confusing. examples # this program requires an excellent understanding of decimal numbers. def to_string(in_int): """converts an integer to a string""" out_str = "" prefix = "" if in_int < 0: prefix = "-" in_int = -in_int while in_int // 10 != 0: out_str = str(in_int % 10) + out_str in_int = in_int // 10 out_str = str(in_int % 10) + out_str return prefix + out_str def to_int(in_str): """converts a string to an integer""" out_num = 0 if in_str[0] == "-": multiplier = -1 in_str = in_str[1:] else: multiplier = 1 for c in in_str: out_num = out_num * 10 + int(c) return out_num * multiplier print(to_string(2)) print(to_string(23445)) print(to_string(-23445)) print(to_int("14234")) print(to_int("12345")) print(to_int("-3512")) the output is: 2 23445 -23445 14234 12345 -3512 non-programmer's tutorial for python 3 ← more on lists print version file io → 17. file io file i/o here is a simple example of file i/o (input/output): # write a file with open("test.txt", "wt") as out_file: out_file.write("this text is going to out file\nlook at it and see!") # read a file with open("test.txt", "rt") as in_file: text = in_file.read() print(text) the output and the contents of the file test.txt are: this text is going to out file look at it and see! notice that it wrote a file called test.txt in the directory that you ran the program from. the \n in the string tells python to put a newline where it is. an overview of file i/o is: get a file object with the open function read or write to the file object (depending on how it was opened) if you did not use with to open the file, you'd have to close it manually the first step is to get a file object. the way to do this is to use the open function. the format is file_object = open(filename, mode) where file_object is the variable to put the file object, filename is a string with the filename, and mode is "rt" to read a file as text or "wt" to write a file as text (and a few others we will skip here). next the file objects functions can be called. the two most common functions are read and write. the write function adds a string to the end of the file. the read function reads the next thing in the file and returns it as a string. if no argument is given it will return the whole file (as done in the example). now here is a new version of the phone numbers program that we made earlier: def print_numbers(numbers): print("telephone numbers:") for k, v in numbers.items(): print("name:", k, "\tnumber:", v) print() def add_number(numbers, name, number): numbers[name] = number def lookup_number(numbers, name): if name in numbers: return "the number is " + numbers[name] else: return name + " was not found" def remove_number(numbers, name): if name in numbers: del numbers[name] else: print(name," was not found") def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. load numbers') print('6. save numbers') print('7. quit') print() phone_list = {} menu_choice = 0 print_menu() while true: menu_choice = int(input("type in a number (1-7): ")) if menu_choice == 1: print_numbers(phone_list) elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") add_number(phone_list, name, phone) elif menu_choice == 3: print("remove name and number") name = input("name: ") remove_number(phone_list, name) elif menu_choice == 4: print("lookup number") name = input("name: ") print(lookup_number(phone_list, name)) elif menu_choice == 5: filename = input("filename to load: ") load_numbers(phone_list, filename) elif menu_choice == 6: filename = input("filename to save: ") save_numbers(phone_list, filename) elif menu_choice == 7: break else: print_menu() print("goodbye") notice that it now includes saving and loading files. here is some output of my running it twice: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 2 add name and number name: jill number: 1234 type in a number (1-7): 2 add name and number name: fred number: 4321 type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 6 filename to save: numbers.txt type in a number (1-7): 7 goodbye 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 5 filename to load: numbers.txt type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 7 goodbye the new portions of this program are: def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() first we will look at the save portion of the program. first it creates a file object with the command open(filename, "wt"). next it goes through and creates a line for each of the phone numbers with the command out_file.write(k + "," + v + "\n"). this writes out a line that contains the name, a comma, the number and follows it by a newline. the loading portion is a little more complicated. it starts by getting a file object. then it uses a while true: loop to keep looping until a break statement is encountered. next it gets a line with the line in_line = in_file.readline(). the readline function will return an empty string when the end of the file is reached. the if statement checks for this and breaks out of the while loop when that happens. of course if the readline function did not return the newline at the end of the line there would be no way to tell if an empty string was an empty line or the end of the file so the newline is left in what readline returns. hence we have to get rid of the newline. the line in_line = in_line[:-1] does this for us by dropping the last character. next the line name, number = in_line.split(",") splits the line at the comma into a name and a number. this is then added to the numbers dictionary. advanced use of .txt files you might be saying to yourself, "well i know how to read and write to a textfile, but what if i want to print the file without opening out another program?" there are a few different ways to accomplish this. the easiest way does open another program, but everything is taken care of in the python code, and doesn't require the user to specify a file to be printed. this method involves invoking the subprocess of another program. remember the file we wrote output to in the above program? let's use that file. keep in mind, in order to prevent some errors, this program uses concepts from the next chapter. please feel free to revisit this example after the next chapter. import subprocess def main(): try: print("this small program invokes the print function in the notepad application") #lets print the file we created in the program above subprocess.call(['notepad','/p','numbers.txt']) except windowserror: print("the called subprocess does not exist, or cannot be called.") main() the subprocess.call takes three arguments. the first argument in the context of this example, should be the name of the program which you would like to invoke the printing subprocess from. the second argument should be the specific subprocess within that program. for simplicity, just understand that in this program, '/p' is the subprocess used to access your printer through the specified application. the last argument should be the name of the file you want to send to the printing subprocess. in this case, it is the same file used earlier in this chapter. exercises now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. solution now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = { } def load_grades(gradesfile): inputfile = open(gradesfile, "r") grades = [ ] while true: student_and_grade = inputfile.readline() student_and_grade = student_and_grade[:-1] if not student_and_grade: break else: studentname, studentgrades = student_and_grade.split(",") studentgrades = studentgrades.split(" ") students[studentname] = studentgrades inputfile.close() print("grades loaded.") def save_grades(gradesfile): outputfile = open(gradesfile, "w") for k, v in students.items(): outputfile.write(k + ",") for x in v: outputfile.write(str(x) + " ") outputfile.write("\n") outputfile.close() print("grades saved.") def print_menu(): print("1. add student") print("2. remove student") print("3. load grades") print("4. record grade") print("5. print grades") print("6. save grades") print("7. print menu") print("9. quit") def print_all_grades(): if students: keys = sorted(students.keys()) print('\t', end=' ') for x in assignments: print(x, '\t', end=' ') print() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) else: print("there are no grades to print.") def print_grades(grades): for x in grades: print(x, '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 9: print() menu_choice = int(input("menu choice: ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(assignments) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: gradesfile = input("load grades from which file? ") load_grades(gradesfile) elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i,x in enumerate(assignments): print(i + 1, x, '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 if 0 <= which < len(grades): grade = input("grade: ") # change from float(input()) to input() to avoid an error when saving grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice == 5: print_all_grades() elif menu_choice == 6: gradesfile = input("save grades to which file? ") save_grades(gradesfile) elif menu_choice != 9: print_menu() non-programmer's tutorial for python 3 ← revenge of the strings print version dealing with the imperfect → 18. dealing with the imperfect ...or how to handle errors closing files with with we use the "with" statement to open and close files.[1][2] with open("in_test.txt", "rt") as in_file: with open("out_test.txt", "wt") as out_file: text = in_file.read() data = parse(text) results = encode(data) out_file.write(results) print( "all done." ) if some sort of error happens anywhere in this code (one of the files is inaccessible, the parse() function chokes on corrupt data, etc.) the "with" statements guarantee that all the files will eventually be properly closed. closing a file just means that the file is "cleaned up" and "released" by our program so that it can be used in another program. to do: is the "closing files with with" section too much detail for a non-programmers tutorial? if so, move it to some other python wikibook (subject:python programming language) catching errors with try so you now have the perfect program, it runs flawlessly, except for one detail, it will crash on invalid user input. have no fear, for python has a special control structure for you. it's called try and it tries to do something. here is an example of a program with a problem: print("type control c or -1 to exit") number = 1 while number != -1: number = int(input("enter a number: ")) print("you entered:", number) notice how when you enter @#& it outputs something like: traceback (most recent call last): file "try_less.py", line 4, in <module> number = int(input("enter a number: ")) valueerror: invalid literal for int() with base 10: '\\@#&' as you can see the int() function is unhappy with the number @#& (as well it should be). the last line shows what the problem is; python found a valueerror. how can our program deal with this? what we do is first: put the place where errors may occur in a try block, and second: tell python how we want valueerrors handled. the following program does this: print("type control c or -1 to exit") number = 1 while number != -1: try: number = int(input("enter a number: ")) print("you entered:", number) except valueerror: print("that was not a number.") now when we run the new program and give it @#& it tells us "that was not a number." and continues with what it was doing before. when your program keeps having some error that you know how to handle, put code in a try block, and put the way to handle the error in the except block. exercises update at least the phone numbers program (in section dictionaries) so it doesn't crash if a user doesn't enter any data at the menu. solution def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: try: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() except valueerror: print("that was not a number.") non-programmer's tutorial for python 3 ← file io print version recursion → 19. the end so here we are at the end, or maybe the beginning. this tutorial is on wikibooks, so feel free to make improvements to it. if you want to learn more about python, the python tutorial by guido van rossum has more topics that you can learn about. if you have been following this tutorial, you should be able to understand a fair amount of it. the python programming wikibook can be worth looking at, too. here are few other books which cover python 3: a byte of python by swaroop c h datacamp interactive python 3 tutorial - online hands-on python tutorial by dr. andrew n. harrington subject:python programming language lists other wikibooks related to python. hopefully this book covers everything you have needed to get started programming. thanks to everyone who has sent me emails about it. i enjoyed reading them, even when i have not always been the best replier. happy programming, may it change your life and the world. non-programmer's tutorial for python 3 ← intro to imported libraries and other functions print version faq → 20. faq how do i make a gui in python? you can use one of these library: tkinter, pyqt, pygobject. for really simple graphics, you can use the turtle graphics mode import turtle how do i make a game in python? the best method is probably to use pygame at http://pygame.org/ how do i make an executable from a python program? short answer: python is an interepreted language so that is impossible. long answer is that something similar to an executable can be created by taking the python interpreter and the file and joining them together and distributing that. for more on that problem see http://www.python.org/doc/faq/programming/#how-can-i-create-a-stand-alone-binary-from-a-python-script (ifaq) why do you use first person in this tutorial? once upon a time in a different millenia, (1999 to be exact), an earlier version was written entirely by josh cogliati, and it was up on his webpage http://www.honors.montana.edu/~jjc/easytut and it was good. then the server rupert, like all good things than have a beginning came to an end, and josh moved it to wikibooks, but the first person writing stuck. if someone really wants to change it, i will not revert it, but i don't see much point. (the webpage has since moved to http://jjc.freeshell.org/easytut/ and http://jjc.freeshell.org/easytut3/ ) my question is not answered. ask on the discussion page or add it to this faq, or email one of the authors. for other faqs, you may want to see the python 2.6 version of this page non-programmer's tutorial for python 2.6/faq, or the python faq. non-programmer's tutorial for python 3 ← the end print version ↑ "the 'with' statement" ↑ 'the python "with" statement by example' retrieved from "https://en.wikibooks.org/w/index.php?title=non-programmer%27s_tutorial_for_python_3/print_version&oldid=3412786"this is the print version of non-programmer's tutorial for python 3you won't see this message or any elements not part of the book's content when you print or preview this page. non-programmer's tutorial for python 3 the current, editable version of this book is available in wikibooks, the open-content textbooks collection, at https://en.wikibooks.org/wiki/non-programmer%27s_tutorial_for_python_3 permission is granted to copy, distribute, and/or modify this document under the terms of the creative commons attribution-sharealike 3.0 license. contents 1 1. front matter 1.1 other resources 2 2. intro 2.1 first things first 2.2 installing python 2.2.1 linux, bsd, and unix users 2.2.2 mac users 2.2.3 windows users 2.2.3.1 configuring your path environment variable 2.3 interactive mode 2.4 creating and running programs 2.4.1 program file names 2.5 using python from the command line 2.5.1 running python programs in *nix 2.6 where to get help 2.6.1 python documentation 2.6.2 python user community 3 3. hello, world 3.1 what you should know 3.2 printing 3.2.1 terminology 3.3 expressions 3.3.1 arithmetic expressions 3.4 commenting in python 3.5 examples 3.6 exercises 3.6.1 footnotes 4 4. who goes there? 4.1 input and variables 4.2 assignment 4.3 examples 4.4 exercises 5 5. count to 10 5.1 while loops 5.1.1 infinite loops or never ending loop 5.2 examples 5.2.1 fibonacci sequence 5.2.2 enter password 5.3 exercises 6 6. decisions 6.1 if statement 6.2 examples 6.3 exercises 7 7. debugging 7.1 what is debugging? 7.2 what should the program do? 7.3 what does the program do? 7.4 how do i fix my program? 8 8. defining functions 8.1 creating functions 8.2 variables in functions 8.3 examples 8.4 exercises 9 9. advanced functions example 9.1 recursion 9.2 examples 10 10. lists 10.1 variables with more than one value 10.2 more features of lists 10.3 examples 10.4 exercises 11 11. for loops 12 12. boolean expressions 12.1 a note on boolean operators 12.2 examples 12.3 exercises 13 13. dictionaries 14 14. using modules 14.1 exercises 14.2 other modules 14.2.1 creating your own module 14.2.1.1 the __name__ == __main__ trick 14.2.2 the pip module 15 15. more on lists 16 16. revenge of the strings 16.1 slicing strings (and lists) 16.2 examples 17 17. file io 17.1 file i/o 17.2 advanced use of .txt files 17.3 exercises 18 18. dealing with the imperfect 18.1 ...or how to handle errors 18.2 closing files with with 18.3 catching errors with try 18.4 exercises 19 19. the end 20 20. faq 1. front matter all example python source code in this tutorial is granted to the public domain. therefore you may modify it and relicense it under any license you please. since you are expected to learn programming, the creative commons attribution-sharealike license would require you to keep all programs that are derived from the source code in this tutorial under that license. since the python source code is granted to the public domain, that requirement is waived. this tutorial is more or less a conversion of non-programmer's tutorial for python 2.6. older versions and some versions in korean, spanish, italian and greek are available from http://jjc.freeshell.org/easytut/ the non-programmers' tutorial for python 3 is a tutorial designed to be an introduction to the python programming language. this guide is for someone with no programming experience. if you have programmed in other languages i recommend using python tutorial for programmers written by guido van rossum. if you have any questions or comments please use the discussion pages or see authors page for author contact information. i welcome questions and comments about this tutorial. i will try to answer any questions you have as best i can. thanks go to james a. brown for writing most of the windows install info. thanks also to elizabeth cogliati for complaining enough :) about the original tutorial (that is almost unusable for a non-programmer), for proofreading, and for many ideas and comments on it. thanks to joe oppegaard for writing almost all the exercises. thanks to everyone i have missed. other resources python home page python 3 documentation a byte of python by swaroop c h porting to python 3: an in-depth guide non-programmer's tutorial for python 3 ← authors print version intro → 2. intro first things first so, you've never programmed before. as we go through this tutorial, i will attempt to teach you how to program. there really is only one way to learn to program. you must read code and write code (as computer programs are often called). i'm going to show you lots of code. you should type in code that i show you to see what happens. play around with it and make changes. the worst that can happen is that it won't work. when i type in code it will be formatted like this: # python is easy to learn print("hello, world!") that's so it is easy to distinguish from the other text. if you're reading this on the web, you'll notice the code is in color -- that's just to make it stand out, and to make the different parts of the code stand out from each other. the code you enter will probably not be colored, or the colors may be different, but it won't affect the code as long as you enter it the same way as it's printed here. if the computer prints something out it will be formatted like this: hello, world! (note that printed text goes to your screen, and does not involve paper. before computers had screens, the output of computer programs would be printed on paper.) note that this is a python 3 tutorial, which means that most of the examples will not work in python 2.7 and before. as well, all but a small number of the extra python 2.7 libraries (third-party libraries) have been converted to python 3. most likely you will want to learn python 3, but if you are learning python for a specific package or set of modules that are only written in python 2.7, you may want to consider learning from the non-programmer's tutorial for python 2.6. however, the differences between python 2 and 3 are not particularly large, so if you learn one, you should be able to read programs written for the other without much difficulty. there will often be a mixture of the text you type (which is shown in bold) and the text the program prints to the screen, which would look like this: halt! who goes there? josh you may pass, josh (some of the tutorial has not been converted to this format. since this is a wiki, you can convert it when you find it.) i will also introduce you to the terminology of programming - for example, that programming is often referred to as coding or hacking. this will not only help you understand what programmers are talking about, but also help the learning process. now, on to more important things. in order to program in python you need the python 3 software. if you don't already have the python software go to www.python.org/download and get the proper version for your platform. download it, read the instructions and get it installed. installing python for python programming you need a working python installation and a text editor. python comes with its own editor, idle, which is quite nice and totally sufficient for the beginning. as you get more into programming, you will probably switch to some other editor like nano, emacs, vi or another. the python download page is http://www.python.org/download. the most recent version is python 3.8.5 (as of july 2020); python 2.7 and older versions will not work with this tutorial. there are various different installation files for different computer platforms available on the download site. here are some specific instructions for the most common operating systems: linux, bsd, and unix users you are probably lucky and python is already installed on your machine. to test it type python3 on a command line. if you see something like what is shown in the following section, you are set. idle may need to be installed separately, from its own package such as idle3 or as part of python-tools. if you have to install python, first try to use the operating system's package manager or go to the repository where your packages are available and get python 3. python 3.0 was released in december 2008; all distributions should have python 3 available, so you may not need to compile it from scratch. ubuntu and fedora do have python 3 binary packages available, but they are not yet the default, so they need to be installed specially. roughly, here are the steps to compile python from source code in unix (if these totally don't make sense, you may want to read another introduction to *nix, such as introduction to linux): download the .tgz file (use your web browser to get the gzipped tar file from https://www.python.org/ftp/python/3.7.4/python-3.7.4.tgz) uncompress the tar file (put in the correct path to where you downloaded it): $ tar -xvzf ~/download/python-3.7.4.tgz ... list of files as they are uncompressed change to the directory and tell the computer to compile and install the program $ cd python-3.7/ $ ./configure --prefix=$home/python3_install ... lots of output. watch for error messages here ... $ make ... even more output. hopefully no error messages ... $ make install add python 3 to your path. you can test it first by specifying the full path. you should add $home/python3_install/bin to your path bash variable. $ ~/python3_install/bin/python3 python 3.7.4 (... size and date information ...) [gcc 9.1.0] on linux type "help", "copyright", "credits" or "license" for more information. >>> the above commands will install python 3 to your home directory, which is probably what you want, but if you skip the --prefix=$home/python3_install, it will install it to /usr/local. if you want to use the idle graphical code editor, you need to make sure that the tk and tcl libraries, together with their development files, are installed on the system. you will get a warning during the make phase if these are not available. mac users starting from mac os x tiger (10.4), versions of python 2 shipped with the operating system by default, but you will need to also install python 3 unless mac os starts including python 3 (check the version by starting python3 in a command line terminal). also idle (the python editor) might be missing in the standard installation. if you want to (re-)install python, get the mac os installer from the python download site. windows users download the appropriate windows installer (the x86 msi installer, if you do not have a 64-bit amd or intel chip). start the installer by double-clicking it and follow the prompts. see https://docs.python.org/3/using/windows.html#installing-python for more information. configuring your path environment variable the path environment variable is a list of folders, separated by semicolons, in which windows will look for a program whenever you try to execute one by typing its name at a command prompt. you can see the current value of your path by typing this command at a command prompt: echo %path% the easiest way to permanently change environment variables is to bring up the built-in environment variable editor in windows. how you get to this editor is slightly different on different versions of windows. on windows 8 or windows 10: press the windows key and type control panel to locate the windows control panel. once you've opened the control panel, select view by: large icons, then click on system. in the window that pops up, click the advanced system settings link, then click the environment variables... button. on windows 7 or vista: click the start button in the lower-left corner of the screen, move your mouse over computer, right-click, and select properties from the pop-up menu. click the advanced system settings link, then click the environment variables... button. once you've brought up the environment variable editor, you'll do the same thing regardless of which version of windows you're running. under system variables in the bottom half of the editor, find a variable called path. if there is is one, select it and click edit.... assuming your python root is c:\python37, add these two folders to your path (and make sure you get the semicolons right; there should be a semicolon between each folder in the list): c:\python37 c:\python37\scripts note: if you want to double-click and start your python programs from a windows folder and not have the console window disappear, you can add the following code to the bottom of each script: #stops console from exiting end_prog = "" while end_prog != "q": end_prog = input("type q to quit") interactive mode go into idle (also called the python gui). you should see a window that has some text like this: python 3.0 (r30:67503, dec 29 2008, 21:31:07) [gcc 4.3.2 20081105 (red hat 4.3.2-7)] on linux2 type "copyright", "credits" or "license()" for more information. **************************************************************** personal firewall software may warn about the connection idle makes to its subprocess using this computer's internal loopback interface. this connection is not visible on any external interface and no data is sent to or received from the internet. **************************************************************** idle 3.0 >>> the >>> is python's way of telling you that you are in interactive mode. in interactive mode what you type is immediately run. try typing 1+1 in. python will respond with 2. interactive mode allows you to test out and see what python will do. if you ever feel you need to play with new python statements, go into interactive mode and try them out. creating and running programs go into idle if you are not already. in the menu at the top, select file then new file. in the new window that appears, type the following: print("hello, world!") now save the program: select file from the menu, then save. save it as "hello.py" (you can save it in any folder you want). now that it is saved it can be run. next run the program by going to run then run module (or if you have an older version of idle use edit then run script). this will output hello, world! on the *python shell* window. for a more in-depth introduction to idle, a longer tutorial with screenshots can be found at http://hkn.eecs.berkeley.edu/~dyoo/python/idle_intro/index.html. program file names it is very useful to stick to some rules regarding the file names of python programs. otherwise some things might go wrong unexpectedly. these don't matter as much for programs, but you can have weird problems if you don't follow them for module names (modules will be discussed later). always save the program with the extension .py. do not put another dot anywhere else in the file name. only use standard characters for file names: letters, numbers, dash (-) and underscore (_). white space (" ") should not be used at all (use underscores instead). do not use anything other than a letter (particularly no numbers!) at the beginning of a file name. do not use "non-english" characters (such as å, ɓ, ç, ð, é, õ, ü) in your file names—or, even better, do not use them at all when programming. do not use module names for file names (such as print.py, math.py, list.py) using python from the command line if you don't want to use python from the command line, you don't have to, just use idle. to get into interactive mode just type python3 without any arguments. to run a program, create it with a text editor (emacs has a good python mode) and then run it with python3 program_name. running python programs in *nix if you are using unix (such as linux, mac os, or bsd), if you make the program executable with chmod, and have as the first line: #!/usr/bin/env python3 you can run the python program with ./hello.py like any other command. where to get help at some point in your python career you will probably get stuck and have no clue about how to solve the problem you are supposed to work on. this tutorial only covers the basics of python programming, but there is a lot of further information available. python documentation first of all, python is very well documented. there might even be copies of these documents on your computer that came with your python installation: the official python 3 tutorial by guido van rossum is often a good starting point for general questions. for questions about standard modules (you will learn what these are later), the python 3 library reference is the place to look. if you really want to get to know something about the details of the language, the python 3 reference manual is comprehensive but quite complex for beginners. python user community there are a lot of other python users out there, and usually they are nice and willing to help you. this very active user community is organised mostly through mailing lists and a newsgroup: the tutor mailing list is for folks who want to ask questions regarding how to learn computer programming with the python language. the python-help mailing list is python.org's help desk. you can ask a group of knowledgeable volunteers questions about all your python problems. the python newsgroup comp.lang.python (google groups archive) is the place for general python discussions, questions and the central meeting point of the community. python wiki has a list of local user groups, you can join the group mailing list and ask questions. you can also participate in the user group meetings. learnpython subreddit is another location where beginner level questions can be asked. in order not to reinvent the wheel and discuss the same questions again and again, people will appreciate very much if you do a web search for a solution to your problem before contacting these lists! non-programmer's tutorial for python 3 ← front matter print version hello, world → 3. hello, world what you should know once you've read and mastered this chapter, you should know how to edit programs in a text editor or idle, save them to the hard disk, and run them once they have been saved. printing programming tutorials since the beginning of time have started with a little program called "hello, world!"[1] so here it is: print("hello, world!") if you are using the command line to run programs then type it in with a text editor, save it as hello.py and run it with python3 hello.py otherwise go into idle, create a new window, and create the program as in section creating and running programs. when this program is run here's what it prints: hello, world! now i'm not going to tell you this every time, but when i show you a program i recommend that you type it in and run it. i learn better when i type it in and you probably do too. now here is a more complicated program: print("jack and jill went up a hill") print("to fetch a pail of water;") print("jack fell down, and broke his crown,") print("and jill came tumbling after.") when you run this program it prints out: jack and jill went up a hill to fetch a pail of water; jack fell down, and broke his crown, and jill came tumbling after. when the computer runs this program it first sees the line: print("jack and jill went up a hill") so the computer prints: jack and jill went up a hill then the computer goes down to the next line and sees: print("to fetch a pail of water;") so the computer prints to the screen: to fetch a pail of water; the computer keeps looking at each line, follows the command and then goes on to the next line. the computer keeps running commands until it reaches the end of the program. terminology now is probably a good time to give you a bit of an explanation of what is happening - and a little bit of programming terminology. what we were doing above was using a function called print. the function's name - print - is followed by parentheses containing zero or more arguments. so in this example print("hello, world!") there is one argument, which is "hello, world!". note that this argument is a group of characters enclosed in double quotes (""). this is commonly referred to as a string of characters, or string, for short. another example of a string is "jack and jill went up a hill". the combination of a function and parentheses with the arguments is a function call. a function and its arguments are one type of statement that python has, so print("hello, world!") is an example of a statement. basically, you can think of a statement as a single line in a program. that's probably more than enough terminology for now. expressions here is another program: print("2 + 2 is", 2 + 2) print("3 * 4 is", 3 * 4) print("100 - 1 is", 100 - 1) print("(33 + 2) / 5 + 11.5 is", (33 + 2) / 5 + 11.5) and here is the output when the program is run: 2 + 2 is 4 3 * 4 is 12 100 - 1 is 99 (33 + 2) / 5 + 11.5 is 18.5 as you can see, python can turn your thousand-dollar computer into a five-dollar calculator. arithmetic expressions in this example, the print function is followed by two arguments, with each of the arguments separated by a comma. so with the first line of the program print("2 + 2 is", 2 + 2) the first argument is the string "2 + 2 is" and the second argument is the arithmetic expression 2 + 2, which is one kind of expression. what is important to note is that a string is printed as is (without the enclosing double quotes), but an expression is evaluated, or converted to its actual value. python has seven basic operations for numbers: operation symbol example power (exponentiation) ** 5 ** 2 == 25 multiplication * 2 * 3 == 6 division / 14 / 3 == 4.666666666666667 integer division // 14 // 3 == 4 remainder (modulo) % 14 % 3 == 2 addition + 1 + 2 == 3 subtraction - 4 - 3 == 1 notice that there are two ways to do division, one that returns the repeating decimal, and the other that can get the remainder and the whole number. the order of operations is the same as in math: parentheses () exponents ** multiplication *, division /, integer division //, and remainder % addition + and subtraction - so use parentheses to structure your formulas when needed. commenting in python often in programming, you are doing something complicated and may not in the future remember what you did. when this happens the program should probably be commented. a comment is a note to you and other programmers explaining what is happening. for example: # not quite pi, but a credible simulation print(22 / 7) which outputs 3.14285714286 notice that the comment starts with a hash: #. comments are used to communicate with others who read the program and your future self to make clear what is complicated. note that any text can follow comment and that when the program is run, the text after the # through to the end of that line is ignored. the # does not have to be at the beginning of a new line: # output pi on the screen print(22 / 7) # well, just a good approximation examples each chapter (eventually) will contain examples of the programming features introduced in the chapter. you should at least look over them and see if you understand them. if you don't, you may want to type them in and see what happens. mess around with them, change them and see what happens. denmark.py print("something's rotten in the state of denmark.") print(" -- shakespeare") output: something's rotten in the state of denmark. -- shakespeare school.py # this is not quite true outside of usa # and is based on my dim memories of my younger years print("firstish grade") print("1 + 1 =", 1 + 1) print("2 + 4 =", 2 + 4) print("5 - 2 =", 5 - 2) print() print("thirdish grade") print("243 - 23 =", 243 - 23) print("12 * 4 =", 12 * 4) print("12 / 3 =", 12 / 3) print("13 / 3 =", 13 // 3, "r", 13 % 3) print() print("junior high") print("123.56 - 62.12 =", 123.56 - 62.12) print("(4 + 3) * 2 =", (4 + 3) * 2) print("4 + 3 * 2 =", 4 + 3 * 2) print("3 ** 2 =", 3 ** 2) output: firstish grade 1 + 1 = 2 2 + 4 = 6 5 - 2 = 3 thirdish grade 243 - 23 = 220 12 * 4 = 48 12 / 3 = 4 13 / 3 = 4 r 1 junior high 123.56 - 62.12 = 61.44 (4 + 3) * 2 = 14 4 + 3 * 2 = 10 3 ** 2 = 9 exercises write a program that prints your full name and your birthday as separate strings. write a program that shows the use of all 7 arithmetic operations. solution 1. write a program that prints your full name and your birthday as separate strings. print("ada lovelace", "born on", "november 27, 1852") print("albert einstein", "born on", "14 march 1879") print(("john smith"), ("born on"), ("14 march 1879")) solution 2. write a program that shows the use of all 7 arithmetic operations. print("5**5 = ", 5**5) print("6*7 = ", 6*7) print("56/8 = ", 56/8) print("14//6 = ", 14//6) print("14%6 = ", 14%6) print("5+6 = ", 5+6) print("9-0 = ", 9-0) footnotes ↑ here is a great list of the famous "hello, world!" program in many programming languages. just so you know how simple python can be... non-programmer's tutorial for python 3 ← intro print version who goes there? → 4. who goes there? input and variables now i feel it is time for a really complicated program. here it is: print("halt!") user_input = input("who goes there? ") print("you may pass,", user_input) when i ran it, here is what my screen showed: halt! who goes there? josh you may pass, josh note: after running the code by pressing f5, the python shell will only give output: halt! who goes there? you need to enter your name in the python shell, and then press enter for the rest of the output. of course when you run the program your screen will look different because of the input() statement. when you ran the program you probably noticed (you did run the program, right?) how you had to type in your name and then press enter. then the program printed out some more text and also your name. this is an example of input. the program reaches a certain point and then waits for the user to input some data that the program can use later. of course, getting information from the user would be useless if we didn't have anywhere to put that information and this is where variables come in. in the previous program user_input is a variable. variables are like a box that can store some piece of data. here is a program to show examples of variables: a = 123.4 b23 = 'spam' first_name = "bill" b = 432 c = a + b print("a + b is",c) print("first_name is",first_name) print("sorted parts, after midnight or",b23) and here is the output: a + b is 555.4 first_name is bill sorted parts, after midnight or spam variables store data. the variables in the above program are a, b23, first_name, b, and c. the two basic types are strings and numbers. strings are a sequence of letters, numbers and other characters. in this example b23 and first_name are variables that are storing strings. spam, bill, a + b is, first_name is, and sorted parts, after midnight or are the strings in this program. the characters are surrounded by " or '. the other type of variables are numbers. remember that variables are used to store a value, they do not use quotation marks (" and '). if you want to use an actual value, you must use quotation marks. value1 == pim value2 == "pim" both look the same, but in the first one python checks if the value stored in the variable value1 is the same as the value stored in the variable pim. in the second one, python checks if the string (the actual letters p,i, and m) are the same as in value2 (continue this tutorial for more explanation about strings and about the ==). assignment okay, so we have these boxes called variables and also data that can go into the variable. the computer will see a line like first_name = "bill" and it reads it as "put the string bill into the box (or variable) first_name". later on it sees the statement c = a + b and it reads it as "put the sum of a + b or 123.4 + 432 which equals 555.4 into c". the right hand side of the statement (a + b) is evaluated and the result is stored in the variable on the left hand side (c). this is called assignment, and you should not confuse the assignment equal sign (=) with "equality" in a mathematical sense here (that's what == will be used for later). here is another example of variable usage: a = 1 print(a) a = a + 1 print(a) a = a * 2 print(a) and of course here is the output: 1 2 4 even if the same variable appears on both sides of the equals sign (e.g., spam = spam), the computer still reads it as, "first find out the data to store and then find out where the data goes." one more program before i end this chapter: number = float(input("type in a number: ")) integer = int(input("type in an integer: ")) text = input("type in a string: ") print("number =", number) print("number is a", type(number)) print("number * 2 =", number * 2) print("integer =", integer) print("integer is a", type(integer)) print("integer * 2 =", integer * 2) print("text =", text) print("text is a", type(text)) print("text * 2 =", text * 2) the output i got was: type in a number: 12.34 type in an integer: -3 type in a string: hello number = 12.34 number is a <class 'float'> number * 2 = 24.68 integer = -3 integer is a <class 'int'> integer * 2 = -6 text = hello text is a <class 'str'> text * 2 = hellohello notice that number was created with float(input()) ,int(input()) returns an integer, a number with no decimal point, while text created with input() returns a string(can be writen as str(input()), too). when you want the user to type in a decimal use float(input()), if you want the user to type in an integer use int(input()), but if you want the user to type in a string use input(). the second half of the program uses the type() function which tells what kind a variable is. numbers are of type int or float, which are short for integer and floating point (mostly used for decimal numbers), respectively. text strings are of type str, short for string. integers and floats can be worked on by mathematical functions, strings cannot. notice how when python multiplies a number by an integer the expected thing happens. however when a string is multiplied by an integer the result is that multiple copies of the string are produced (i.e., text * 2 = hellohello). operations with strings do different things than operations with numbers. as well, some operations only work with numbers (both integers and floating point numbers) and will give an error if a string is used. here are some interactive mode examples to show that some more. >>> print("this" + " " + "is" + " joined.") this is joined. >>> print("ha, " * 5) ha, ha, ha, ha, ha, >>> print("ha, " * 5 + "ha!") ha, ha, ha, ha, ha, ha! >>> print(3 - 1) 2 >>> print("3" - "1") traceback (most recent call last): file "<stdin>", line 1, in <module> typeerror: unsupported operand type(s) for -: 'str' and 'str' >>> here is the list of some string operations: operation symbol example repetition * "i" * 5 == "iiiii" concatenation + "hello, " + "world!" == "hello, world!" examples rate_times.py # this program calculates rate and distance problems print("input a rate and a distance") rate = float(input("rate: ")) distance = float(input("distance: ")) time=(distance/ rate) print("time:", time) sample runs: input a rate and a distance rate: 5 distance: 10 time: 2.0 input a rate and a distance rate: 3.52 distance: 45.6 time: 12.9545454545 area.py # this program calculates the perimeter and area of a rectangle print("calculate information about a rectangle") length = float(input("length: ")) width = float(input("width: ")) perimeter=(2 * length + 2 * width) print("area:", length * width) print("perimeter:",perimeter) sample runs: calculate information about a rectangle length: 4 width: 3 area: 12.0 perimeter: 14.0 calculate information about a rectangle length: 2.53 width: 5.2 area: 13.156 perimeter: 15.46 temperature.py # this program converts fahrenheit to celsius fahr_temp = float(input("fahrenheit temperature: ")) celc_temp = (fahr_temp - 32.0) *( 5.0 / 9.0) print("celsius temperature:", celc_temp) sample runs: fahrenheit temperature: 32 celsius temperature: 0.0 fahrenheit temperature: -40 celsius temperature: -40.0 fahrenheit temperature: 212 celsius temperature: 100.0 fahrenheit temperature: 98.6 celsius temperature: 37.0 exercises write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. solution write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. string1 = input('string 1: ') string2 = input('string 2: ') float1 = float(input('number 1: ')) float2 = float(input('number 2: ')) print(string1 + string2) print(float1 * float2) non-programmer's tutorial for python 3 ← hello, world print version count to 10 → 5. count to 10 while loops presenting our first control structure. ordinarily the computer starts with the first line and then goes down from there. control structures change the order that statements are executed or decide if a certain statement will be run. here's the source for a program that uses the while control structure: a = 0 # first, set the initial value of the variable a to 0(zero). while a < 10: # while the value of the variable a is less than 10 do the following: a = a + 1 # increase the value of the variable a by 1, as in: a = a + 1! print(a) # print to screen what the present value of the variable a is. # repeat! until the value of the variable a is equal to 9!? see note. # note: # the value of the variable a will increase by 1 # with each repeat, or loop of the 'while statement block'. # e.g. a = 1 then a = 2 then a = 3 etc. until a = 9 then... # the code will finish adding 1 to a (now a = 10), printing the # result, and then exiting the 'while statement block'. # -- # while a < 10: | # a = a + 1 |<--[ the while statement block ] # print (a) | # -- and here is the extremely exciting output: 1 2 3 4 5 6 7 8 9 10 (and you thought it couldn't get any worse after turning your computer into a five-dollar calculator?) so what does the program do? first it sees the line a = 0 and sets a to zero. then it sees while a < 10: and so the computer checks to see if a < 10. the first time the computer sees this statement, a is zero, so it is less than 10. in other words, as long as a is less than ten, the computer will run the tabbed in statements. this eventually makes a equal to ten (by adding one to a again and again) and the while a < 10 is not true any longer. reaching that point, the program will stop running the indented lines. always remember to put a colon ":" at the end of the while statement line! here is another example of the use of while: a = 1 s = 0 print('enter numbers to add to the sum.') print('enter 0 to quit.') while a != 0: print('current sum:', s) a = float(input('number? ')) s = s + a print('total sum =', s) enter numbers to add to the sum. enter 0 to quit. current sum: 0 number? 200 current sum: 200.0 number? -15.25 current sum: 184.75 number? -151.85 current sum: 32.9 number? 10.00 current sum: 42.9 number? 0 total sum = 42.9 notice how print('total sum =', s) is only run at the end. the while statement only affects the lines that are indented with whitespace. the != means does not equal so while a != 0: means as long as a is not zero run the tabbed statements that follow. note that a is a floating point number, and not all floating point numbers can be accurately represented, so using != on them can sometimes not work. try typing in 1.1 in interactive mode. infinite loops or never ending loop now that we have while loops, it is possible to have programs that run forever. an easy way to do this is to write a program like this: while 1 == 1: print("help, i'm stuck in a loop.") the "==" operator is used to test equality of the expressions on the two sides of the operator, just as "<" was used for "less than" before (you will get a complete list of all comparison operators in the next chapter). this program will output help, i'm stuck in a loop. until the heat death of the universe or you stop it, because 1 will forever be equal to 1. the way to stop it is to hit the control (or ctrl) button and c (the letter) at the same time. this will kill the program. (note: sometimes you will have to hit enter after the control-c.) on some systems, nothing will stop it, short of killing the process--so avoid! examples fibonacci sequence fibonacci-method1.py # this program calculates the fibonacci sequence a = 0 b = 1 count = 0 max_count = 20 while count < max_count: count = count + 1 print(a, end=" ") # notice the magic end=" " in the print function arguments # that keeps it from creating a new line. old_a = a # we need to keep track of a since we change it. a = b b = old_a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 note that the output is on a single line because of the extra argument end=" " in the print arguments. fibonacci-method2.py # simplified and faster method to calculate the fibonacci sequence a = 0 b = 1 count = 0 max_count = 10 while count < max_count: count = count + 1 print(a, b, end=" ") # notice the magic end=" " a = a + b b = a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 fibonacci-method3.py a = 0 b = 1 count = 0 maxcount = 20 #once loop is started we stay in it while count < maxcount: count += 1 olda = a a = a + b b = olda print(olda,end=" ") print() output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 enter password password.py # waits until a password has been entered. use control-c to break out without # the password #note that this must not be the password so that the # while loop runs at least once. password = str() # note that != means not equal while password != "unicorn": password = input("password: ") print("welcome in") sample run: password: auo password: y22 password: password password: open sesame password: unicorn welcome in exercises write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. solution write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. name = input("what is your username: ") password = input("what is your password: ") print("to lock your computer type lock.") command = none input1 = none input2 = none while command != "lock": command = input("what is your command: ") while input1 != name: input1 = input("what is your username: ") while input2 != password: input2 = input("what is your password: ") print("welcome back to your system!") if you would like the program to run continuously, just add a while 1 == 1: loop around the whole thing. you will have to indent the rest of the program when you add this at the top of the code, but don't worry, you don't have to do it manually for each line! just highlight everything you want to indent and click on "indent" under "format" in the top bar of the python window. another way of doing this could be: name = input('set name: ') password = input('set password: ') while 1 == 1: nameguess="" passwordguess="" key="" while (nameguess != name) or (passwordguess != password): nameguess = input('name? ') passwordguess = input('password? ') print("welcome,", name, ". type lock to lock.") while key != "lock": key = input("") notice the or in while (nameguess != name) or (passwordguess != password), which we haven't yet introduced. you can probably figure out how it works. non-programmer's tutorial for python 3 ← who goes there? print version decisions → 6. decisions if statement as always, i believe i should start each chapter with a warm-up typing exercise, so here is a short program to compute the absolute value of an integer: n = int(input("number? ")) if n < 0: print("the absolute value of", n, "is", -n) else: print("the absolute value of", n, "is", n) here is the output from the two times that i ran this program: number? -34 the absolute value of -34 is 34 number? 1 the absolute value of 1 is 1 so what does the computer do when it sees this piece of code? first it prompts the user for a number with the statement "n = int(input("number? "))". next it reads the line "if n < 0:". if n is less than zero python runs the line "print("the absolute value of", n, "is", -n)". otherwise it runs the line "print("the absolute value of", n, "is", n)". more formally python looks at whether the expression n < 0 is true or false. an if statement is followed by an indented block of statements that are run when the expression is true. optionally after the if statement is an else statement and another indented block of statements. this second block of statements is run if the expression is false. there are a number of different tests that an expression can have. here is a table of all of them: operator function < less than <= less than or equal to > greater than >= greater than or equal to == equal != not equal another feature of the if command is the elif statement. it stands for else if and means if the original if statement is false but the elif part is true, then do the elif part. and if neither the if or elif expressions are true, then do what's in the else block. here's an example: a = 0 while a < 10: a = a + 1 if a > 5: print(a, ">", 5) elif a <= 3: print(a, "<=", 3) else: print("neither test was true") and the output: 1 <= 3 2 <= 3 3 <= 3 neither test was true neither test was true 6 > 5 7 > 5 8 > 5 9 > 5 10 > 5 notice how the elif a <= 3 is only tested when the if statement fails to be true. there can be more than one elif expression, allowing multiple tests to be done in a single if statement. examples # this program demonstrates the use of the == operator # using numbers print(5 == 6) # using variables x = 5 y = 8 print(x == y) and the output false false high_low.py # plays the guessing game higher or lower # this should actually be something that is semi random like the # last digits of the time or something else, but that will have to # wait till a later chapter. (extra credit, modify it to be random # after the modules chapter) number = 7 guess = -1 print("guess the number!") while guess != number: guess = int(input("is it... ")) if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") sample run: guess the number! is it... 2 it's bigger... is it... 5 it's bigger... is it... 10 it's not so big. is it... 7 hooray! you guessed it right! even.py # asks for a number. # prints if it is even or odd number = float(input("tell me a number: ")) if number % 2 == 0: print(int(number), "is even.") elif number % 2 == 1: print(int(number), "is odd.") else: print(number, "is very strange.") sample runs: tell me a number: 3 3 is odd. tell me a number: 2 2 is even. tell me a number: 3.4895 3.4895 is very strange. average1.py # keeps asking for numbers until 0 is entered. # prints the average value. count = 0 sum = 0.0 number = 1 # set to something that will not exit the while loop immediately. print("enter 0 to exit the loop") while number != 0: number = float(input("enter a number: ")) if number != 0: count = count + 1 sum = sum + number if number == 0: print("the average was:", sum / count) sample runs sample runs: enter 0 to exit the loop enter a number: 3 enter a number: 5 enter a number: 0 the average was: 4.0 enter 0 to exit the loop enter a number: 1 enter a number: 4 enter a number: 3 enter a number: 0 the average was: 2.66666666667 average2.py # keeps asking for numbers until count numbers have been entered. # prints the average value. #notice that we use an integer to keep track of how many numbers, # but floating point numbers for the input of each number sum = 0.0 print("this program will take several numbers then average them") count = int(input("how many numbers would you like to average: ")) current_count = 0 while current_count < count: current_count = current_count + 1 print("number", current_count) number = float(input("enter a number: ")) sum = sum + number print("the average was:", sum / count) sample runs: this program will take several numbers then average them how many numbers would you like to average: 2 number 1 enter a number: 3 number 2 enter a number: 5 the average was: 4.0 this program will take several numbers then average them how many numbers would you like to average: 3 number 1 enter a number: 1 number 2 enter a number: 4 number 3 enter a number: 3 the average was: 2.66666666667 exercises write a program that asks the user their name, if they enter your name say "that is a nice name", if they enter "john cleese" or "michael palin", tell them how you feel about them ;), otherwise tell them "you have a nice name." solution name = input('your name: ') if name == 'bryn': print('that is a nice name.') elif name == 'john cleese': print('... some funny text.') elif name == 'michael palin': print('... some funny text.') else: print('you have a nice name.') modify the higher or lower program from this section to keep track of how many times the user has entered the wrong number. if it is more than 3 times, print "that must have been complicated." at the end, otherwise print "good job!" solution number = 7 guess = -1 count = 0 print("guess the number!") while guess != number: guess = int(input("is it... ")) count = count + 1 if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") if count > 3: print("that must have been complicated.") else: print("good job!") write a program that asks for two numbers. if the sum of the numbers is greater than 100, print "that is a big number." solution number1 = float(input('1st number: ')) number2 = float(input('2nd number: ')) if number1 + number2 > 100: print('that is a big number.') non-programmer's tutorial for python 3 ← count to 10 print version debugging → 7. debugging what is debugging? "as soon as we started programming, we found to our surprise that it wasn't as easy to get programs right as we had thought. debugging had to be discovered. i can remember the exact instant when i realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs." — maurice wilkes discovers debugging, 1949 by now if you have been messing around with the programs you have probably found that sometimes the program does something you didn't want it to do. this is fairly common. debugging is the process of figuring out what the computer is doing and then getting it to do what you want it to do. this can be tricky. i once spent nearly a week tracking down and fixing a bug that was caused by someone putting an x where a y should have been. this chapter will be more abstract than previous chapters. what should the program do? the first thing to do (this sounds obvious) is to figure out what the program should be doing if it is running correctly. come up with some test cases and see what happens. for example, let's say i have a program to compute the perimeter of a rectangle (the sum of the length of all the edges). i have the following test cases: height width perimeter 3 4 14 2 3 10 4 4 16 2 2 8 5 1 12 i now run my program on all of the test cases and see if the program does what i expect it to do. if it doesn't then i need to find out what the computer is doing. more commonly some of the test cases will work and some will not. if that is the case you should try and figure out what the working ones have in common. for example here is the output for a perimeter program (you get to see the code in a minute): height: 3 width: 4 perimeter = 15 height: 2 width: 3 perimeter = 11 height: 4 width: 4 perimeter = 16 height: 2 width: 2 perimeter = 8 height: 5 width: 1 perimeter = 8 notice that it didn't work for the first two inputs, it worked for the next two and it didn't work on the last one. try and figure out what is in common with the working ones. once you have some idea what the problem is finding the cause is easier. with your own programs you should try more test cases if you need them. what does the program do? the next thing to do is to look at the source code. one of the most important things to do while programming is reading source code. the primary way to do this is code walkthroughs. a code walkthrough starts at the first line, and works its way down until the program is done. while loops and if statements mean that some lines may never be run and some lines are run many times. at each line you figure out what python has done. lets start with the simple perimeter program. don't type it in, you are going to read it, not run it. the source code is: height = int(input("height: ")) width = int(input("width: ")) print("perimeter =", width + height + width + width) question: what is the first line python runs? answer: the first line is always run first. in this case it is: height = int(input("height: ")) what does that line do? prints height: , waits for the user to type a string in, and then converts the string to an integer variable height. what is the next line that runs? in general, it is the next line down which is: width = int(input("width: ")) what does that line do? prints width: , waits for the user to type a number in, and puts what the user types in the variable width. what is the next line that runs? when the next line is not indented more or less than the current line, it is the line right afterwards, so it is: print("perimeter = ", width + height + width + width) (it may also run a function in the current line, but that's a future chapter.) what does that line do? first it prints perimeter = , then it prints the sum of the values contained within the variables, width and height, from width + height + width + width. does width + height + width + width calculate the perimeter properly? let's see, perimeter of a rectangle is the bottom (width) plus the left side (height) plus the top (width) plus the right side (huh?). the last item should be the right side's length, or the height. do you understand why some of the times the perimeter was calculated "correctly"? it was calculated correctly when the width and the height were equal. the next program we will do a code walkthrough for is a program that is supposed to print out 5 dots on the screen. however, this is what the program is outputting: . . . . and here is the program: number = 5 while number > 1: print(".",end=" ") number = number - 1 print() this program will be more complex to walkthrough since it now has indented portions (or control structures). let us begin. what is the first line to be run? the first line of the file: number = 5 what does it do? puts the number 5 in the variable number. what is the next line? the next line is: while number > 1: what does it do? well, while statements in general look at their expression, and if it is true they do the next indented block of code, otherwise they skip the next indented block of code. so what does it do right now? if number > 1 is true then the next two lines will be run. so is number > 1? the last value put into number was 5 and 5 > 1 so yes. so what is the next line? since the while was true the next line is: print(".",end=" ") what does that line do? prints one dot and since the extra argument end=" " exists the next printed text will not be on a different screen line. what is the next line? number = number - 1 since that is following line and there are no indent changes. what does it do? it calculates number - 1, which is the current value of number (or 5) subtracts 1 from it, and makes that the new value of number. so basically it changes number's value from 5 to 4. what is the next line? well, the indent level decreases so we have to look at what type of control structure it is. it is a while loop, so we have to go back to the while clause which is while number > 1: what does it do? it looks at the value of number, which is 4, and compares it to 1 and since 4 > 1 the while loop continues. what is the next line? since the while loop was true, the next line is: print(".",end=" ") what does it do? it prints a second dot on the line, ending by a space. what is the next line? no indent change so it is: number = number - 1 and what does it do? it takes the current value of number (4), subtracts 1 from it, which gives it 3 and then finally makes 3 the new value of number. what is the next line? since there is an indent change caused by the end of the while loop, the next line is: while number > 1: what does it do? it compares the current value of number (3) to 1. 3 > 1 so the while loop continues. what is the next line? since the while loop condition was true the next line is: print(".",end=" ") and it does what? a third dot is printed on the line. what is the next line? it is: number = number - 1 what does it do? it takes the current value of number (3) subtracts from it 1 and makes the 2 the new value of number. what is the next line? back up to the start of the while loop: while number > 1: what does it do? it compares the current value of number (2) to 1. since 2 > 1 the while loop continues. what is the next line? since the while loop is continuing: print(".",end=" ") what does it do? it discovers the meaning of life, the universe and everything. i'm joking. (i had to make sure you were awake.) the line prints a fourth dot on the screen. what is the next line? it's: number = number - 1 what does it do? takes the current value of number (2) subtracts 1 and makes 1 the new value of number. what is the next line? back up to the while loop: while number > 1: what does the line do? it compares the current value of number (1) to 1. since 1 > 1 is false (one is not greater than one), the while loop exits. what is the next line? since the while loop condition was false the next line is the line after the while loop exits, or: print() what does that line do? makes the screen go to the next line. why doesn't the program print 5 dots? the loop exits 1 dot too soon. how can we fix that? make the loop exit 1 dot later. and how do we do that? there are several ways. one way would be to change the while loop to: while number > 0: another way would be to change the conditional to: number >= 1 there are a couple others. how do i fix my program? you need to figure out what the program is doing. you need to figure out what the program should do. figure out what the difference between the two is. debugging is a skill that has to be practiced to be learned. if you can't figure it out after an hour, take a break, talk to someone about the problem or contemplate the lint in your navel. come back in a while and you will probably have new ideas about the problem. good luck. non-programmer's tutorial for python 3 ← decisions print version defining functions → 8. defining functions creating functions to start off this chapter i am going to give you an example of what you could do but shouldn't (so don't type it in): a = 23 b = -23 if a < 0: a = -a if b < 0: b = -b if a == b: print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and 23 are equal. the program seems a little repetitive. programmers hate to repeat things -- that's what computers are for, after all! (note also that finding the absolute value changed the value of the variable, which is why it is printing out 23, and not -23 in the output.) fortunately python allows you to create functions to remove duplication. here is the rewritten example: a = 23 b = -23 def absolute_value(n): if n < 0: n = -n return n if absolute_value(a) == absolute_value(b): print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and -23 are equal. the key feature of this program is the def statement. def (short for define) starts a function definition. def is followed by the name of the function absolute_value. next comes a '(' followed by the parameter n (n is passed from the program into the function when the function is called). the statements after the ':' are executed when the function is used. the statements continue until either the indented statements end or a return is encountered. the return statement returns a value back to the place where the function was called. we already have encountered a function in our very first program, the print function. now we can make new functions. notice how the values of a and b are not changed. functions can be used to repeat tasks that don't return values. here are some examples: def hello(): print("hello") def area(width, height): return width * height def print_welcome(name): print("welcome", name) hello() hello() print_welcome("fred") w = 4 h = 5 print("width =", w, " height =", h, " area =", area(w, h)) with output being: hello hello welcome fred width = 4 height = 5 area = 20 that example shows some more stuff that you can do with functions. notice that you can use no arguments or two or more. notice also when a function doesn't need to send back a value, a return is optional. variables in functions when eliminating repeated code, you often have variables in the repeated code. in python, these are dealt with in a special way. so far all variables we have seen are global variables. functions have a special type of variable called local variables. these variables only exist while the function is running. when a local variable has the same name as another variable (such as a global variable), the local variable hides the other. sound confusing? well, these next examples (which are a bit contrived) should help clear things up. a = 4 def print_func(): a = 17 print("in print_func a =", a) print_func() print("a = ", a) when run, we will receive an output of: in print_func a = 17 a = 4 variable assignments inside a function do not override global variables, they exist only inside the function. even though a was assigned a new value inside the function, this newly assigned value was only relevant to print_func, when the function finishes running, and the a's values is printed again, we see the originally assigned values. here is another more complex example. a_var = 10 b_var = 15 e_var = 25 def a_func(a_var): print("in a_func a_var =", a_var) b_var = 100 + a_var d_var = 2 * a_var print("in a_func b_var =", b_var) print("in a_func d_var =", d_var) print("in a_func e_var =", e_var) return b_var + 10 c_var = a_func(b_var) print("a_var =", a_var) print("b_var =", b_var) print("c_var =", c_var) print("d_var =", d_var) output: in a_func a_var = 15 in a_func b_var = 115 in a_func d_var = 30 in a_func e_var = 25 a_var = 10 b_var = 15 c_var = 125 d_var = traceback (most recent call last): file "c:\def2.py", line 19, in <module> print("d_var = ", d_var) nameerror: name 'd_var' is not defined in this example the variables a_var, b_var, and d_var are all local variables when they are inside the function a_func. after the statement return b_var + 10 is run, they all cease to exist. the variable a_var is automatically a local variable since it is a parameter name. the variables b_var and d_var are local variables since they appear on the left of an equals sign in the function in the statements b_var = 100 + a_var and d_var = 2 * a_var . inside of the function a_var has no value assigned to it. when the function is called with c_var = a_func(b_var), 15 is assigned to a_var since at that point in time b_var is 15, making the call to the function a_func(15). this ends up setting a_var to 15 when it is inside of a_func. as you can see, once the function finishes running, the local variables a_var and b_var that had hidden the global variables of the same name are gone. then the statement print("a_var = ", a_var) prints the value 10 rather than the value 15 since the local variable that hid the global variable is gone. another thing to notice is the nameerror that happens at the end. this appears since the variable d_var no longer exists since a_func finished. all the local variables are deleted when the function exits. if you want to get something from a function, then you will have to use return something. one last thing to notice is that the value of e_var remains unchanged inside a_func since it is not a parameter and it never appears on the left of an equals sign inside of the function a_func. when a global variable is accessed inside a function it is the global variable from the outside. functions allow local variables that exist only inside the function and can hide other variables that are outside the function. examples temperature2.py #! /usr/bin/python #-*-coding: utf-8 -*- # converts temperature to fahrenheit or celsius def print_options(): print("options:") print(" 'p' print options") print(" 'c' convert from celsius") print(" 'f' convert from fahrenheit") print(" 'q' quit the program") def celsius_to_fahrenheit(c_temp): return 9.0 / 5.0 * c_temp + 32 def fahrenheit_to_celsius(f_temp): return (f_temp - 32.0) * 5.0 / 9.0 choice = "p" while choice != "q": if choice == "c": c_temp = float(input("celsius temperature: ")) print("fahrenheit:", celsius_to_fahrenheit(c_temp)) choice = input("option: ") elif choice == "f": f_temp = float(input("fahrenheit temperature: ")) print("celsius:", fahrenheit_to_celsius(f_temp)) choice = input("option: ") else: choice = "p" #alternatively choice != "q": so that print #when anything unexpected inputed print_options() choice = input("option: ") sample run: options: 'p' print options 'c' convert from celsius 'f' convert from fahrenheit 'q' quit the program option: c celsius temperature: 30 fahrenheit: 86.0 option: f fahrenheit temperature: 60 celsius: 15.5555555556 option: q area2.py #! /usr/bin/python #-*-coding: utf-8 -*- # calculates a given rectangle area def hello(): print('hello!') def area(width, height): return width * height def print_welcome(name): print('welcome,', name) def positive_input(prompt): number = float(input(prompt)) while number <= 0: print('must be a positive number') number = float(input(prompt)) return number name = input('your name: ') hello() print_welcome(name) print() print('to find the area of a rectangle,') print('enter the width and height below.') print() w = positive_input('width: ') h = positive_input('height: ') print('width =', w, ' height =', h, ' so area =', area(w, h)) sample run: your name: josh hello! welcome, josh to find the area of a rectangle, enter the width and height below. width: -4 must be a positive number width: 4 height: 3 width = 4 height = 3 so area = 12 exercises rewrite the area2.py program from the examples above to have a separate function for the area of a square, the area of a rectangle, and the area of a circle (3.14 * radius**2). this program should include a menu interface. solution def square(l): return l * l def rectangle(width , height): return width * height def circle(radius): return 3.14159 * radius ** 2 def options(): print() print("options:") print("s = calculate the area of a square.") print("c = calculate the area of a circle.") print("r = calculate the area of a rectangle.") print("q = quit") print() print("this program will calculate the area of a square, circle or rectangle.") choice = "x" options() while choice != "q": choice = input("please enter your choice: ") if choice == "s": l = float(input("length of square side: ")) print("the area of this square is", square(l)) options() elif choice == "c": radius = float(input("radius of the circle: ")) print("the area of the circle is", circle(radius)) options() elif choice == "r": width = float(input("width of the rectangle: ")) height = float(input("height of the rectangle: ")) print("the area of the rectangle is", rectangle(width, height)) options() elif choice == "q": print(" ",end="") else: print("unrecognized option.") options() non-programmer's tutorial for python 3 ← debugging print version advanced functions example → 9. advanced functions example some people find this section useful, and some find it confusing. if you find it confusing you can skip it. now we will do a walk through for the following program: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value result = mult(3, 2) print("3 * 2 = ", result) basically this program creates a positive integer multiplication function (that is far slower than the built in multiplication function) and then demonstrates this function with a use of the function. this program demonstrates the use of recursion, that is a form of iteration (repetition) in which there is a function that repeatedly calls itself until an exit condition is satisfied. it uses repeated additions to give the same result as mutiplication: e.g. 3 + 3 (addition) gives the same result as 3 * 2 (multiplication). question: what is the first thing the program does? answer: the first thing done is the function mult is defined with the lines: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value this creates a function that takes two parameters and returns a value when it is done. later this function can be run. what happens next? the next line after the function, result = mult(3, 2) is run. what does this line do? this line will assign the return value of mult(3, 2) to the variable result. and what does mult(3, 2) return? we need to do a walkthrough of the mult function to find out. what happens next? the variable a gets the value 3 assigned to it and the variable b gets the value 2 assigned to it. and then? the line if b == 0: is run. since b has the value 2 this is false so the line return 0 is skipped. and what then? the line rest = mult(a, b - 1) is run. this line sets the local variable rest to the value of mult(a, b - 1). the value of a is 3 and the value of b is 2 so the function call is mult(3,1) so what is the value of mult(3, 1) ? we will need to run the function mult with the parameters 3 and 1. so what happens next? the local variables in the new run of the function are set so that a has the value 3 and b has the value 1. since these are local values these do not affect the previous values of a and b. and then? since b has the value 1 the if statement is false, so the next line becomes rest = mult(a, b - 1). what does this line do? this line will assign the value of mult(3, 0) to rest. so what is that value? we will have to run the function one more time to find that out. this time a has the value 3 and b has the value 0. so what happens next? the first line in the function to run is if b == 0:. b has the value 0 so the next line to run is return 0 and what does the line return 0 do? this line returns the value 0 out of the function. so? so now we know that mult(3, 0) has the value 0. now we know what the line rest = mult(a, b - 1) did since we have run the function mult with the parameters 3 and 0. we have finished running mult(3, 0) and are now back to running mult(3, 1). the variable rest gets assigned the value 0. what line is run next? the line value = a + rest is run next. in this run of the function, a = 3 and rest = 0 so now value = 3. what happens next? the line return value is run. this returns 3 from the function. this also exits from the run of the function mult(3, 1). after return is called, we go back to running mult(3, 2). where were we in mult(3, 2)? we had the variables a = 3 and b = 2 and were examining the line rest = mult(a, b - 1). so what happens now? the variable rest get 3 assigned to it. the next line value = a + rest sets value to 3 + 3 or 6. so now what happens? the next line runs, this returns 6 from the function. we are now back to running the line result = mult(3, 2) which can now assign the value 6 to the variable result. what happens next? the next line after the function, print("3 * 2 = ", result) is run. and what does this do? it prints 3 * 2 = and the value of result which is 6. the complete line printed is 3 * 2 = 6. what is happening overall? basically we used two facts to calculate the multiple of the two numbers. the first is that any number times 0 is 0 (x * 0 = 0). the second is that a number times another number is equal to the first number plus the first number times one less than the second number (x * y = x + x * (y - 1)). so what happens is 3 * 2 is first converted into 3 + 3 * 1. then 3 * 1 is converted into 3 + 3 * 0. then we know that any number times 0 is 0 so 3 * 0 is 0. then we can calculate that 3 + 3 * 0 is 3 + 0 which is 3. now we know what 3 * 1 is so we can calculate that 3 + 3 * 1 is 3 + 3 which is 6. this is how the whole thing works: mult(3, 2) 3 + mult(3, 1) 3 + 3 + mult(3, 0) 3 + 3 + 0 3 + 3 6 recursion programming constructs solving a problem by solving a smaller version of the same problem are called recursive. in the examples in this chapter, recursion is realized by defining a function calling itself. this facilitates implementing solutions to programming tasks as it may be sufficient to consider the next step of a problem instead of the whole problem at once. it is also useful as it allows to express some mathematical concepts with straightforward, easy to read code. any problem that can be solved with recursion could be re-implemented with loops. using the latter usually results in better performance. however equivalent implementations using loops are usually harder to get done correctly. probably the most intuitive definition of recursion is: recursion if you still don't get it, see recursion. try walking through the factorial example if the multiplication example did not make sense. examples factorial.py #defines a function that calculates the factorial def factorial(n): if n == 0: return 1 if n<0: return "error, negative numbers do not have factorial values!!" return n * factorial(n - 1) print("2! =", factorial(2)) print("3! =", factorial(3)) print("4! =", factorial(4)) print("5! =", factorial(5)) print("-3! =", factorial(-3)) output: 2! = 2 3! = 6 4! = 24 5! = 120 -3! = error, negative values do not have factorial values!! countdown.py def count_down(n): print(n) if n > 0: return count_down(n-1) count_down(5) output: 5 4 3 2 1 0 non-programmer's tutorial for python 3 ← defining functions print version lists → 10. lists variables with more than one value you have already seen ordinary variables that store a single value. however other variable types can hold more than one value. these are called containers because they can contain more than one object. the simplest type is called a list. here is an example of a list being used: which_one = int(input("what month (1-12)? ")) months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'] if 1 <= which_one <= 12: print("the month is", months[which_one - 1]) and an output example: what month (1-12)? 3 the month is march in this example the months is a list. months is defined with the lines months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', and 'august', 'september', 'october', 'november', 'december'] (note that a \ could also be used to split a long line, but that is not necessary in this case because python is intelligent enough to recognize that everything within brackets belongs together). the [ and ] start and end the list with commas (,) separating the list items. the list is used in months[which_one - 1]. a list consists of items that are numbered starting at 0. in other words if you wanted january you would use months[0]. give a list a number and it will return the value that is stored at that location. the statement if 1 <= which_one <= 12: will only be true if which_one is between one and twelve inclusive (in other words it is what you would expect if you have seen that in algebra). lists can be thought of as a series of boxes. each box has a different value. for example, the boxes created by demolist = ['life', 42, 'the universe', 6, 'and', 9] would look like this: box number 0 1 2 3 4 5 demolist "life" 42 "the universe" 6 "and" 9 each box is referenced by its number so the statement demolist[0] would get 'life', demolist[1] would get 42 and so on up to demolist[5] getting 9. more features of lists the next example is just to show a lot of other stuff lists can do (for once i don't expect you to type it in, but you should probably play around with lists in interactive mode until you are comfortable with them.). here goes: demolist = ["life", 42, "the universe", 6, "and", 9] print("demolist = ",demolist) demolist.append("everything") print("after 'everything' was appended demolist is now:") print(demolist) print("len(demolist) =", len(demolist)) print("demolist.index(42) =", demolist.index(42)) print("demolist[1] =", demolist[1]) # next we will loop through the list for c in range(len(demolist)): print("demolist[", c, "] =", demolist[c]) del demolist[2] print("after 'the universe' was removed demolist is now:") print(demolist) if "life" in demolist: print("'life' was found in demolist") else: print("'life' was not found in demolist") if "amoeba" in demolist: print("'amoeba' was found in demolist") if "amoeba" not in demolist: print("'amoeba' was not found in demolist") another_list = [42,7,0,123] another_list.sort() print("the sorted another_list is", another_list) the output is: demolist = ['life', 42, 'the universe', 6, 'and', 9] after 'everything' was appended demolist is now: ['life', 42, 'the universe', 6, 'and', 9, 'everything'] len(demolist) = 7 demolist.index(42) = 1 demolist[1] = 42 demolist[ 0 ] = life demolist[ 1 ] = 42 demolist[ 2 ] = the universe demolist[ 3 ] = 6 demolist[ 4 ] = and demolist[ 5 ] = 9 demolist[ 6 ] = everything after 'the universe' was removed demolist is now: ['life', 42, 6, 'and', 9, 'everything'] 'life' was found in demolist 'amoeba' was not found in demolist the sorted another_list is [0, 7, 42, 123] this example uses a whole bunch of new functions. notice that you can just print a whole list. next the append function is used to add a new item to the end of the list. len returns how many items are in a list. the valid indexes (as in numbers that can be used inside of the []) of a list range from 0 to len - 1. the index function tells where the first location of an item is located in a list. notice how demolist.index(42) returns 1, and when demolist[1] is run it returns 42. to get help on all the functions a list provides for you, type help(list) in the interactive python interpreter. the line # next we will loop through the list is a just a reminder to the programmer (also called a comment). python ignores everything that is written after a # on the current line. next the lines: for c in range(len(demolist)): print('demolist[', c, '] =', demolist[c]) create a variable c, which starts at 0 and is incremented until it reaches the last index of the list. meanwhile the print statement prints out each element of the list. a much better way to do the above is: for c, x in enumerate(demolist): print("demolist[", c, "] =", x) the del command can be used to remove a given element in a list. the next few lines use the in operator to test if an element is in or is not in a list. the sort function sorts the list. this is useful if you need a list in order from smallest number to largest or alphabetical. note that this rearranges the list. in summary, for a list, the following operations occur: example explanation demolist[2] accesses the element at index 2 demolist[2] = 3 sets the element at index 2 to be 3 del demolist[2] removes the element at index 2 len(demolist) returns the length of demolist "value" in demolist is true if "value" is an element in demolist "value" not in demolist is true if "value" is not an element in demolist another_list.sort() sorts another_list. note that the list must be all numbers or all strings to be sorted. demolist.index("value") returns the index of the first place that "value" occurs demolist.append("value") adds an element "value" at the end of the list demolist.remove("value") removes the first occurrence of value from demolist (same as del demolist[demolist.index("value")]) this next example uses these features in a more useful way: menu_item = 0 namelist = [] while menu_item != 9: print("--------------------") print("1. print the list") print("2. add a name to the list") print("3. remove a name from the list") print("4. change an item in the list") print("9. quit") menu_item = int(input("pick an item from the menu: ")) if menu_item == 1: current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") elif menu_item == 2: name = input("type in a name to add: ") namelist.append(name) elif menu_item == 3: del_name = input("what name would you like to remove: ") if del_name in namelist: # namelist.remove(del_name) would work just as fine item_number = namelist.index(del_name) del namelist[item_number] # the code above only removes the first occurrence of # the name. the code below from gerald removes all. # while del_name in namelist: # item_number = namelist.index(del_name) # del namelist[item_number] else: print(del_name, "was not found") elif menu_item == 4: old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") print("goodbye") and here is part of the output: -------------------- 1. print the list 2. add a name to the list 3. remove a name from the list 4. change an item in the list 9. quit pick an item from the menu: 2 type in a name to add: jack pick an item from the menu: 2 type in a name to add: jill pick an item from the menu: 1 0 . jack 1 . jill pick an item from the menu: 3 what name would you like to remove: jack pick an item from the menu: 4 what name would you like to change: jill what is the new name: jill peters pick an item from the menu: 1 0 . jill peters pick an item from the menu: 9 goodbye that was a long program. let's take a look at the source code. the line namelist = [] makes the variable namelist a list with no items (or elements). the next important line is while menu_item != 9:. this line starts a loop that allows the menu system for this program. the next few lines display a menu and decide which part of the program to run. the section current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") goes through the list and prints each name. len(namelist) tells how many items are in the list. if len returns 0, then the list is empty. then, a few lines later, the statement namelist.append(name) appears. it uses the append function to add an item to the end of the list. jump down another two lines, and notice this section of code: item_number = namelist.index(del_name) del namelist[item_number] here the index function is used to find the index value that will be used later to remove the item. del namelist[item_number] is used to remove an element of the list. the next section old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") uses index to find the item_number and then puts new_name where the old_name was. congratulations, with lists under your belt, you now know enough of the language that you could do any computations that a computer can do (this is technically known as turing-completeness). of course, there are still many features that are used to make your life easier. examples test.py ## this program runs a test of knowledge # first get the test questions # later this will be modified to use file io. def get_questions(): # notice how the data is stored as a list of lists return [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list # this function takes a list with two elements, a question and an answer. question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the tester's answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question #note that this is extracting a question and answer list from the list of lists. if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions),\ "% right out of", len(questions)) # now let's get the questions from the get_questions function, and # send the returned list of lists as an argument to the run_test function. run_test(get_questions()) the values true and false point to 1 and 0, respectively. they are often used in sanity checks, loop conditions etc. you will learn more about this a little bit later (chapter boolean expressions). please note that get_questions() is essentially a list because even though it's technically a function, returning a list of lists is the only thing it does. sample output: what color is the daytime sky on a clear day? green incorrect, correct was: blue what is the answer to life, the universe and everything? 42 correct what is a three letter word for mouse trap? cat correct you got 66 % right out of 3 exercises expand the test.py program so it has a menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". solution expand the test.py program so it has menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". ## this program runs a test of knowledge questions = [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"], ["what noise does a truly advanced machine make?", "ping"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the testers answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions), "% right out of", len(questions)) #showing a list of questions and answers def showquestions(): q = 0 while q < len(questions): a = 0 print("q:" , questions[q][a]) a = 1 print("a:" , questions[q][a]) q = q + 1 # now let's define the menu function def menu(): print("-----------------") print("menu:") print("1 - take the test") print("2 - view a list of questions and answers") print("3 - view the menu") print("5 - quit") print("-----------------") choice = "3" while choice != "5": if choice == "1": run_test(questions) elif choice == "2": showquestions() elif choice == "3": menu() print() choice = input("choose your option from the menu above: ") non-programmer's tutorial for python 3 ← advanced functions example print version for loops → 11. for loops and here is the new typing exercise for this chapter: onetoten = range(1, 11) for count in onetoten: print(count) and the ever-present output: 1 2 3 4 5 6 7 8 9 10 the output looks awfully familiar but the program code looks different. the first line uses the range function. the range function uses two arguments like this range(start, finish). start is the first number that is produced. finish is one larger than the last number. note that this program could have been done in a shorter way: for count in range(1, 11): print(count) the range function returns an iterable. this can be converted into a list with the list function. which will then be the dominant number. here are some examples to show what happens with the range command: >>> range(1, 10) range(1, 10) >>> list(range(1, 10)) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(-32, -20)) [-32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21] >>> list(range(5,21)) [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] >>> list(range(5)) [0, 1, 2, 3, 4] >>> list(range(21, 5)) [] the next line for count in onetoten: uses the for control structure. a for control structure looks like for variable in list:. list is gone through starting with the first element of the list and going to the last. as for goes through each element in a list it puts each into variable. that allows variable to be used in each successive time the for loop is run through. here is another example (you don't have to type this) to demonstrate: demolist = ['life', 42, 'the universe', 6, 'and', 7, 'everything'] for item in demolist: print("the current item is:",item) the output is: the current item is: life the current item is: 42 the current item is: the universe the current item is: 6 the current item is: and the current item is: 7 the current item is: everything notice how the for loop goes through and sets item to each element in the list. so, what is for good for? the first use is to go through all the elements of a list and do something with each of them. here's a quick way to add up all the elements: list = [2, 4, 6, 8] sum = 0 for num in list: sum = sum + num print("the sum is:", sum) with the output simply being: the sum is: 20 or you could write a program to find out if there are any duplicates in a list like this program does: list = [4, 5, 7, 8, 9, 1, 0, 7, 10] list.sort() prev = none for item in list: if prev == item: print("duplicate of", prev, "found") prev = item and for good measure: duplicate of 7 found okay, so how does it work? here is a special debugging version to help you understand (you don't need to type this in): l = [4, 5, 7, 8, 9, 1, 0, 7, 10] print("l = [4, 5, 7, 8, 9, 1, 0, 7, 10]", "\t\tl:", l) l.sort() print("l.sort()", "\t\tl:", l) prev = l[0] print("prev = l[0]", "\t\tprev:", prev) del l[0] print("del l[0]", "\t\tl:", l) for item in l: if prev == item: print("duplicate of", prev, "found") print("if prev == item:", "\t\tprev:", prev, "\titem:", item) prev = item print("prev = item", "\t\tprev:", prev, "\titem:", item) with the output being: l = [4, 5, 7, 8, 9, 1, 0, 7, 10] l: [4, 5, 7, 8, 9, 1, 0, 7, 10] l.sort() l: [0, 1, 4, 5, 7, 7, 8, 9, 10] prev = l[0] prev: 0 del l[0] l: [1, 4, 5, 7, 7, 8, 9, 10] if prev == item: prev: 0 item: 1 prev = item prev: 1 item: 1 if prev == item: prev: 1 item: 4 prev = item prev: 4 item: 4 if prev == item: prev: 4 item: 5 prev = item prev: 5 item: 5 if prev == item: prev: 5 item: 7 prev = item prev: 7 item: 7 duplicate of 7 found if prev == item: prev: 7 item: 7 prev = item prev: 7 item: 7 if prev == item: prev: 7 item: 8 prev = item prev: 8 item: 8 if prev == item: prev: 8 item: 9 prev = item prev: 9 item: 9 if prev == item: prev: 9 item: 10 prev = item prev: 10 item: 10 the reason i put so many print statements in the code was so that you can see what is happening in each line. (by the way, if you can't figure out why a program is not working, try putting in lots of print statements in places where you want to know what is happening.) first the program starts with a boring old list. next the program sorts the list. this is so that any duplicates get put next to each other. the program then initializes a prev(ious) variable. next the first element of the list is deleted so that the first item is not incorrectly thought to be a duplicate. next a for loop is gone into. each item of the list is checked to see if it is the same as the previous. if it is a duplicate was found. the value of prev is then changed so that the next time the for loop is run through prev is the previous item to the current. sure enough, the 7 is found to be a duplicate. (notice how \t is used to print a tab.) the other way to use for loops is to do something a certain number of times. here is some code to print out the first 9 numbers of the fibonacci series: a = 1 b = 1 for c in range(1, 10): print(a, end=" ") n = a + b a = b b = n with the surprising output: 1 1 2 3 5 8 13 21 34 everything that can be done with for loops can also be done with while loops but for loops give an easy way to go through all the elements in a list or to do something a certain number of times. non-programmer's tutorial for python 3 ← lists print version boolean expressions → 12. boolean expressions here is a little example of boolean expressions (you don't have to type it in): a = 6 b = 7 c = 42 print(1, a == 6) print(2, a == 7) print(3, a == 6 and b == 7) print(4, a == 7 and b == 7) print(5, not a == 7 and b == 7) print(6, a == 7 or b == 7) print(7, a == 7 or b == 6) print(8, not (a == 7 and b == 6)) print(9, not a == 7 and b == 6) with the output being: 1 true 2 false 3 true 4 false 5 true 6 true 7 false 8 true 9 false what is going on? the program consists of a bunch of funny looking print statements. each print statement prints a number and an expression. the number is to help keep track of which statement i am dealing with. notice how each expression ends up being either false or true. in python false can also be written as 0 and true as 1. the lines: print(1, a == 6) print(2, a == 7) print out a true and a false respectively just as expected since the first is true and the second is false. the third print, print(3, a == 6 and b == 7), is a little different. the operator and means if both the statement before and the statement after are true then the whole expression is true otherwise the whole expression is false. the next line, print(4, a == 7 and b == 7), shows how if part of an and expression is false, the whole thing is false. the behavior of and can be summarized as follows: expression result true and true true true and false false false and true false false and false false notice that if the first expression is false python does not check the second expression since it knows the whole expression is false. try running false and print("hi") and compare this to running true and print("hi") the technical term for this is short-circuit evaluation the next line, print(5, not a == 7 and b == 7), uses the not operator. not just gives the opposite of the expression. (the expression could be rewritten as print(5, a != 7 and b == 7)). here is the table: expression result not true false not false true the two following lines, print(6, a == 7 or b == 7) and print(7, a == 7 or b == 6), use the or operator. the or operator returns true if the first expression is true, or if the second expression is true or both are true. if neither are true it returns false. here's the table: expression result true or true true true or false true false or true true false or false false notice that if the first expression is true python doesn't check the second expression since it knows the whole expression is true. this works since or is true if at least one half of the expression is true. the first part is true so the second part could be either false or true, but the whole expression is still true. the next two lines, print(8, not (a == 7 and b == 6)) and print(9, not a == 7 and b == 6), show that parentheses can be used to group expressions and force one part to be evaluated first. notice that the parentheses changed the expression from false to true. this occurred since the parentheses forced the not to apply to the whole expression instead of just the a == 7 portion. here is an example of using a boolean expression: list = ["life", "the universe", "everything", "jack", "jill", "life", "jill"] # make a copy of the list. see the more on lists chapter to explain what [:] means. copy = list[:] # sort the copy copy.sort() prev = copy[0] del copy[0] count = 0 # go through the list searching for a match while count < len(copy) and copy[count] != prev: prev = copy[count] count = count + 1 # if a match was not found then count can't be < len # since the while loop continues while count is < len # and no match is found if count < len(copy): print("first match:", prev) and here is the output: first match: jill this program works by continuing to check for match while count < len(copy) and copy[count] is not equal to prev. when either count is greater than the last index of copy or a match has been found the and is no longer true so the loop exits. the if simply checks to make sure that the while exited because a match was found. the other "trick" of and is used in this example. if you look at the table for and notice that the third entry is "false and false". if count >= len(copy) (in other words count < len(copy) is false) then copy[count] is never looked at. this is because python knows that if the first is false then they can't both be true. this is known as a short circuit and is useful if the second half of the and will cause an error if something is wrong. i used the first expression (count < len(copy)) to check and see if count was a valid index for copy. (if you don't believe me remove the matches "jill" and "life", check that it still works and then reverse the order of count < len(copy) and copy[count] != prev to copy[count] != prev and count < len(copy).) boolean expressions can be used when you need to check two or more different things at once. a note on boolean operators a common mistake for people new to programming is a misunderstanding of the way that boolean operators works, which stems from the way the python interpreter reads these expressions. for example, after initially learning about "and " and "or" statements, one might assume that the expression x == ('a' or 'b') would check to see if the variable x was equivalent to one of the strings 'a' or 'b'. this is not so. to see what i'm talking about, start an interactive session with the interpreter and enter the following expressions: >>> 'a' == ('a' or 'b') >>> 'b' == ('a' or 'b') >>> 'a' == ('a' and 'b') >>> 'b' == ('a' and 'b') and this will be the unintuitive result: >>> 'a' == ('a' or 'b') true >>> 'b' == ('a' or 'b') false >>> 'a' == ('a' and 'b') false >>> 'b' == ('a' and 'b') true at this point, the and and or operators seem to be broken. it doesn't make sense that, for the first two expressions, 'a' is equivalent to 'a' or 'b' while 'b' is not. furthermore, it doesn't make any sense that 'b' is equivalent to 'a' and 'b'. after examining what the interpreter does with boolean operators, these results do in fact exactly what you are asking of them, it's just not the same as what you think you are asking. when the python interpreter looks at an or expression, it takes the first statement and checks to see if it is true. if the first statement is true, then python returns that object's value without checking the second statement. this is because for an or expression, the whole thing is true if one of the values is true; the program does not need to bother with the second statement. on the other hand, if the first value is evaluated as false python checks the second half and returns that value. that second half determines the truth value of the whole expression since the first half was false. this "laziness" on the part of the interpreter is called "short circuiting" and is a common way of evaluating boolean expressions in many programming languages. similarly, for an and expression, python uses a short circuit technique to speed truth value evaluation. if the first statement is false then the whole thing must be false, so it returns that value. otherwise if the first value is true it checks the second and returns that value. one thing to note at this point is that the boolean expression returns a value indicating true or false, but that python considers a number of different things to have a truth value assigned to them. to check the truth value of any given object x, you can use the function bool(x) to see its truth value. below is a table with examples of the truth values of various objects: true false true false 1 0 numbers other than zero the string 'none' nonempty strings empty strings nonempty lists empty lists nonempty dictionaries empty dictionaries now it is possible to understand the perplexing results we were getting when we tested those boolean expressions before. let's take a look at what the interpreter "sees" as it goes through that code: first case: >>> 'a' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'a' == 'a' # the string 'a' is equivalent to the string 'a', so expression is true true second case: >>> 'b' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'b' == 'a' # the string 'b' is not equivalent to the string 'a', so expression is false false third case: >>> 'a' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'a' == 'b' # the string 'a' is not equivalent to the string 'b', so expression is false false fourth case: >>> 'b' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'b' == 'b' # the string 'b' is equivalent to the string 'b', so expression is true true so python was really doing its job when it gave those apparently bogus results. as mentioned previously, the important thing is to recognize what value your boolean expression will return when it is evaluated, because it isn't always obvious. going back to those initial expressions, this is how you would write them out so they behaved in a way that you want: >>> 'a' == 'a' or 'a' == 'b' true >>> 'b' == 'a' or 'b' == 'b' true >>> 'a' == 'a' and 'a' == 'b' false >>> 'b' == 'a' and 'b' == 'b' false when these comparisons are evaluated they return truth values in terms of true or false, not strings, so we get the proper results. examples password1.py ## this program asks a user for a name and a password. # it then checks them to make sure that the user is allowed in. name = input("what is your name? ") password = input("what is the password? ") if name == "josh" and password == "friday": print("welcome josh") elif name == "fred" and password == "rock": print("welcome fred") else: print("i don't know you.") sample runs what is your name? josh what is the password? friday welcome josh what is your name? bill what is the password? money i don't know you. exercises write a program that has a user guess your name, but they only get 3 chances to do so until the program quits. solution print("try to guess my name!") count = 1 name = "guilherme" guess = input("what is my name? ") while count < 3 and guess.lower() != name: # .lower allows things like guilherme to still match print("you are wrong!") guess = input("what is my name? ") count = count + 1 if guess.lower() != name: print("you are wrong!") # this message isn't printed in the third chance, so we print it now print("you ran out of chances.") else: print("yes! my name is", name + "!") non-programmer's tutorial for python 3 ← for loops print version dictionaries → 13. dictionaries this chapter is about dictionaries. dictionaries have keys and values. the keys are used to find the values. here is an example of a dictionary in use: def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() and here is my output: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. quit type in a number (1-5): 2 add name and number name: joe number: 545-4464 type in a number (1-5): 2 add name and number name: jill number: 979-4654 type in a number (1-5): 2 add name and number name: fred number: 132-9874 type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 name: fred number: 132-9874 type in a number (1-5): 4 lookup number name: joe the number is 545-4464 type in a number (1-5): 3 remove name and number name: fred type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 type in a number (1-5): 5 this program is similar to the name list earlier in the chapter on lists. here's how the program works. first the function print_menu is defined. print_menu just prints a menu that is later used twice in the program. next comes the funny looking line numbers = {}. all that this line does is to tell python that numbers is a dictionary. the next few lines just make the menu work. the lines for x in numbers.keys(): print("name:", x, "\tnumber:", numbers[x]) go through the dictionary and print all the information. the function numbers.keys() returns a list that is then used by the for loop. the list returned by keys() is not in any particular order so if you want it in alphabetic order it must be sorted. similar to lists the statement numbers[x] is used to access a specific member of the dictionary. of course in this case x is a string. next the line numbers[name] = phone adds a name and phone number to the dictionary. if name had already been in the dictionary phone would replace whatever was there before. next the lines if name in numbers: del numbers[name] see if a name is in the dictionary and remove it if it is. the operator name in numbers returns true if name is in numbers but otherwise returns false. the line del numbers[name] removes the key name and the value associated with that key. the lines if name in numbers: print("the number is", numbers[name]) check to see if the dictionary has a certain key and if it does prints out the number associated with it. lastly if the menu choice is invalid it reprints the menu for your viewing pleasure. a recap: dictionaries have keys and values. keys can be strings or numbers. keys point to values. values can be any type of variable (including lists or even dictionaries (those dictionaries or lists of course can contain dictionaries or lists themselves (scary right? :-) ))). here is an example of using a list in a dictionary: max_points = [25, 25, 50, 25, 100] assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = {'#max': max_points} def print_menu(): print("1. add student") print("2. remove student") print("3. print grades") print("4. record grade") print("5. print menu") print("6. exit") def print_all_grades(): print('\t', end=' ') for i in range(len(assignments)): print(assignments[i], '\t', end=' ') print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) def print_grades(grades): for i in range(len(grades)): print(grades[i], '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 6: print() menu_choice = int(input("menu choice (1-6): ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(max_points) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: print_all_grades() elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i in range(len(assignments)): print(i + 1, assignments[i], '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 #same as which = which - 1 if 0 <= which < len(grades): grade = int(input("grade: ")) grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice != 6: print_menu() and here is a sample output: 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 menu choice (1-6): 5 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 1 student to add: bill menu choice (1-6): 4 record grade student: bill type in the number of the grade to record type a 0 (zero) to exit 1 hw ch 1 2 hw ch 2 3 quiz 4 hw ch 3 5 test 0 0 0 0 0 change which grade: 1 grade: 25 change which grade: 2 grade: 24 change which grade: 3 grade: 45 change which grade: 4 grade: 23 change which grade: 5 grade: 95 change which grade: 0 menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 bill 25 24 45 23 95 menu choice (1-6): 6 heres how the program works. basically the variable students is a dictionary with the keys being the name of the students and the values being their grades. the first two lines just create two lists. the next line students = {'#max': max_points} creates a new dictionary with the key {#max} and the value is set to be [25, 25, 50, 25, 100] (since thats what max_points was when the assignment is made) (i use the key #max since # is sorted ahead of any alphabetic characters). next print_menu is defined. next the print_all_grades function is defined in the lines: def print_all_grades(): print('\t',end=" ") for i in range(len(assignments)): print(assignments[i], '\t',end=" ") print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t',end=' ') grades = students[x] print_grades(grades) notice how first the keys are gotten out of the students dictionary with the keys function in the line keys = list(students.keys()). keys is an iterable, and it is converted to list so all the functions for lists can be used on it. next the keys are sorted in the line keys.sort(). for is used to go through all the keys. the grades are stored as a list inside the dictionary so the assignment grades = students[x] gives grades the list that is stored at the key x. the function print_grades just prints a list and is defined a few lines later. the later lines of the program implement the various options of the menu. the line students[name] = [0] * len(max_points) adds a student to the key of their name. the notation [0] * len(max_points) just creates a list of 0's that is the same length as the max_points list. the remove student entry just deletes a student similar to the telephone book example. the record grades choice is a little more complex. the grades are retrieved in the line grades = students[name] gets a reference to the grades of the student name. a grade is then recorded in the line grades[which] = grade. you may notice that grades is never put back into the students dictionary (as in no students[name] = grades). the reason for the missing statement is that grades is actually another name for students[name] and so changing grades changes student[name]. dictionaries provide an easy way to link keys to values. this can be used to easily keep track of data that is attached to various keys. non-programmer's tutorial for python 3 ← boolean expressions print version using modules → 14. using modules here's this chapter's typing exercise (name it cal.py (import actually looks for a file named calendar.py and reads it in. if the file is named calendar.py and it sees a "import calendar" it tries to read in itself which works poorly at best.)): import calendar year = int(input("type in the year number: ")) calendar.prcal(year) and here is part of the output i got: type in the year number: 2001 2001 january february march mo tu we th fr sa su mo tu we th fr sa su mo tu we th fr sa su 1 2 3 4 5 6 7 1 2 3 4 1 2 3 4 8 9 10 11 12 13 14 5 6 7 8 9 10 11 5 6 7 8 9 10 11 15 16 17 18 19 20 21 12 13 14 15 16 17 18 12 13 14 15 16 17 18 22 23 24 25 26 27 28 19 20 21 22 23 24 25 19 20 21 22 23 24 25 29 30 31 26 27 28 26 27 28 29 30 31 (i skipped some of the output, but i think you get the idea.) so what does the program do? the first line import calendar uses a new command import. the command import loads a module (in this case the calendar module). to see the commands available in the standard modules either look in the library reference for python (if you downloaded it) or go to http://docs.python.org/3/library/. if you look at the documentation for the calendar module, it lists a function called prcal that prints a calendar for a year. the line calendar.prcal(year) uses this function. in summary to use a module import it and then use module_name.function for functions in the module. another way to write the program is: from calendar import prcal year = int(input("type in the year number: ")) prcal(year) this version imports a specific function from a module. here is another program that uses the python library (name it something like clock.py) (press ctrl and the 'c' key at the same time to terminate the program): from time import time, ctime prev_time = "" while true: the_time = ctime(time()) if prev_time != the_time: print("the time is:", ctime(time())) prev_time = the_time with some output being: the time is: sun aug 20 13:40:04 2000 the time is: sun aug 20 13:40:05 2000 the time is: sun aug 20 13:40:06 2000 the time is: sun aug 20 13:40:07 2000 traceback (innermost last): file "clock.py", line 5, in ? the_time = ctime(time()) keyboardinterrupt the output is infinite of course so i cancelled it (or the output at least continues until ctrl+c is pressed). the program just does an infinite loop (true is always true, so while true: goes forever) and each time checks to see if the time has changed and prints it if it has. notice how multiple names after the import statement are used in the line from time import time, ctime. the python library contains many useful functions. these functions give your programs more abilities and many of them can simplify programming in python. exercises rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. solution rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. from random import randint number = randint(0, 99) guess = -1 while guess != number: guess = int(input ("guess a number: ")) if guess > number: print("too high") elif guess < number: print("too low") print("just right") other modules sometimes you want to use a python module that does not come with the python installation. you can also import those, but you have to have them installed on your computer. creating your own module when python reads the import command, it first checks files in your directory, then site-packages or pre installed modules. to make your own module, just create a .py file in the current directory and use the command: import module this will try to import the file module.py from your current directory and if not found, from site-packages and prepackaged modules. changing module to the name of the .py file you created will import that file. however, when it imports the module, it will basically start the file as a program, so any code on there will be run. you want to group all code into functions. the __name__ == __main__ trick in python, the variable __name__ will give you the current name of the program. if a module you import prints the __name__ variable, then it will print the name of the module. if the current file prints the __name__ variable, it will print __main__, to show it is the main program. if an if statement checks the name variable and runs code if the program is main, it can bypass the unintentional run problem created when a module is imported. say for example you have a file, which runs some code. it also has a function you want to use in another program. however, you only want the function, not to run the code. by setting up the code below, it will only run the code if it is the file that was clicked on or started, not if it was imported. if __name__ == '__main__': pass in this instance, if the file is run but not imported, it will run the pass command. you can replace the pass command with the code you want to be run when not imported. just remember to indent the code. the pip module the pip module is a module that comes with the python installation and acts as a module downloader/manager. you can download other modules from the internet with pip. the pip module is not used in the python interpreter, but is run through the command line. to use it, open up your command line interpreter (for windows it is command prompt, for mac/linux it is terminal) and type in the following code: py3 -m pip install module or the alternate code pip install module this will try to download and install module from the user-submitted python modules database. module can be changed to the name of the module. non-programmer's tutorial for python 3 ← dictionaries print version more on lists → 15. more on lists we have already seen lists and how they can be used. now that you have some more background i will go into more detail about lists. first we will look at more ways to get at the elements in a list and then we will talk about copying them. here are some examples of using indexing to access a single element of a list: >>> some_numbers = ['zero', 'one', 'two', 'three', 'four', 'five'] >>> some_numbers[0] 'zero' >>> some_numbers[4] 'four' >>> some_numbers[5] 'five' all those examples should look familiar to you. if you want the first item in the list just look at index 0. the second item is index 1 and so on through the list. however what if you want the last item in the list? one way could be to use the len() function like some_numbers[len(some_numbers) - 1]. this way works since the len() function always returns the last index plus one. the second from the last would then be some_numbers[len(some_numbers) - 2]. there is an easier way to do this. in python the last item is always index -1. the second to the last is index -2 and so on. here are some more examples: >>> some_numbers[len(some_numbers) - 1] 'five' >>> some_numbers[len(some_numbers) - 2] 'four' >>> some_numbers[-1] 'five' >>> some_numbers[-2] 'four' >>> some_numbers[-6] 'zero' thus any item in the list can be indexed in two ways: from the front and from the back. another useful way to get into parts of lists is using slicing. here is another example to give you an idea what they can be used for: >>> things = [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, "jack", "jill"] >>> things[0] 0 >>> things[7] 'jill' >>> things[0:8] [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, 'jack', 'jill'] >>> things[2:4] [2, 's.p.a.m.'] >>> things[4:7] ['stocking', 42, 'jack'] >>> things[1:5] ['fred', 2, 's.p.a.m.', 'stocking'] slicing is used to return part of a list. the slicing operator is in the form things[first_index:last_index]. slicing cuts the list before the first_index and before the last_index and returns the parts in between. you can use both types of indexing: >>> things[-4:-2] ['stocking', 42] >>> things[-4] 'stocking' >>> things[-4:6] ['stocking', 42] another trick with slicing is the unspecified index. if the first index is not specified the beginning of the list is assumed. if the last index is not specified the whole rest of the list is assumed. here are some examples: >>> things[:2] [0, 'fred'] >>> things[-2:] ['jack', 'jill'] >>> things[:3] [0, 'fred', 2] >>> things[:-5] [0, 'fred', 2] here is a (html inspired) program example (copy and paste in the poem definition if you want): poem = ["<b>", "jack", "and", "jill", "</b>", "went", "up", "the", "hill", "to", "<b>", "fetch", "a", "pail", "of", "</b>", "water.", "jack", "fell", "<b>", "down", "and", "broke", "</b>", "his", "crown", "and", "<b>", "jill", "came", "</b>", "tumbling", "after"] def get_bolds(text): true = 1 false = 0 ## is_bold tells whether or not we are currently looking at ## a bold section of text. is_bold = false ## start_block is the index of the start of either an unbolded ## segment of text or a bolded segment. start_block = 0 for index in range(len(text)): ## handle a starting of bold text if text[index] == "<b>": if is_bold: print("error: extra bold") ## print "not bold:", text[start_block:index] is_bold = true start_block = index + 1 ## handle end of bold text ## remember that the last number in a slice is the index ## after the last index used. if text[index] == "</b>": if not is_bold: print("error: extra close bold") print("bold [", start_block, ":", index, "]", text[start_block:index]) is_bold = false start_block = index + 1 get_bolds(poem) with the output being: bold [ 1 : 4 ] ['jack', 'and', 'jill'] bold [ 11 : 15 ] ['fetch', 'a', 'pail', 'of'] bold [ 20 : 23 ] ['down', 'and', 'broke'] bold [ 28 : 30 ] ['jill', 'came'] the get_bold() function takes in a list that is broken into words and tokens. the tokens that it looks for are <b> which starts the bold text and </b> which ends bold text. the function get_bold() goes through and searches for the start and end tokens. the next feature of lists is copying them. if you try something simple like: >>> a = [1, 2, 3] >>> b = a >>> print(b) [1, 2, 3] >>> b[1] = 10 >>> print(b) [1, 10, 3] >>> print(a) [1, 10, 3] this probably looks surprising since a modification to b resulted in a being changed as well. what happened is that the statement b = a makes b a reference to a. this means that b can be thought of as another name for a. hence any modification to b changes a as well. however some assignments don't create two names for one list: >>> a = [1, 2, 3] >>> b = a * 2 >>> print(a) [1, 2, 3] >>> print(b) [1, 2, 3, 1, 2, 3] >>> a[1] = 10 >>> print(a) [1, 10, 3] >>> print(b) [1, 2, 3, 1, 2, 3] in this case b is not a reference to a since the expression a * 2 creates a new list. then the statement b = a * 2 gives b a reference to a * 2 rather than a reference to a. all assignment operations create a reference. when you pass a list as an argument to a function you create a reference as well. most of the time you don't have to worry about creating references rather than copies. however when you need to make modifications to one list without changing another name of the list you have to make sure that you have actually created a copy. there are several ways to make a copy of a list. the simplest that works most of the time is the slice operator since it always makes a new list even if it is a slice of a whole list: >>> a = [1, 2, 3] >>> b = a[:] >>> b[1] = 10 >>> print(a) [1, 2, 3] >>> print(b) [1, 10, 3] taking the slice [:] creates a new copy of the list. however it only copies the outer list. any sublist inside is still a references to the sublist in the original list. therefore, when the list contains lists, the inner lists have to be copied as well. you could do that manually but python already contains a module to do it. you use the deepcopy function of the copy module: >>> import copy >>> a = [[1, 2, 3], [4, 5, 6]] >>> b = a[:] >>> c = copy.deepcopy(a) >>> b[0][1] = 10 >>> c[1][1] = 12 >>> print(a) [[1, 10, 3], [4, 5, 6]] >>> print(b) [[1, 10, 3], [4, 5, 6]] >>> print(c) [[1, 2, 3], [4, 12, 6]] first of all notice that a is a list of lists. then notice that when b[0][1] = 10 is run both a and b are changed, but c is not. this happens because the inner arrays are still references when the slice operator is used. however with deepcopy c was fully copied. so, should i worry about references every time i use a function or =? the good news is that you only have to worry about references when using dictionaries and lists. numbers and strings create references when assigned but every operation on numbers and strings that modifies them creates a new copy so you can never modify them unexpectedly. you do have to think about references when you are modifying a list or a dictionary. by now you are probably wondering why are references used at all? the basic reason is speed. it is much faster to make a reference to a thousand element list than to copy all the elements. the other reason is that it allows you to have a function to modify the inputed list or dictionary. just remember about references if you ever have some weird problem with data being changed when it shouldn't be. non-programmer's tutorial for python 3 ← using modules print version revenge of the strings → 16. revenge of the strings and now presenting a cool trick that can be done with strings: def shout(string): for character in string: print("gimme a " + character) print("'" + character + "'") shout("lose") def middle(string): print("the middle character is:", string[len(string) // 2]) middle("abcdefg") middle("the python programming language") middle("atlanta") and the output is: gimme a l 'l' gimme a o 'o' gimme a s 's' gimme a e 'e' the middle character is: d the middle character is: r the middle character is: a what these programs demonstrate is that strings are similar to lists in several ways. the shout() function shows that for loops can be used with strings just as they can be used with lists. the middle procedure shows that that strings can also use the len() function and array indexes and slices. most list features work on strings as well. the next feature demonstrates some string specific features: def to_upper(string): ## converts a string to upper case upper_case = "" for character in string: if 'a' <= character <= 'z': location = ord(character) - ord('a') new_ascii = location + ord('a') character = chr(new_ascii) upper_case = upper_case + character return upper_case print(to_upper("this is text")) with the output being: this is text this works because the computer represents the characters of a string as numbers from 0 to 1,114,111. for example 'a' is 65, 'b' is 66 and א is 1488. the values are the unicode value. python has a function called ord() (short for ordinal) that returns a character as a number. there is also a corresponding function called chr() that converts a number into a character. with this in mind the program should start to be clear. the first detail is the line: if 'a' <= character <= 'z': which checks to see if a letter is lower case. if it is then the next lines are used. first it is converted into a location so that a = 0, b = 1, c = 2 and so on with the line: location = ord(character) - ord('a'). next the new value is found with new_ascii = location + ord('a'). this value is converted back to a character that is now upper case. note that if you really need the upper case of a letter, you should use u=var.upper() which will work with other languages as well. now for some interactive typing exercise: >>> # integer to string >>> 2 2 >>> repr(2) '2' >>> -123 -123 >>> repr(-123) '-123' >>> # string to integer >>> "23" '23' >>> int("23") 23 >>> "23" * 2 '2323' >>> int("23") * 2 46 >>> # float to string >>> 1.23 1.23 >>> repr(1.23) '1.23' >>> # float to integer >>> 1.23 1.23 >>> int(1.23) 1 >>> int(-1.23) -1 >>> # string to float >>> float("1.23") 1.23 >>> "1.23" '1.23' >>> float("123") 123.0 if you haven't guessed already the function repr() can convert an integer to a string and the function int() can convert a string to an integer. the function float() can convert a string to a float. the repr() function returns a printable representation of something. here are some examples of this: >>> repr(1) '1' >>> repr(234.14) '234.14' >>> repr([4, 42, 10]) '[4, 42, 10]' the int() function tries to convert a string (or a float) into an integer. there is also a similar function called float() that will convert an integer or a string into a float. another function that python has is the eval() function. the eval() function takes a string and returns data of the type that python thinks it found. for example: >>> v = eval('123') >>> print(v, type(v)) 123 <type 'int'> >>> v = eval('645.123') >>> print(v, type(v)) 645.123 <type 'float'> >>> v = eval('[1, 2, 3]') >>> print(v, type(v)) [1, 2, 3] <type 'list'> if you use the eval() function you should check that it returns the type that you expect. one useful string function is the split() method. here's an example: >>> "this is a bunch of words".split() ['this', 'is', 'a', 'bunch', 'of', 'words'] >>> text = "first batch, second batch, third, fourth" >>> text.split(",") ['first batch', ' second batch', ' third', ' fourth'] notice how split() converts a string into a list of strings. the string is split by whitespace by default or by the optional argument (in this case a comma). you can also add another argument that tells split() how many times the separator will be used to split the text. for example: >>> list = text.split(",") >>> len(list) 4 >>> list[-1] ' fourth' >>> list = text.split(",", 2) >>> len(list) 3 >>> list[-1] ' third, fourth' slicing strings (and lists) strings can be cut into pieces — in the same way as it was shown for lists in the previous chapter — by using the slicing "operator" []. the slicing operator works in the same way as before: text[first_index:last_index] (in very rare cases there can be another colon and a third argument, as in the example shown below). in order not to get confused by the index numbers, it is easiest to see them as clipping places, possibilities to cut a string into parts. here is an example, which shows the clipping places (in yellow) and their index numbers (red and blue) for a simple text string: 0 1 2 ... -2 -1 ↓ ↓ ↓ ↓ ↓ ↓ ↓ text = " s t r i n g " ↑ ↑ [: :] note that the red indexes are counted from the beginning of the string and the blue ones from the end of the string backwards. (note that there is no blue -0, which could seem to be logical at the end of the string. because -0 == 0, -0 means "beginning of the string" as well.) now we are ready to use the indexes for slicing operations: text[1:4] → "tri" text[:5] → "strin" text[:-1] → "strin" text[-4:] → "ring" text[2] → "r" text[:] → "string" text[::-1] → "gnirts" text[1:4] gives us all of the text string between clipping places 1 and 4, "tri". if you omit one of the [first_index:last_index] arguments, you get the beginning or end of the string as default: text[:5] gives "strin". for both first_index and last_index we can use both the red and the blue numbering schema: text[:-1] gives the same as text[:5], because the index -1 is at the same place as 5 in this case. if we do not use an argument containing a colon, the number is treated in a different way: text[2] gives us one character following the second clipping point, "r". the special slicing operation text[:] means "from the beginning to the end" and produces a copy of the entire string (or list, as shown in the previous chapter). last but not least, the slicing operation can have a second colon and a third argument, which is interpreted as the "step size": text[::-1] is text from beginning to the end, with a step size of -1. -1 means "every character, but in the other direction". "string" backwards is "gnirts" (test a step length of 2, if you have not got the point here). all these slicing operations work with lists as well. in that sense strings are just a special case of lists, where the list elements are single characters. just remember the concept of clipping places, and the indexes for slicing things will get a lot less confusing. examples # this program requires an excellent understanding of decimal numbers. def to_string(in_int): """converts an integer to a string""" out_str = "" prefix = "" if in_int < 0: prefix = "-" in_int = -in_int while in_int // 10 != 0: out_str = str(in_int % 10) + out_str in_int = in_int // 10 out_str = str(in_int % 10) + out_str return prefix + out_str def to_int(in_str): """converts a string to an integer""" out_num = 0 if in_str[0] == "-": multiplier = -1 in_str = in_str[1:] else: multiplier = 1 for c in in_str: out_num = out_num * 10 + int(c) return out_num * multiplier print(to_string(2)) print(to_string(23445)) print(to_string(-23445)) print(to_int("14234")) print(to_int("12345")) print(to_int("-3512")) the output is: 2 23445 -23445 14234 12345 -3512 non-programmer's tutorial for python 3 ← more on lists print version file io → 17. file io file i/o here is a simple example of file i/o (input/output): # write a file with open("test.txt", "wt") as out_file: out_file.write("this text is going to out file\nlook at it and see!") # read a file with open("test.txt", "rt") as in_file: text = in_file.read() print(text) the output and the contents of the file test.txt are: this text is going to out file look at it and see! notice that it wrote a file called test.txt in the directory that you ran the program from. the \n in the string tells python to put a newline where it is. an overview of file i/o is: get a file object with the open function read or write to the file object (depending on how it was opened) if you did not use with to open the file, you'd have to close it manually the first step is to get a file object. the way to do this is to use the open function. the format is file_object = open(filename, mode) where file_object is the variable to put the file object, filename is a string with the filename, and mode is "rt" to read a file as text or "wt" to write a file as text (and a few others we will skip here). next the file objects functions can be called. the two most common functions are read and write. the write function adds a string to the end of the file. the read function reads the next thing in the file and returns it as a string. if no argument is given it will return the whole file (as done in the example). now here is a new version of the phone numbers program that we made earlier: def print_numbers(numbers): print("telephone numbers:") for k, v in numbers.items(): print("name:", k, "\tnumber:", v) print() def add_number(numbers, name, number): numbers[name] = number def lookup_number(numbers, name): if name in numbers: return "the number is " + numbers[name] else: return name + " was not found" def remove_number(numbers, name): if name in numbers: del numbers[name] else: print(name," was not found") def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. load numbers') print('6. save numbers') print('7. quit') print() phone_list = {} menu_choice = 0 print_menu() while true: menu_choice = int(input("type in a number (1-7): ")) if menu_choice == 1: print_numbers(phone_list) elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") add_number(phone_list, name, phone) elif menu_choice == 3: print("remove name and number") name = input("name: ") remove_number(phone_list, name) elif menu_choice == 4: print("lookup number") name = input("name: ") print(lookup_number(phone_list, name)) elif menu_choice == 5: filename = input("filename to load: ") load_numbers(phone_list, filename) elif menu_choice == 6: filename = input("filename to save: ") save_numbers(phone_list, filename) elif menu_choice == 7: break else: print_menu() print("goodbye") notice that it now includes saving and loading files. here is some output of my running it twice: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 2 add name and number name: jill number: 1234 type in a number (1-7): 2 add name and number name: fred number: 4321 type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 6 filename to save: numbers.txt type in a number (1-7): 7 goodbye 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 5 filename to load: numbers.txt type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 7 goodbye the new portions of this program are: def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() first we will look at the save portion of the program. first it creates a file object with the command open(filename, "wt"). next it goes through and creates a line for each of the phone numbers with the command out_file.write(k + "," + v + "\n"). this writes out a line that contains the name, a comma, the number and follows it by a newline. the loading portion is a little more complicated. it starts by getting a file object. then it uses a while true: loop to keep looping until a break statement is encountered. next it gets a line with the line in_line = in_file.readline(). the readline function will return an empty string when the end of the file is reached. the if statement checks for this and breaks out of the while loop when that happens. of course if the readline function did not return the newline at the end of the line there would be no way to tell if an empty string was an empty line or the end of the file so the newline is left in what readline returns. hence we have to get rid of the newline. the line in_line = in_line[:-1] does this for us by dropping the last character. next the line name, number = in_line.split(",") splits the line at the comma into a name and a number. this is then added to the numbers dictionary. advanced use of .txt files you might be saying to yourself, "well i know how to read and write to a textfile, but what if i want to print the file without opening out another program?" there are a few different ways to accomplish this. the easiest way does open another program, but everything is taken care of in the python code, and doesn't require the user to specify a file to be printed. this method involves invoking the subprocess of another program. remember the file we wrote output to in the above program? let's use that file. keep in mind, in order to prevent some errors, this program uses concepts from the next chapter. please feel free to revisit this example after the next chapter. import subprocess def main(): try: print("this small program invokes the print function in the notepad application") #lets print the file we created in the program above subprocess.call(['notepad','/p','numbers.txt']) except windowserror: print("the called subprocess does not exist, or cannot be called.") main() the subprocess.call takes three arguments. the first argument in the context of this example, should be the name of the program which you would like to invoke the printing subprocess from. the second argument should be the specific subprocess within that program. for simplicity, just understand that in this program, '/p' is the subprocess used to access your printer through the specified application. the last argument should be the name of the file you want to send to the printing subprocess. in this case, it is the same file used earlier in this chapter. exercises now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. solution now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = { } def load_grades(gradesfile): inputfile = open(gradesfile, "r") grades = [ ] while true: student_and_grade = inputfile.readline() student_and_grade = student_and_grade[:-1] if not student_and_grade: break else: studentname, studentgrades = student_and_grade.split(",") studentgrades = studentgrades.split(" ") students[studentname] = studentgrades inputfile.close() print("grades loaded.") def save_grades(gradesfile): outputfile = open(gradesfile, "w") for k, v in students.items(): outputfile.write(k + ",") for x in v: outputfile.write(str(x) + " ") outputfile.write("\n") outputfile.close() print("grades saved.") def print_menu(): print("1. add student") print("2. remove student") print("3. load grades") print("4. record grade") print("5. print grades") print("6. save grades") print("7. print menu") print("9. quit") def print_all_grades(): if students: keys = sorted(students.keys()) print('\t', end=' ') for x in assignments: print(x, '\t', end=' ') print() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) else: print("there are no grades to print.") def print_grades(grades): for x in grades: print(x, '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 9: print() menu_choice = int(input("menu choice: ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(assignments) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: gradesfile = input("load grades from which file? ") load_grades(gradesfile) elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i,x in enumerate(assignments): print(i + 1, x, '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 if 0 <= which < len(grades): grade = input("grade: ") # change from float(input()) to input() to avoid an error when saving grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice == 5: print_all_grades() elif menu_choice == 6: gradesfile = input("save grades to which file? ") save_grades(gradesfile) elif menu_choice != 9: print_menu() non-programmer's tutorial for python 3 ← revenge of the strings print version dealing with the imperfect → 18. dealing with the imperfect ...or how to handle errors closing files with with we use the "with" statement to open and close files.[1][2] with open("in_test.txt", "rt") as in_file: with open("out_test.txt", "wt") as out_file: text = in_file.read() data = parse(text) results = encode(data) out_file.write(results) print( "all done." ) if some sort of error happens anywhere in this code (one of the files is inaccessible, the parse() function chokes on corrupt data, etc.) the "with" statements guarantee that all the files will eventually be properly closed. closing a file just means that the file is "cleaned up" and "released" by our program so that it can be used in another program. to do: is the "closing files with with" section too much detail for a non-programmers tutorial? if so, move it to some other python wikibook (subject:python programming language) catching errors with try so you now have the perfect program, it runs flawlessly, except for one detail, it will crash on invalid user input. have no fear, for python has a special control structure for you. it's called try and it tries to do something. here is an example of a program with a problem: print("type control c or -1 to exit") number = 1 while number != -1: number = int(input("enter a number: ")) print("you entered:", number) notice how when you enter @#& it outputs something like: traceback (most recent call last): file "try_less.py", line 4, in <module> number = int(input("enter a number: ")) valueerror: invalid literal for int() with base 10: '\\@#&' as you can see the int() function is unhappy with the number @#& (as well it should be). the last line shows what the problem is; python found a valueerror. how can our program deal with this? what we do is first: put the place where errors may occur in a try block, and second: tell python how we want valueerrors handled. the following program does this: print("type control c or -1 to exit") number = 1 while number != -1: try: number = int(input("enter a number: ")) print("you entered:", number) except valueerror: print("that was not a number.") now when we run the new program and give it @#& it tells us "that was not a number." and continues with what it was doing before. when your program keeps having some error that you know how to handle, put code in a try block, and put the way to handle the error in the except block. exercises update at least the phone numbers program (in section dictionaries) so it doesn't crash if a user doesn't enter any data at the menu. solution def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: try: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() except valueerror: print("that was not a number.") non-programmer's tutorial for python 3 ← file io print version recursion → 19. the end so here we are at the end, or maybe the beginning. this tutorial is on wikibooks, so feel free to make improvements to it. if you want to learn more about python, the python tutorial by guido van rossum has more topics that you can learn about. if you have been following this tutorial, you should be able to understand a fair amount of it. the python programming wikibook can be worth looking at, too. here are few other books which cover python 3: a byte of python by swaroop c h datacamp interactive python 3 tutorial - online hands-on python tutorial by dr. andrew n. harrington subject:python programming language lists other wikibooks related to python. hopefully this book covers everything you have needed to get started programming. thanks to everyone who has sent me emails about it. i enjoyed reading them, even when i have not always been the best replier. happy programming, may it change your life and the world. non-programmer's tutorial for python 3 ← intro to imported libraries and other functions print version faq → 20. faq how do i make a gui in python? you can use one of these library: tkinter, pyqt, pygobject. for really simple graphics, you can use the turtle graphics mode import turtle how do i make a game in python? the best method is probably to use pygame at http://pygame.org/ how do i make an executable from a python program? short answer: python is an interepreted language so that is impossible. long answer is that something similar to an executable can be created by taking the python interpreter and the file and joining them together and distributing that. for more on that problem see http://www.python.org/doc/faq/programming/#how-can-i-create-a-stand-alone-binary-from-a-python-script (ifaq) why do you use first person in this tutorial? once upon a time in a different millenia, (1999 to be exact), an earlier version was written entirely by josh cogliati, and it was up on his webpage http://www.honors.montana.edu/~jjc/easytut and it was good. then the server rupert, like all good things than have a beginning came to an end, and josh moved it to wikibooks, but the first person writing stuck. if someone really wants to change it, i will not revert it, but i don't see much point. (the webpage has since moved to http://jjc.freeshell.org/easytut/ and http://jjc.freeshell.org/easytut3/ ) my question is not answered. ask on the discussion page or add it to this faq, or email one of the authors. for other faqs, you may want to see the python 2.6 version of this page non-programmer's tutorial for python 2.6/faq, or the python faq. non-programmer's tutorial for python 3 ← the end print version ↑ "the 'with' statement" ↑ 'the python "with" statement by example' retrieved from "https://en.wikibooks.org/w/index.php?title=non-programmer%27s_tutorial_for_python_3/print_version&oldid=3412786" this is the print version of non-programmer's tutorial for python 3you won't see this message or any elements not part of the book's content when you print or preview this page. non-programmer's tutorial for python 3 the current, editable version of this book is available in wikibooks, the open-content textbooks collection, at https://en.wikibooks.org/wiki/non-programmer%27s_tutorial_for_python_3 permission is granted to copy, distribute, and/or modify this document under the terms of the creative commons attribution-sharealike 3.0 license. contents 1 1. front matter 1.1 other resources 2 2. intro 2.1 first things first 2.2 installing python 2.2.1 linux, bsd, and unix users 2.2.2 mac users 2.2.3 windows users 2.2.3.1 configuring your path environment variable 2.3 interactive mode 2.4 creating and running programs 2.4.1 program file names 2.5 using python from the command line 2.5.1 running python programs in *nix 2.6 where to get help 2.6.1 python documentation 2.6.2 python user community 3 3. hello, world 3.1 what you should know 3.2 printing 3.2.1 terminology 3.2.2 \n in printing 3.3 expressions 3.3.1 arithmetic expressions 3.4 commenting in python 3.5 examples 3.6 exercises 3.6.1 footnotes 4 4. who goes there? 4.1 input and variables 4.2 assignment 4.3 examples 4.4 exercises 5 5. count to 10 5.1 while loops 5.1.1 infinite loops or never ending loop 5.2 examples 5.2.1 fibonacci sequence 5.2.2 enter password 5.3 exercises 6 6. decisions 6.1 if statement 6.2 examples 6.3 exercises 7 7. debugging 7.1 what is debugging? 7.2 what should the program do? 7.3 what does the program do? 7.4 how do i fix my program? 8 8. defining functions 8.1 creating functions 8.2 variables in functions 8.3 examples 8.4 exercises 9 9. advanced functions example 9.1 recursion 9.2 examples 10 10. lists 10.1 variables with more than one value 10.2 more features of lists 10.3 examples 10.4 exercises 11 11. for loops 12 12. boolean expressions 12.1 a note on boolean operators 12.2 examples 12.3 exercises 13 13. dictionaries 14 14. using modules 14.1 exercises 14.2 other modules 14.2.1 creating your own module 14.2.1.1 the __name__ == __main__ trick 14.2.2 the pip module 15 15. more on lists 16 16. revenge of the strings 16.1 slicing strings (and lists) 16.2 examples 17 17. file io 17.1 file i/o 17.2 advanced use of .txt files 17.3 exercises 18 18. dealing with the imperfect 18.1 ...or how to handle errors 18.2 closing files with with 18.3 catching errors with try 18.4 exercises 19 19. the end 20 20. faq 1. front matter all example python source code in this tutorial is granted to the public domain. therefore you may modify it and relicense it under any license you please. since you are expected to learn programming, the creative commons attribution-sharealike license would require you to keep all programs that are derived from the source code in this tutorial under that license. since the python source code is granted to the public domain, that requirement is waived. this tutorial is more or less a conversion of non-programmer's tutorial for python 2.6. older versions and some versions in korean, spanish, italian and greek are available from http://jjc.freeshell.org/easytut/ the non-programmers' tutorial for python 3 is a tutorial designed to be an introduction to the python programming language. this guide is for someone with no programming experience. if you have programmed in other languages i recommend using python tutorial for programmers written by guido van rossum. if you have any questions or comments please use the discussion pages or see authors page for author contact information. i welcome questions and comments about this tutorial. i will try to answer any questions you have as best i can. thanks go to james a. brown for writing most of the windows install info. thanks also to elizabeth cogliati for complaining enough :) about the original tutorial (that is almost unusable for a non-programmer), for proofreading, and for many ideas and comments on it. thanks to joe oppegaard for writing almost all the exercises. thanks to everyone i have missed. other resources python home page python 3 documentation a byte of python by swaroop c h porting to python 3: an in-depth guide non-programmer's tutorial for python 3 ← authors print version intro → 2. intro first things first so, you've never programmed before. as we go through this tutorial, i will attempt to teach you how to program. there really is only one way to learn to program. you must read code and write code (as computer programs are often called). i'm going to show you lots of code. you should type in code that i show you to see what happens. play around with it and make changes. the worst that can happen is that it won't work. when i type in code it will be formatted like this: # python is easy to learn print("hello, world!") that's so it is easy to distinguish from the other text. if you're reading this on the web, you'll notice the code is in color -- that's just to make it stand out, and to make the different parts of the code stand out from each other. the code you enter will probably not be colored, or the colors may be different, but it won't affect the code as long as you enter it the same way as it's printed here. if the computer prints something out it will be formatted like this: hello, world! (note that printed text goes to your screen, and does not involve paper. before computers had screens, the output of computer programs would be printed on paper.) note that this is a python 3 tutorial, which means that most of the examples will not work in python 2.7 and before. as well, all but a small number of the extra python 2.7 libraries (third-party libraries) have been converted to python 3. most likely you will want to learn python 3, but if you are learning python for a specific package or set of modules that are only written in python 2.7, you may want to consider learning from the non-programmer's tutorial for python 2.6. however, the differences between python 2 and 3 are not particularly large, so if you learn one, you should be able to read programs written for the other without much difficulty. there will often be a mixture of the text you type (which is shown in bold) and the text the program prints to the screen, which would look like this: halt! who goes there? josh you may pass, josh (some of the tutorial has not been converted to this format. since this is a wiki, you can convert it when you find it.) i will also introduce you to the terminology of programming - for example, that programming is often referred to as coding or hacking. this will not only help you understand what programmers are talking about, but also help the learning process. now, on to more important things. in order to program in python you need the python 3 software. if you don't already have the python software go to www.python.org/download and get the proper version for your platform. download it, read the instructions and get it installed. installing python for python programming you need a working python installation and a text editor. python comes with its own editor, idle, which is quite nice and totally sufficient for the beginning. as you get more into programming, you will probably switch to some other editor like nano, emacs, vi or another. the python download page is http://www.python.org/download. the most recent version is python 3.8.5 (as of july 2020); python 2.7 and older versions will not work with this tutorial. there are various different installation files for different computer platforms available on the download site. here are some specific instructions for the most common operating systems: linux, bsd, and unix users you are probably lucky and python is already installed on your machine. to test it type python3 on a command line. if you see something like what is shown in the following section, you are set. idle may need to be installed separately, from its own package such as idle3 or as part of python-tools. if you have to install python, first try to use the operating system's package manager or go to the repository where your packages are available and get python 3. python 3.0 was released in december 2008; all distributions should have python 3 available, so you may not need to compile it from scratch. ubuntu and fedora do have python 3 binary packages available, but they are not yet the default, so they need to be installed specially. roughly, here are the steps to compile python from source code in unix (if these totally don't make sense, you may want to read another introduction to *nix, such as introduction to linux): download the .tgz file (use your web browser to get the gzipped tar file from https://www.python.org/ftp/python/3.7.4/python-3.7.4.tgz) uncompress the tar file (put in the correct path to where you downloaded it): $ tar -xvzf ~/download/python-3.7.4.tgz ... list of files as they are uncompressed change to the directory and tell the computer to compile and install the program $ cd python-3.7/ $ ./configure --prefix=$home/python3_install ... lots of output. watch for error messages here ... $ make ... even more output. hopefully no error messages ... $ make install add python 3 to your path. you can test it first by specifying the full path. you should add $home/python3_install/bin to your path bash variable. $ ~/python3_install/bin/python3 python 3.7.4 (... size and date information ...) [gcc 9.1.0] on linux type "help", "copyright", "credits" or "license" for more information. >>> the above commands will install python 3 to your home directory, which is probably what you want, but if you skip the --prefix=$home/python3_install, it will install it to /usr/local. if you want to use the idle graphical code editor, you need to make sure that the tk and tcl libraries, together with their development files, are installed on the system. you will get a warning during the make phase if these are not available. mac users starting from mac os x tiger (10.4), versions of python 2 shipped with the operating system by default, but you will need to also install python 3 unless mac os starts including python 3 (check the version by starting python3 in a command line terminal). also idle (the python editor) might be missing in the standard installation. if you want to (re-)install python, get the mac os installer from the python download site. windows users download the appropriate windows installer (the x86 msi installer, if you do not have a 64-bit amd or intel chip). start the installer by double-clicking it and follow the prompts. see https://docs.python.org/3/using/windows.html#installing-python for more information. configuring your path environment variable the path environment variable is a list of folders, separated by semicolons, in which windows will look for a program whenever you try to execute one by typing its name at a command prompt. you can see the current value of your path by typing this command at a command prompt: echo %path% the easiest way to permanently change environment variables is to bring up the built-in environment variable editor in windows. how you get to this editor is slightly different on different versions of windows. on windows 8 or windows 10: press the windows key and type control panel to locate the windows control panel. once you've opened the control panel, select view by: large icons, then click on system. in the window that pops up, click the advanced system settings link, then click the environment variables... button. on windows 7 or vista: click the start button in the lower-left corner of the screen, move your mouse over computer, right-click, and select properties from the pop-up menu. click the advanced system settings link, then click the environment variables... button. once you've brought up the environment variable editor, you'll do the same thing regardless of which version of windows you're running. under system variables in the bottom half of the editor, find a variable called path. if there is is one, select it and click edit.... assuming your python root is c:\python37, add these two folders to your path (and make sure you get the semicolons right; there should be a semicolon between each folder in the list): c:\python37 c:\python37\scripts note: if you want to double-click and start your python programs from a windows folder and not have the console window disappear, you can add the following code to the bottom of each script: #stops console from exiting end_prog = "" while end_prog != "q": end_prog = input("type q to quit") interactive mode go into idle (also called the python gui). you should see a window that has some text like this: python 3.0 (r30:67503, dec 29 2008, 21:31:07) [gcc 4.3.2 20081105 (red hat 4.3.2-7)] on linux2 type "copyright", "credits" or "license()" for more information. **************************************************************** personal firewall software may warn about the connection idle makes to its subprocess using this computer's internal loopback interface. this connection is not visible on any external interface and no data is sent to or received from the internet. **************************************************************** idle 3.0 >>> the >>> is python's way of telling you that you are in interactive mode. in interactive mode what you type is immediately run. try typing 1+1 in. python will respond with 2. interactive mode allows you to test out and see what python will do. if you ever feel you need to play with new python statements, go into interactive mode and try them out. creating and running programs go into idle if you are not already. in the menu at the top, select file then new file. in the new window that appears, type the following: print("hello, world!") now save the program: select file from the menu, then save. save it as "hello.py" (you can save it in any folder you want). now that it is saved it can be run. next run the program by going to run then run module (or if you have an older version of idle use edit then run script). this will output hello, world! on the *python shell* window. for a more in-depth introduction to idle, a longer tutorial with screenshots can be found at http://hkn.eecs.berkeley.edu/~dyoo/python/idle_intro/index.html. program file names it is very useful to stick to some rules regarding the file names of python programs. otherwise some things might go wrong unexpectedly. these don't matter as much for programs, but you can have weird problems if you don't follow them for module names (modules will be discussed later). always save the program with the extension .py. do not put another dot anywhere else in the file name. only use standard characters for file names: letters, numbers, dash (-) and underscore (_). white space (" ") should not be used at all (use underscores instead). do not use anything other than a letter (particularly no numbers!) at the beginning of a file name. do not use "non-english" characters (such as å, ɓ, ç, ð, é, õ, ü) in your file names—or, even better, do not use them at all when programming. do not use module names for file names (such as print.py, math.py, list.py) using python from the command line if you don't want to use python from the command line, you don't have to, just use idle. to get into interactive mode just type python3 without any arguments. to run a program, create it with a text editor (emacs has a good python mode) and then run it with python3 program_name. running python programs in *nix if you are using unix (such as linux, mac os, or bsd), if you make the program executable with chmod, and have as the first line: #!/usr/bin/env python3 you can run the python program with ./hello.py like any other command. where to get help at some point in your python career you will probably get stuck and have no clue about how to solve the problem you are supposed to work on. this tutorial only covers the basics of python programming, but there is a lot of further information available. python documentation first of all, python is very well documented. there might even be copies of these documents on your computer that came with your python installation: the official python 3 tutorial by guido van rossum is often a good starting point for general questions. for questions about standard modules (you will learn what these are later), the python 3 library reference is the place to look. if you really want to get to know something about the details of the language, the python 3 reference manual is comprehensive but quite complex for beginners. python user community there are a lot of other python users out there, and usually they are nice and willing to help you. this very active user community is organised mostly through mailing lists and a newsgroup: the tutor mailing list is for folks who want to ask questions regarding how to learn computer programming with the python language. the python-help mailing list is python.org's help desk. you can ask a group of knowledgeable volunteers questions about all your python problems. the python newsgroup comp.lang.python (google groups archive) is the place for general python discussions, questions and the central meeting point of the community. python wiki has a list of local user groups, you can join the group mailing list and ask questions. you can also participate in the user group meetings. learnpython subreddit is another location where beginner level questions can be asked. in order not to reinvent the wheel and discuss the same questions again and again, people will appreciate very much if you do a web search for a solution to your problem before contacting these lists! non-programmer's tutorial for python 3 ← front matter print version hello, world → 3. hello, world what you should know once you've read and mastered this chapter, you should know how to edit programs in a text editor or idle, save them to the hard disk, and run them once they have been saved. printing programming tutorials since the beginning of time have started with a little program called "hello, world!"[1] so here it is: print("hello, world!") if you are using the command line to run programs then type it in with a text editor, save it as hello.py and run it with python3 hello.py otherwise go into idle, create a new window, and create the program as in section creating and running programs. when this program is run here's what it prints: hello, world! now i'm not going to tell you this every time, but when i show you a program i recommend that you type it in and run it. i learn better when i type it in and you probably do too. now here is a more complicated program: print("jack and jill went up a hill") print("to fetch a pail of water;") print("jack fell down, and broke his crown,") print("and jill came tumbling after.") when you run this program it prints out: jack and jill went up a hill to fetch a pail of water; jack fell down, and broke his crown, and jill came tumbling after. when the computer runs this program it first sees the line: print("jack and jill went up a hill") so the computer prints: jack and jill went up a hill then the computer goes down to the next line and sees: print("to fetch a pail of water;") so the computer prints to the screen: to fetch a pail of water; the computer keeps looking at each line, follows the command and then goes on to the next line. the computer keeps running commands until it reaches the end of the program. terminology now is probably a good time to give you a bit of an explanation of what is happening - and a little bit of programming terminology. what we were doing above was using a function called print. the function's name - print - is followed by parentheses containing zero or more arguments. so in this example print("hello, world!") there is one argument, which is "hello, world!". note that this argument is a group of characters enclosed in double quotes (""). this is commonly referred to as a string of characters, or string, for short. another example of a string is "jack and jill went up a hill". the combination of a function and parentheses with the arguments is a function call. a function and its arguments are one type of statement that python has, so print("hello, world!") is an example of a statement. basically, you can think of a statement as a single line in a program. that's probably more than enough terminology for now. \n in printing \n in printing makes the strings after the \n in a new line,here is an example: print("hello, world!\nwhat should i do?") here is the output: hello, world! what should i do? it can be used to put a bunch of strings that are supposed to be on different lines into 1 print statement instead of making multiple print statements expressions here is another program: print("2 + 2 is", 2 + 2) print("3 * 4 is", 3 * 4) print("100 - 1 is", 100 - 1) print("(33 + 2) / 5 + 11.5 is", (33 + 2) / 5 + 11.5) and here is the output when the program is run: 2 + 2 is 4 3 * 4 is 12 100 - 1 is 99 (33 + 2) / 5 + 11.5 is 18.5 as you can see, python can turn your thousand-dollar computer into a five-dollar calculator. arithmetic expressions in this example, the print function is followed by two arguments, with each of the arguments separated by a comma. so with the first line of the program print("2 + 2 is", 2 + 2) the first argument is the string "2 + 2 is" and the second argument is the arithmetic expression 2 + 2, which is one kind of expression. what is important to note is that a string is printed as is (without the enclosing double quotes), but an expression is evaluated, or converted to its actual value. python has seven basic operations for numbers: operation symbol example power (exponentiation) ** 5 ** 2 == 25 multiplication * 2 * 3 == 6 division / 14 / 3 == 4.666666666666667 integer division // 14 // 3 == 4 remainder (modulo) % 14 % 3 == 2 addition + 1 + 2 == 3 subtraction - 4 - 3 == 1 notice that there are two ways to do division, one that returns the repeating decimal, and the other that can get the remainder and the whole number. the order of operations is the same as in math: parentheses () exponents ** multiplication *, division /, integer division //, and remainder % addition + and subtraction - so use parentheses to structure your formulas when needed. commenting in python often in programming, you are doing something complicated and may not in the future remember what you did. when this happens the program should probably be commented. a comment is a note to you and other programmers explaining what is happening. for example: # not quite pi, but a credible simulation print(22 / 7) which outputs 3.14285714286 notice that the comment starts with a hash: #. comments are used to communicate with others who read the program and your future self to make clear what is complicated. note that any text can follow comment and that when the program is run, the text after the # through to the end of that line is ignored. the # does not have to be at the beginning of a new line: # output pi on the screen print(22 / 7) # well, just a good approximation examples each chapter (eventually) will contain examples of the programming features introduced in the chapter. you should at least look over them and see if you understand them. if you don't, you may want to type them in and see what happens. mess around with them, change them and see what happens. denmark.py print("something's rotten in the state of denmark.") print(" -- shakespeare") output: something's rotten in the state of denmark. -- shakespeare school.py # this is not quite true outside of usa # and is based on my dim memories of my younger years print("firstish grade") print("1 + 1 =", 1 + 1) print("2 + 4 =", 2 + 4) print("5 - 2 =", 5 - 2) print() print("thirdish grade") print("243 - 23 =", 243 - 23) print("12 * 4 =", 12 * 4) print("12 / 3 =", 12 / 3) print("13 / 3 =", 13 // 3, "r", 13 % 3) print() print("junior high") print("123.56 - 62.12 =", 123.56 - 62.12) print("(4 + 3) * 2 =", (4 + 3) * 2) print("4 + 3 * 2 =", 4 + 3 * 2) print("3 ** 2 =", 3 ** 2) output: firstish grade 1 + 1 = 2 2 + 4 = 6 5 - 2 = 3 thirdish grade 243 - 23 = 220 12 * 4 = 48 12 / 3 = 4 13 / 3 = 4 r 1 junior high 123.56 - 62.12 = 61.44 (4 + 3) * 2 = 14 4 + 3 * 2 = 10 3 ** 2 = 9 exercises write a program that prints your full name and your birthday as separate strings. write a program that shows the use of all 7 arithmetic operations. solution 1. write a program that prints your full name and your birthday as separate strings. print("ada lovelace", "born on", "november 27, 1852") print("albert einstein", "born on", "14 march 1879") print(("john smith"), ("born on"), ("14 march 1879")) solution 2. write a program that shows the use of all 7 arithmetic operations. print("5**5 = ", 5**5) print("6*7 = ", 6*7) print("56/8 = ", 56/8) print("14//6 = ", 14//6) print("14%6 = ", 14%6) print("5+6 = ", 5+6) print("9-0 = ", 9-0) footnotes ↑ here is a great list of the famous "hello, world!" program in many programming languages. just so you know how simple python can be... non-programmer's tutorial for python 3 ← intro print version who goes there? → 4. who goes there? input and variables now i feel it is time for a really complicated program. here it is: print("halt!") user_input = input("who goes there? ") print("you may pass,", user_input) when i ran it, here is what my screen showed: halt! who goes there? josh you may pass, josh note: after running the code by pressing f5, the python shell will only give output: halt! who goes there? you need to enter your name in the python shell, and then press enter for the rest of the output. of course when you run the program your screen will look different because of the input() statement. when you ran the program you probably noticed (you did run the program, right?) how you had to type in your name and then press enter. then the program printed out some more text and also your name. this is an example of input. the program reaches a certain point and then waits for the user to input some data that the program can use later. of course, getting information from the user would be useless if we didn't have anywhere to put that information and this is where variables come in. in the previous program user_input is a variable. variables are like a box that can store some piece of data. here is a program to show examples of variables: a = 123.4 b23 = 'spam' first_name = "bill" b = 432 c = a + b print("a + b is",c) print("first_name is",first_name) print("sorted parts, after midnight or",b23) and here is the output: a + b is 555.4 first_name is bill sorted parts, after midnight or spam variables store data. the variables in the above program are a, b23, first_name, b, and c. the two basic types are strings and numbers. strings are a sequence of letters, numbers and other characters. in this example b23 and first_name are variables that are storing strings. spam, bill, a + b is, first_name is, and sorted parts, after midnight or are the strings in this program. the characters are surrounded by " or '. the other type of variables are numbers. remember that variables are used to store a value, they do not use quotation marks (" and '). if you want to use an actual value, you must use quotation marks. value1 == pim value2 == "pim" both look the same, but in the first one python checks if the value stored in the variable value1 is the same as the value stored in the variable pim. in the second one, python checks if the string (the actual letters p,i, and m) are the same as in value2 (continue this tutorial for more explanation about strings and about the ==). assignment okay, so we have these boxes called variables and also data that can go into the variable. the computer will see a line like first_name = "bill" and it reads it as "put the string bill into the box (or variable) first_name". later on it sees the statement c = a + b and it reads it as "put the sum of a + b or 123.4 + 432 which equals 555.4 into c". the right hand side of the statement (a + b) is evaluated and the result is stored in the variable on the left hand side (c). this is called assignment, and you should not confuse the assignment equal sign (=) with "equality" in a mathematical sense here (that's what == will be used for later). here is another example of variable usage: a = 1 print(a) a = a + 1 print(a) a = a * 2 print(a) and of course here is the output: 1 2 4 even if the same variable appears on both sides of the equals sign (e.g., spam = spam), the computer still reads it as, "first find out the data to store and then find out where the data goes." one more program before i end this chapter: number = float(input("type in a number: ")) integer = int(input("type in an integer: ")) text = input("type in a string: ") print("number =", number) print("number is a", type(number)) print("number * 2 =", number * 2) print("integer =", integer) print("integer is a", type(integer)) print("integer * 2 =", integer * 2) print("text =", text) print("text is a", type(text)) print("text * 2 =", text * 2) the output i got was: type in a number: 12.34 type in an integer: -3 type in a string: hello number = 12.34 number is a <class 'float'> number * 2 = 24.68 integer = -3 integer is a <class 'int'> integer * 2 = -6 text = hello text is a <class 'str'> text * 2 = hellohello notice that number was created with float(input()) ,int(input()) returns an integer, a number with no decimal point, while text created with input() returns a string(can be writen as str(input()), too). when you want the user to type in a decimal use float(input()), if you want the user to type in an integer use int(input()), but if you want the user to type in a string use input(). the second half of the program uses the type() function which tells what kind a variable is. numbers are of type int or float, which are short for integer and floating point (mostly used for decimal numbers), respectively. text strings are of type str, short for string. integers and floats can be worked on by mathematical functions, strings cannot. notice how when python multiplies a number by an integer the expected thing happens. however when a string is multiplied by an integer the result is that multiple copies of the string are produced (i.e., text * 2 = hellohello). operations with strings do different things than operations with numbers. as well, some operations only work with numbers (both integers and floating point numbers) and will give an error if a string is used. here are some interactive mode examples to show that some more. >>> print("this" + " " + "is" + " joined.") this is joined. >>> print("ha, " * 5) ha, ha, ha, ha, ha, >>> print("ha, " * 5 + "ha!") ha, ha, ha, ha, ha, ha! >>> print(3 - 1) 2 >>> print("3" - "1") traceback (most recent call last): file "<stdin>", line 1, in <module> typeerror: unsupported operand type(s) for -: 'str' and 'str' >>> here is the list of some string operations: operation symbol example repetition * "i" * 5 == "iiiii" concatenation + "hello, " + "world!" == "hello, world!" examples rate_times.py # this program calculates rate and distance problems print("input a rate and a distance") rate = float(input("rate: ")) distance = float(input("distance: ")) time=(distance/ rate) print("time:", time) sample runs: input a rate and a distance rate: 5 distance: 10 time: 2.0 input a rate and a distance rate: 3.52 distance: 45.6 time: 12.9545454545 area.py # this program calculates the perimeter and area of a rectangle print("calculate information about a rectangle") length = float(input("length: ")) width = float(input("width: ")) perimeter=(2 * length + 2 * width) print("area:", length * width) print("perimeter:",perimeter) sample runs: calculate information about a rectangle length: 4 width: 3 area: 12.0 perimeter: 14.0 calculate information about a rectangle length: 2.53 width: 5.2 area: 13.156 perimeter: 15.46 temperature.py # this program converts fahrenheit to celsius fahr_temp = float(input("fahrenheit temperature: ")) celc_temp = (fahr_temp - 32.0) *( 5.0 / 9.0) print("celsius temperature:", celc_temp) sample runs: fahrenheit temperature: 32 celsius temperature: 0.0 fahrenheit temperature: -40 celsius temperature: -40.0 fahrenheit temperature: 212 celsius temperature: 100.0 fahrenheit temperature: 98.6 celsius temperature: 37.0 exercises write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. solution write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. string1 = input('string 1: ') string2 = input('string 2: ') float1 = float(input('number 1: ')) float2 = float(input('number 2: ')) print(string1 + string2) print(float1 * float2) non-programmer's tutorial for python 3 ← hello, world print version count to 10 → 5. count to 10 while loops presenting our first control structure. ordinarily the computer starts with the first line and then goes down from there. control structures change the order that statements are executed or decide if a certain statement will be run. here's the source for a program that uses the while control structure: a = 0 # first, set the initial value of the variable a to 0(zero). while a < 10: # while the value of the variable a is less than 10 do the following: a = a + 1 # increase the value of the variable a by 1, as in: a = a + 1! print(a) # print to screen what the present value of the variable a is. # repeat! until the value of the variable a is equal to 9!? see note. # note: # the value of the variable a will increase by 1 # with each repeat, or loop of the 'while statement block'. # e.g. a = 1 then a = 2 then a = 3 etc. until a = 9 then... # the code will finish adding 1 to a (now a = 10), printing the # result, and then exiting the 'while statement block'. # -- # while a < 10: | # a = a + 1 |<--[ the while statement block ] # print (a) | # -- and here is the extremely exciting output: 1 2 3 4 5 6 7 8 9 10 (and you thought it couldn't get any worse after turning your computer into a five-dollar calculator?) so what does the program do? first it sees the line a = 0 and sets a to zero. then it sees while a < 10: and so the computer checks to see if a < 10. the first time the computer sees this statement, a is zero, so it is less than 10. in other words, as long as a is less than ten, the computer will run the tabbed in statements. this eventually makes a equal to ten (by adding one to a again and again) and the while a < 10 is not true any longer. reaching that point, the program will stop running the indented lines. always remember to put a colon ":" at the end of the while statement line! here is another example of the use of while: a = 1 s = 0 print('enter numbers to add to the sum.') print('enter 0 to quit.') while a != 0: print('current sum:', s) a = float(input('number? ')) s = s + a print('total sum =', s) enter numbers to add to the sum. enter 0 to quit. current sum: 0 number? 200 current sum: 200.0 number? -15.25 current sum: 184.75 number? -151.85 current sum: 32.9 number? 10.00 current sum: 42.9 number? 0 total sum = 42.9 notice how print('total sum =', s) is only run at the end. the while statement only affects the lines that are indented with whitespace. the != means does not equal so while a != 0: means as long as a is not zero run the tabbed statements that follow. note that a is a floating point number, and not all floating point numbers can be accurately represented, so using != on them can sometimes not work. try typing in 1.1 in interactive mode. infinite loops or never ending loop now that we have while loops, it is possible to have programs that run forever. an easy way to do this is to write a program like this: while 1 == 1: print("help, i'm stuck in a loop.") the "==" operator is used to test equality of the expressions on the two sides of the operator, just as "<" was used for "less than" before (you will get a complete list of all comparison operators in the next chapter). this program will output help, i'm stuck in a loop. until the heat death of the universe or you stop it, because 1 will forever be equal to 1. the way to stop it is to hit the control (or ctrl) button and c (the letter) at the same time. this will kill the program. (note: sometimes you will have to hit enter after the control-c.) on some systems, nothing will stop it, short of killing the process--so avoid! examples fibonacci sequence fibonacci-method1.py # this program calculates the fibonacci sequence a = 0 b = 1 count = 0 max_count = 20 while count < max_count: count = count + 1 print(a, end=" ") # notice the magic end=" " in the print function arguments # that keeps it from creating a new line. old_a = a # we need to keep track of a since we change it. a = b b = old_a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 note that the output is on a single line because of the extra argument end=" " in the print arguments. fibonacci-method2.py # simplified and faster method to calculate the fibonacci sequence a = 0 b = 1 count = 0 max_count = 10 while count < max_count: count = count + 1 print(a, b, end=" ") # notice the magic end=" " a = a + b b = a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 fibonacci-method3.py a = 0 b = 1 count = 0 maxcount = 20 #once loop is started we stay in it while count < maxcount: count += 1 olda = a a = a + b b = olda print(olda,end=" ") print() output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 enter password password.py # waits until a password has been entered. use control-c to break out without # the password #note that this must not be the password so that the # while loop runs at least once. password = str() # note that != means not equal while password != "unicorn": password = input("password: ") print("welcome in") sample run: password: auo password: y22 password: password password: open sesame password: unicorn welcome in exercises write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. solution write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. name = input("what is your username: ") password = input("what is your password: ") print("to lock your computer type lock.") command = none input1 = none input2 = none while command != "lock": command = input("what is your command: ") while input1 != name: input1 = input("what is your username: ") while input2 != password: input2 = input("what is your password: ") print("welcome back to your system!") if you would like the program to run continuously, just add a while 1 == 1: loop around the whole thing. you will have to indent the rest of the program when you add this at the top of the code, but don't worry, you don't have to do it manually for each line! just highlight everything you want to indent and click on "indent" under "format" in the top bar of the python window. another way of doing this could be: name = input('set name: ') password = input('set password: ') while 1 == 1: nameguess="" passwordguess="" key="" while (nameguess != name) or (passwordguess != password): nameguess = input('name? ') passwordguess = input('password? ') print("welcome,", name, ". type lock to lock.") while key != "lock": key = input("") notice the or in while (nameguess != name) or (passwordguess != password), which we haven't yet introduced. you can probably figure out how it works. non-programmer's tutorial for python 3 ← who goes there? print version decisions → 6. decisions if statement as always, i believe i should start each chapter with a warm-up typing exercise, so here is a short program to compute the absolute value of an integer: n = int(input("number? ")) if n < 0: print("the absolute value of", n, "is", -n) else: print("the absolute value of", n, "is", n) here is the output from the two times that i ran this program: number? -34 the absolute value of -34 is 34 number? 1 the absolute value of 1 is 1 so what does the computer do when it sees this piece of code? first it prompts the user for a number with the statement "n = int(input("number? "))". next it reads the line "if n < 0:". if n is less than zero python runs the line "print("the absolute value of", n, "is", -n)". otherwise it runs the line "print("the absolute value of", n, "is", n)". more formally python looks at whether the expression n < 0 is true or false. an if statement is followed by an indented block of statements that are run when the expression is true. optionally after the if statement is an else statement and another indented block of statements. this second block of statements is run if the expression is false. there are a number of different tests that an expression can have. here is a table of all of them: operator function < less than <= less than or equal to > greater than >= greater than or equal to == equal != not equal another feature of the if command is the elif statement. it stands for else if and means if the original if statement is false but the elif part is true, then do the elif part. and if neither the if or elif expressions are true, then do what's in the else block. here's an example: a = 0 while a < 10: a = a + 1 if a > 5: print(a, ">", 5) elif a <= 3: print(a, "<=", 3) else: print("neither test was true") and the output: 1 <= 3 2 <= 3 3 <= 3 neither test was true neither test was true 6 > 5 7 > 5 8 > 5 9 > 5 10 > 5 notice how the elif a <= 3 is only tested when the if statement fails to be true. there can be more than one elif expression, allowing multiple tests to be done in a single if statement. examples # this program demonstrates the use of the == operator # using numbers print(5 == 6) # using variables x = 5 y = 8 print(x == y) and the output false false high_low.py # plays the guessing game higher or lower # this should actually be something that is semi random like the # last digits of the time or something else, but that will have to # wait till a later chapter. (extra credit, modify it to be random # after the modules chapter) number = 7 guess = -1 print("guess the number!") while guess != number: guess = int(input("is it... ")) if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") sample run: guess the number! is it... 2 it's bigger... is it... 5 it's bigger... is it... 10 it's not so big. is it... 7 hooray! you guessed it right! even.py # asks for a number. # prints if it is even or odd number = float(input("tell me a number: ")) if number % 2 == 0: print(int(number), "is even.") elif number % 2 == 1: print(int(number), "is odd.") else: print(number, "is very strange.") sample runs: tell me a number: 3 3 is odd. tell me a number: 2 2 is even. tell me a number: 3.4895 3.4895 is very strange. average1.py # keeps asking for numbers until 0 is entered. # prints the average value. count = 0 sum = 0.0 number = 1 # set to something that will not exit the while loop immediately. print("enter 0 to exit the loop") while number != 0: number = float(input("enter a number: ")) if number != 0: count = count + 1 sum = sum + number if number == 0: print("the average was:", sum / count) sample runs sample runs: enter 0 to exit the loop enter a number: 3 enter a number: 5 enter a number: 0 the average was: 4.0 enter 0 to exit the loop enter a number: 1 enter a number: 4 enter a number: 3 enter a number: 0 the average was: 2.66666666667 average2.py # keeps asking for numbers until count numbers have been entered. # prints the average value. #notice that we use an integer to keep track of how many numbers, # but floating point numbers for the input of each number sum = 0.0 print("this program will take several numbers then average them") count = int(input("how many numbers would you like to average: ")) current_count = 0 while current_count < count: current_count = current_count + 1 print("number", current_count) number = float(input("enter a number: ")) sum = sum + number print("the average was:", sum / count) sample runs: this program will take several numbers then average them how many numbers would you like to average: 2 number 1 enter a number: 3 number 2 enter a number: 5 the average was: 4.0 this program will take several numbers then average them how many numbers would you like to average: 3 number 1 enter a number: 1 number 2 enter a number: 4 number 3 enter a number: 3 the average was: 2.66666666667 exercises write a program that asks the user their name, if they enter your name say "that is a nice name", if they enter "john cleese" or "michael palin", tell them how you feel about them ;), otherwise tell them "you have a nice name." solution name = input('your name: ') if name == 'bryn': print('that is a nice name.') elif name == 'john cleese': print('... some funny text.') elif name == 'michael palin': print('... some funny text.') else: print('you have a nice name.') modify the higher or lower program from this section to keep track of how many times the user has entered the wrong number. if it is more than 3 times, print "that must have been complicated." at the end, otherwise print "good job!" solution number = 7 guess = -1 count = 0 print("guess the number!") while guess != number: guess = int(input("is it... ")) count = count + 1 if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") if count > 3: print("that must have been complicated.") else: print("good job!") write a program that asks for two numbers. if the sum of the numbers is greater than 100, print "that is a big number." solution number1 = float(input('1st number: ')) number2 = float(input('2nd number: ')) if number1 + number2 > 100: print('that is a big number.') non-programmer's tutorial for python 3 ← count to 10 print version debugging → 7. debugging what is debugging? "as soon as we started programming, we found to our surprise that it wasn't as easy to get programs right as we had thought. debugging had to be discovered. i can remember the exact instant when i realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs." — maurice wilkes discovers debugging, 1949 by now if you have been messing around with the programs you have probably found that sometimes the program does something you didn't want it to do. this is fairly common. debugging is the process of figuring out what the computer is doing and then getting it to do what you want it to do. this can be tricky. i once spent nearly a week tracking down and fixing a bug that was caused by someone putting an x where a y should have been. this chapter will be more abstract than previous chapters. what should the program do? the first thing to do (this sounds obvious) is to figure out what the program should be doing if it is running correctly. come up with some test cases and see what happens. for example, let's say i have a program to compute the perimeter of a rectangle (the sum of the length of all the edges). i have the following test cases: height width perimeter 3 4 14 2 3 10 4 4 16 2 2 8 5 1 12 i now run my program on all of the test cases and see if the program does what i expect it to do. if it doesn't then i need to find out what the computer is doing. more commonly some of the test cases will work and some will not. if that is the case you should try and figure out what the working ones have in common. for example here is the output for a perimeter program (you get to see the code in a minute): height: 3 width: 4 perimeter = 15 height: 2 width: 3 perimeter = 11 height: 4 width: 4 perimeter = 16 height: 2 width: 2 perimeter = 8 height: 5 width: 1 perimeter = 8 notice that it didn't work for the first two inputs, it worked for the next two and it didn't work on the last one. try and figure out what is in common with the working ones. once you have some idea what the problem is finding the cause is easier. with your own programs you should try more test cases if you need them. what does the program do? the next thing to do is to look at the source code. one of the most important things to do while programming is reading source code. the primary way to do this is code walkthroughs. a code walkthrough starts at the first line, and works its way down until the program is done. while loops and if statements mean that some lines may never be run and some lines are run many times. at each line you figure out what python has done. lets start with the simple perimeter program. don't type it in, you are going to read it, not run it. the source code is: height = int(input("height: ")) width = int(input("width: ")) print("perimeter =", width + height + width + width) question: what is the first line python runs? answer: the first line is always run first. in this case it is: height = int(input("height: ")) what does that line do? prints height: , waits for the user to type a string in, and then converts the string to an integer variable height. what is the next line that runs? in general, it is the next line down which is: width = int(input("width: ")) what does that line do? prints width: , waits for the user to type a number in, and puts what the user types in the variable width. what is the next line that runs? when the next line is not indented more or less than the current line, it is the line right afterwards, so it is: print("perimeter = ", width + height + width + width) (it may also run a function in the current line, but that's a future chapter.) what does that line do? first it prints perimeter = , then it prints the sum of the values contained within the variables, width and height, from width + height + width + width. does width + height + width + width calculate the perimeter properly? let's see, perimeter of a rectangle is the bottom (width) plus the left side (height) plus the top (width) plus the right side (huh?). the last item should be the right side's length, or the height. do you understand why some of the times the perimeter was calculated "correctly"? it was calculated correctly when the width and the height were equal. the next program we will do a code walkthrough for is a program that is supposed to print out 5 dots on the screen. however, this is what the program is outputting: . . . . and here is the program: number = 5 while number > 1: print(".",end=" ") number = number - 1 print() this program will be more complex to walkthrough since it now has indented portions (or control structures). let us begin. what is the first line to be run? the first line of the file: number = 5 what does it do? puts the number 5 in the variable number. what is the next line? the next line is: while number > 1: what does it do? well, while statements in general look at their expression, and if it is true they do the next indented block of code, otherwise they skip the next indented block of code. so what does it do right now? if number > 1 is true then the next two lines will be run. so is number > 1? the last value put into number was 5 and 5 > 1 so yes. so what is the next line? since the while was true the next line is: print(".",end=" ") what does that line do? prints one dot and since the extra argument end=" " exists the next printed text will not be on a different screen line. what is the next line? number = number - 1 since that is following line and there are no indent changes. what does it do? it calculates number - 1, which is the current value of number (or 5) subtracts 1 from it, and makes that the new value of number. so basically it changes number's value from 5 to 4. what is the next line? well, the indent level decreases so we have to look at what type of control structure it is. it is a while loop, so we have to go back to the while clause which is while number > 1: what does it do? it looks at the value of number, which is 4, and compares it to 1 and since 4 > 1 the while loop continues. what is the next line? since the while loop was true, the next line is: print(".",end=" ") what does it do? it prints a second dot on the line, ending by a space. what is the next line? no indent change so it is: number = number - 1 and what does it do? it takes the current value of number (4), subtracts 1 from it, which gives it 3 and then finally makes 3 the new value of number. what is the next line? since there is an indent change caused by the end of the while loop, the next line is: while number > 1: what does it do? it compares the current value of number (3) to 1. 3 > 1 so the while loop continues. what is the next line? since the while loop condition was true the next line is: print(".",end=" ") and it does what? a third dot is printed on the line. what is the next line? it is: number = number - 1 what does it do? it takes the current value of number (3) subtracts from it 1 and makes the 2 the new value of number. what is the next line? back up to the start of the while loop: while number > 1: what does it do? it compares the current value of number (2) to 1. since 2 > 1 the while loop continues. what is the next line? since the while loop is continuing: print(".",end=" ") what does it do? it discovers the meaning of life, the universe and everything. i'm joking. (i had to make sure you were awake.) the line prints a fourth dot on the screen. what is the next line? it's: number = number - 1 what does it do? takes the current value of number (2) subtracts 1 and makes 1 the new value of number. what is the next line? back up to the while loop: while number > 1: what does the line do? it compares the current value of number (1) to 1. since 1 > 1 is false (one is not greater than one), the while loop exits. what is the next line? since the while loop condition was false the next line is the line after the while loop exits, or: print() what does that line do? makes the screen go to the next line. why doesn't the program print 5 dots? the loop exits 1 dot too soon. how can we fix that? make the loop exit 1 dot later. and how do we do that? there are several ways. one way would be to change the while loop to: while number > 0: another way would be to change the conditional to: number >= 1 there are a couple others. how do i fix my program? you need to figure out what the program is doing. you need to figure out what the program should do. figure out what the difference between the two is. debugging is a skill that has to be practiced to be learned. if you can't figure it out after an hour, take a break, talk to someone about the problem or contemplate the lint in your navel. come back in a while and you will probably have new ideas about the problem. good luck. non-programmer's tutorial for python 3 ← decisions print version defining functions → 8. defining functions creating functions to start off this chapter i am going to give you an example of what you could do but shouldn't (so don't type it in): a = 23 b = -23 if a < 0: a = -a if b < 0: b = -b if a == b: print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and 23 are equal. the program seems a little repetitive. programmers hate to repeat things -- that's what computers are for, after all! (note also that finding the absolute value changed the value of the variable, which is why it is printing out 23, and not -23 in the output.) fortunately python allows you to create functions to remove duplication. here is the rewritten example: a = 23 b = -23 def absolute_value(n): if n < 0: n = -n return n if absolute_value(a) == absolute_value(b): print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and -23 are equal. the key feature of this program is the def statement. def (short for define) starts a function definition. def is followed by the name of the function absolute_value. next comes a '(' followed by the parameter n (n is passed from the program into the function when the function is called). the statements after the ':' are executed when the function is used. the statements continue until either the indented statements end or a return is encountered. the return statement returns a value back to the place where the function was called. we already have encountered a function in our very first program, the print function. now we can make new functions. notice how the values of a and b are not changed. functions can be used to repeat tasks that don't return values. here are some examples: def hello(): print("hello") def area(width, height): return width * height def print_welcome(name): print("welcome", name) hello() hello() print_welcome("fred") w = 4 h = 5 print("width =", w, " height =", h, " area =", area(w, h)) with output being: hello hello welcome fred width = 4 height = 5 area = 20 that example shows some more stuff that you can do with functions. notice that you can use no arguments or two or more. notice also when a function doesn't need to send back a value, a return is optional. variables in functions when eliminating repeated code, you often have variables in the repeated code. in python, these are dealt with in a special way. so far all variables we have seen are global variables. functions have a special type of variable called local variables. these variables only exist while the function is running. when a local variable has the same name as another variable (such as a global variable), the local variable hides the other. sound confusing? well, these next examples (which are a bit contrived) should help clear things up. a = 4 def print_func(): a = 17 print("in print_func a =", a) print_func() print("a = ", a) when run, we will receive an output of: in print_func a = 17 a = 4 variable assignments inside a function do not override global variables, they exist only inside the function. even though a was assigned a new value inside the function, this newly assigned value was only relevant to print_func, when the function finishes running, and the a's values is printed again, we see the originally assigned values. here is another more complex example. a_var = 10 b_var = 15 e_var = 25 def a_func(a_var): print("in a_func a_var =", a_var) b_var = 100 + a_var d_var = 2 * a_var print("in a_func b_var =", b_var) print("in a_func d_var =", d_var) print("in a_func e_var =", e_var) return b_var + 10 c_var = a_func(b_var) print("a_var =", a_var) print("b_var =", b_var) print("c_var =", c_var) print("d_var =", d_var) output: in a_func a_var = 15 in a_func b_var = 115 in a_func d_var = 30 in a_func e_var = 25 a_var = 10 b_var = 15 c_var = 125 d_var = traceback (most recent call last): file "c:\def2.py", line 19, in <module> print("d_var = ", d_var) nameerror: name 'd_var' is not defined in this example the variables a_var, b_var, and d_var are all local variables when they are inside the function a_func. after the statement return b_var + 10 is run, they all cease to exist. the variable a_var is automatically a local variable since it is a parameter name. the variables b_var and d_var are local variables since they appear on the left of an equals sign in the function in the statements b_var = 100 + a_var and d_var = 2 * a_var . inside of the function a_var has no value assigned to it. when the function is called with c_var = a_func(b_var), 15 is assigned to a_var since at that point in time b_var is 15, making the call to the function a_func(15). this ends up setting a_var to 15 when it is inside of a_func. as you can see, once the function finishes running, the local variables a_var and b_var that had hidden the global variables of the same name are gone. then the statement print("a_var = ", a_var) prints the value 10 rather than the value 15 since the local variable that hid the global variable is gone. another thing to notice is the nameerror that happens at the end. this appears since the variable d_var no longer exists since a_func finished. all the local variables are deleted when the function exits. if you want to get something from a function, then you will have to use return something. one last thing to notice is that the value of e_var remains unchanged inside a_func since it is not a parameter and it never appears on the left of an equals sign inside of the function a_func. when a global variable is accessed inside a function it is the global variable from the outside. functions allow local variables that exist only inside the function and can hide other variables that are outside the function. examples temperature2.py #! /usr/bin/python #-*-coding: utf-8 -*- # converts temperature to fahrenheit or celsius def print_options(): print("options:") print(" 'p' print options") print(" 'c' convert from celsius") print(" 'f' convert from fahrenheit") print(" 'q' quit the program") def celsius_to_fahrenheit(c_temp): return 9.0 / 5.0 * c_temp + 32 def fahrenheit_to_celsius(f_temp): return (f_temp - 32.0) * 5.0 / 9.0 choice = "p" while choice != "q": if choice == "c": c_temp = float(input("celsius temperature: ")) print("fahrenheit:", celsius_to_fahrenheit(c_temp)) choice = input("option: ") elif choice == "f": f_temp = float(input("fahrenheit temperature: ")) print("celsius:", fahrenheit_to_celsius(f_temp)) choice = input("option: ") else: choice = "p" #alternatively choice != "q": so that print #when anything unexpected inputed print_options() choice = input("option: ") sample run: options: 'p' print options 'c' convert from celsius 'f' convert from fahrenheit 'q' quit the program option: c celsius temperature: 30 fahrenheit: 86.0 option: f fahrenheit temperature: 60 celsius: 15.5555555556 option: q area2.py #! /usr/bin/python #-*-coding: utf-8 -*- # calculates a given rectangle area def hello(): print('hello!') def area(width, height): return width * height def print_welcome(name): print('welcome,', name) def positive_input(prompt): number = float(input(prompt)) while number <= 0: print('must be a positive number') number = float(input(prompt)) return number name = input('your name: ') hello() print_welcome(name) print() print('to find the area of a rectangle,') print('enter the width and height below.') print() w = positive_input('width: ') h = positive_input('height: ') print('width =', w, ' height =', h, ' so area =', area(w, h)) sample run: your name: josh hello! welcome, josh to find the area of a rectangle, enter the width and height below. width: -4 must be a positive number width: 4 height: 3 width = 4 height = 3 so area = 12 exercises rewrite the area2.py program from the examples above to have a separate function for the area of a square, the area of a rectangle, and the area of a circle (3.14 * radius**2). this program should include a menu interface. solution def square(l): return l * l def rectangle(width , height): return width * height def circle(radius): return 3.14159 * radius ** 2 def options(): print() print("options:") print("s = calculate the area of a square.") print("c = calculate the area of a circle.") print("r = calculate the area of a rectangle.") print("q = quit") print() print("this program will calculate the area of a square, circle or rectangle.") choice = "x" options() while choice != "q": choice = input("please enter your choice: ") if choice == "s": l = float(input("length of square side: ")) print("the area of this square is", square(l)) options() elif choice == "c": radius = float(input("radius of the circle: ")) print("the area of the circle is", circle(radius)) options() elif choice == "r": width = float(input("width of the rectangle: ")) height = float(input("height of the rectangle: ")) print("the area of the rectangle is", rectangle(width, height)) options() elif choice == "q": print(" ",end="") else: print("unrecognized option.") options() non-programmer's tutorial for python 3 ← debugging print version advanced functions example → 9. advanced functions example some people find this section useful, and some find it confusing. if you find it confusing you can skip it. now we will do a walk through for the following program: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value result = mult(3, 2) print("3 * 2 = ", result) basically this program creates a positive integer multiplication function (that is far slower than the built in multiplication function) and then demonstrates this function with a use of the function. this program demonstrates the use of recursion, that is a form of iteration (repetition) in which there is a function that repeatedly calls itself until an exit condition is satisfied. it uses repeated additions to give the same result as mutiplication: e.g. 3 + 3 (addition) gives the same result as 3 * 2 (multiplication). question: what is the first thing the program does? answer: the first thing done is the function mult is defined with the lines: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value this creates a function that takes two parameters and returns a value when it is done. later this function can be run. what happens next? the next line after the function, result = mult(3, 2) is run. what does this line do? this line will assign the return value of mult(3, 2) to the variable result. and what does mult(3, 2) return? we need to do a walkthrough of the mult function to find out. what happens next? the variable a gets the value 3 assigned to it and the variable b gets the value 2 assigned to it. and then? the line if b == 0: is run. since b has the value 2 this is false so the line return 0 is skipped. and what then? the line rest = mult(a, b - 1) is run. this line sets the local variable rest to the value of mult(a, b - 1). the value of a is 3 and the value of b is 2 so the function call is mult(3,1) so what is the value of mult(3, 1) ? we will need to run the function mult with the parameters 3 and 1. so what happens next? the local variables in the new run of the function are set so that a has the value 3 and b has the value 1. since these are local values these do not affect the previous values of a and b. and then? since b has the value 1 the if statement is false, so the next line becomes rest = mult(a, b - 1). what does this line do? this line will assign the value of mult(3, 0) to rest. so what is that value? we will have to run the function one more time to find that out. this time a has the value 3 and b has the value 0. so what happens next? the first line in the function to run is if b == 0:. b has the value 0 so the next line to run is return 0 and what does the line return 0 do? this line returns the value 0 out of the function. so? so now we know that mult(3, 0) has the value 0. now we know what the line rest = mult(a, b - 1) did since we have run the function mult with the parameters 3 and 0. we have finished running mult(3, 0) and are now back to running mult(3, 1). the variable rest gets assigned the value 0. what line is run next? the line value = a + rest is run next. in this run of the function, a = 3 and rest = 0 so now value = 3. what happens next? the line return value is run. this returns 3 from the function. this also exits from the run of the function mult(3, 1). after return is called, we go back to running mult(3, 2). where were we in mult(3, 2)? we had the variables a = 3 and b = 2 and were examining the line rest = mult(a, b - 1). so what happens now? the variable rest get 3 assigned to it. the next line value = a + rest sets value to 3 + 3 or 6. so now what happens? the next line runs, this returns 6 from the function. we are now back to running the line result = mult(3, 2) which can now assign the value 6 to the variable result. what happens next? the next line after the function, print("3 * 2 = ", result) is run. and what does this do? it prints 3 * 2 = and the value of result which is 6. the complete line printed is 3 * 2 = 6. what is happening overall? basically we used two facts to calculate the multiple of the two numbers. the first is that any number times 0 is 0 (x * 0 = 0). the second is that a number times another number is equal to the first number plus the first number times one less than the second number (x * y = x + x * (y - 1)). so what happens is 3 * 2 is first converted into 3 + 3 * 1. then 3 * 1 is converted into 3 + 3 * 0. then we know that any number times 0 is 0 so 3 * 0 is 0. then we can calculate that 3 + 3 * 0 is 3 + 0 which is 3. now we know what 3 * 1 is so we can calculate that 3 + 3 * 1 is 3 + 3 which is 6. this is how the whole thing works: mult(3, 2) 3 + mult(3, 1) 3 + 3 + mult(3, 0) 3 + 3 + 0 3 + 3 6 recursion programming constructs solving a problem by solving a smaller version of the same problem are called recursive. in the examples in this chapter, recursion is realized by defining a function calling itself. this facilitates implementing solutions to programming tasks as it may be sufficient to consider the next step of a problem instead of the whole problem at once. it is also useful as it allows to express some mathematical concepts with straightforward, easy to read code. any problem that can be solved with recursion could be re-implemented with loops. using the latter usually results in better performance. however equivalent implementations using loops are usually harder to get done correctly. probably the most intuitive definition of recursion is: recursion if you still don't get it, see recursion. try walking through the factorial example if the multiplication example did not make sense. examples factorial.py #defines a function that calculates the factorial def factorial(n): if n == 0: return 1 if n<0: return "error, negative numbers do not have factorial values!!" return n * factorial(n - 1) print("2! =", factorial(2)) print("3! =", factorial(3)) print("4! =", factorial(4)) print("5! =", factorial(5)) print("-3! =", factorial(-3)) output: 2! = 2 3! = 6 4! = 24 5! = 120 -3! = error, negative values do not have factorial values!! countdown.py def count_down(n): print(n) if n > 0: return count_down(n-1) count_down(5) output: 5 4 3 2 1 0 non-programmer's tutorial for python 3 ← defining functions print version lists → 10. lists variables with more than one value you have already seen ordinary variables that store a single value. however other variable types can hold more than one value. these are called containers because they can contain more than one object. the simplest type is called a list. here is an example of a list being used: which_one = int(input("what month (1-12)? ")) months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'] if 1 <= which_one <= 12: print("the month is", months[which_one - 1]) and an output example: what month (1-12)? 3 the month is march in this example the months is a list. months is defined with the lines months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', and 'august', 'september', 'october', 'november', 'december'] (note that a \ could also be used to split a long line, but that is not necessary in this case because python is intelligent enough to recognize that everything within brackets belongs together). the [ and ] start and end the list with commas (,) separating the list items. the list is used in months[which_one - 1]. a list consists of items that are numbered starting at 0. in other words if you wanted january you would use months[0]. give a list a number and it will return the value that is stored at that location. the statement if 1 <= which_one <= 12: will only be true if which_one is between one and twelve inclusive (in other words it is what you would expect if you have seen that in algebra). lists can be thought of as a series of boxes. each box has a different value. for example, the boxes created by demolist = ['life', 42, 'the universe', 6, 'and', 9] would look like this: box number 0 1 2 3 4 5 demolist "life" 42 "the universe" 6 "and" 9 each box is referenced by its number so the statement demolist[0] would get 'life', demolist[1] would get 42 and so on up to demolist[5] getting 9. more features of lists the next example is just to show a lot of other stuff lists can do (for once i don't expect you to type it in, but you should probably play around with lists in interactive mode until you are comfortable with them.). here goes: demolist = ["life", 42, "the universe", 6, "and", 9] print("demolist = ",demolist) demolist.append("everything") print("after 'everything' was appended demolist is now:") print(demolist) print("len(demolist) =", len(demolist)) print("demolist.index(42) =", demolist.index(42)) print("demolist[1] =", demolist[1]) # next we will loop through the list for c in range(len(demolist)): print("demolist[", c, "] =", demolist[c]) del demolist[2] print("after 'the universe' was removed demolist is now:") print(demolist) if "life" in demolist: print("'life' was found in demolist") else: print("'life' was not found in demolist") if "amoeba" in demolist: print("'amoeba' was found in demolist") if "amoeba" not in demolist: print("'amoeba' was not found in demolist") another_list = [42,7,0,123] another_list.sort() print("the sorted another_list is", another_list) the output is: demolist = ['life', 42, 'the universe', 6, 'and', 9] after 'everything' was appended demolist is now: ['life', 42, 'the universe', 6, 'and', 9, 'everything'] len(demolist) = 7 demolist.index(42) = 1 demolist[1] = 42 demolist[ 0 ] = life demolist[ 1 ] = 42 demolist[ 2 ] = the universe demolist[ 3 ] = 6 demolist[ 4 ] = and demolist[ 5 ] = 9 demolist[ 6 ] = everything after 'the universe' was removed demolist is now: ['life', 42, 6, 'and', 9, 'everything'] 'life' was found in demolist 'amoeba' was not found in demolist the sorted another_list is [0, 7, 42, 123] this example uses a whole bunch of new functions. notice that you can just print a whole list. next the append function is used to add a new item to the end of the list. len returns how many items are in a list. the valid indexes (as in numbers that can be used inside of the []) of a list range from 0 to len - 1. the index function tells where the first location of an item is located in a list. notice how demolist.index(42) returns 1, and when demolist[1] is run it returns 42. to get help on all the functions a list provides for you, type help(list) in the interactive python interpreter. the line # next we will loop through the list is a just a reminder to the programmer (also called a comment). python ignores everything that is written after a # on the current line. next the lines: for c in range(len(demolist)): print('demolist[', c, '] =', demolist[c]) create a variable c, which starts at 0 and is incremented until it reaches the last index of the list. meanwhile the print statement prints out each element of the list. a much better way to do the above is: for c, x in enumerate(demolist): print("demolist[", c, "] =", x) the del command can be used to remove a given element in a list. the next few lines use the in operator to test if an element is in or is not in a list. the sort function sorts the list. this is useful if you need a list in order from smallest number to largest or alphabetical. note that this rearranges the list. in summary, for a list, the following operations occur: example explanation demolist[2] accesses the element at index 2 demolist[2] = 3 sets the element at index 2 to be 3 del demolist[2] removes the element at index 2 len(demolist) returns the length of demolist "value" in demolist is true if "value" is an element in demolist "value" not in demolist is true if "value" is not an element in demolist another_list.sort() sorts another_list. note that the list must be all numbers or all strings to be sorted. demolist.index("value") returns the index of the first place that "value" occurs demolist.append("value") adds an element "value" at the end of the list demolist.remove("value") removes the first occurrence of value from demolist (same as del demolist[demolist.index("value")]) this next example uses these features in a more useful way: menu_item = 0 namelist = [] while menu_item != 9: print("--------------------") print("1. print the list") print("2. add a name to the list") print("3. remove a name from the list") print("4. change an item in the list") print("9. quit") menu_item = int(input("pick an item from the menu: ")) if menu_item == 1: current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") elif menu_item == 2: name = input("type in a name to add: ") namelist.append(name) elif menu_item == 3: del_name = input("what name would you like to remove: ") if del_name in namelist: # namelist.remove(del_name) would work just as fine item_number = namelist.index(del_name) del namelist[item_number] # the code above only removes the first occurrence of # the name. the code below from gerald removes all. # while del_name in namelist: # item_number = namelist.index(del_name) # del namelist[item_number] else: print(del_name, "was not found") elif menu_item == 4: old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") print("goodbye") and here is part of the output: -------------------- 1. print the list 2. add a name to the list 3. remove a name from the list 4. change an item in the list 9. quit pick an item from the menu: 2 type in a name to add: jack pick an item from the menu: 2 type in a name to add: jill pick an item from the menu: 1 0 . jack 1 . jill pick an item from the menu: 3 what name would you like to remove: jack pick an item from the menu: 4 what name would you like to change: jill what is the new name: jill peters pick an item from the menu: 1 0 . jill peters pick an item from the menu: 9 goodbye that was a long program. let's take a look at the source code. the line namelist = [] makes the variable namelist a list with no items (or elements). the next important line is while menu_item != 9:. this line starts a loop that allows the menu system for this program. the next few lines display a menu and decide which part of the program to run. the section current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") goes through the list and prints each name. len(namelist) tells how many items are in the list. if len returns 0, then the list is empty. then, a few lines later, the statement namelist.append(name) appears. it uses the append function to add an item to the end of the list. jump down another two lines, and notice this section of code: item_number = namelist.index(del_name) del namelist[item_number] here the index function is used to find the index value that will be used later to remove the item. del namelist[item_number] is used to remove an element of the list. the next section old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") uses index to find the item_number and then puts new_name where the old_name was. congratulations, with lists under your belt, you now know enough of the language that you could do any computations that a computer can do (this is technically known as turing-completeness). of course, there are still many features that are used to make your life easier. examples test.py ## this program runs a test of knowledge # first get the test questions # later this will be modified to use file io. def get_questions(): # notice how the data is stored as a list of lists return [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list # this function takes a list with two elements, a question and an answer. question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the tester's answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question #note that this is extracting a question and answer list from the list of lists. if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions),\ "% right out of", len(questions)) # now let's get the questions from the get_questions function, and # send the returned list of lists as an argument to the run_test function. run_test(get_questions()) the values true and false point to 1 and 0, respectively. they are often used in sanity checks, loop conditions etc. you will learn more about this a little bit later (chapter boolean expressions). please note that get_questions() is essentially a list because even though it's technically a function, returning a list of lists is the only thing it does. sample output: what color is the daytime sky on a clear day? green incorrect, correct was: blue what is the answer to life, the universe and everything? 42 correct what is a three letter word for mouse trap? cat correct you got 66 % right out of 3 exercises expand the test.py program so it has a menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". solution expand the test.py program so it has menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". ## this program runs a test of knowledge questions = [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"], ["what noise does a truly advanced machine make?", "ping"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the testers answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions), "% right out of", len(questions)) #showing a list of questions and answers def showquestions(): q = 0 while q < len(questions): a = 0 print("q:" , questions[q][a]) a = 1 print("a:" , questions[q][a]) q = q + 1 # now let's define the menu function def menu(): print("-----------------") print("menu:") print("1 - take the test") print("2 - view a list of questions and answers") print("3 - view the menu") print("5 - quit") print("-----------------") choice = "3" while choice != "5": if choice == "1": run_test(questions) elif choice == "2": showquestions() elif choice == "3": menu() print() choice = input("choose your option from the menu above: ") non-programmer's tutorial for python 3 ← advanced functions example print version for loops → 11. for loops and here is the new typing exercise for this chapter: onetoten = range(1, 11) for count in onetoten: print(count) and the ever-present output: 1 2 3 4 5 6 7 8 9 10 the output looks awfully familiar but the program code looks different. the first line uses the range function. the range function uses two arguments like this range(start, finish). start is the first number that is produced. finish is one larger than the last number. note that this program could have been done in a shorter way: for count in range(1, 11): print(count) the range function returns an iterable. this can be converted into a list with the list function. which will then be the dominant number. here are some examples to show what happens with the range command: >>> range(1, 10) range(1, 10) >>> list(range(1, 10)) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(-32, -20)) [-32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21] >>> list(range(5,21)) [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] >>> list(range(5)) [0, 1, 2, 3, 4] >>> list(range(21, 5)) [] the next line for count in onetoten: uses the for control structure. a for control structure looks like for variable in list:. list is gone through starting with the first element of the list and going to the last. as for goes through each element in a list it puts each into variable. that allows variable to be used in each successive time the for loop is run through. here is another example (you don't have to type this) to demonstrate: demolist = ['life', 42, 'the universe', 6, 'and', 7, 'everything'] for item in demolist: print("the current item is:",item) the output is: the current item is: life the current item is: 42 the current item is: the universe the current item is: 6 the current item is: and the current item is: 7 the current item is: everything notice how the for loop goes through and sets item to each element in the list. so, what is for good for? the first use is to go through all the elements of a list and do something with each of them. here's a quick way to add up all the elements: list = [2, 4, 6, 8] sum = 0 for num in list: sum = sum + num print("the sum is:", sum) with the output simply being: the sum is: 20 or you could write a program to find out if there are any duplicates in a list like this program does: list = [4, 5, 7, 8, 9, 1, 0, 7, 10] list.sort() prev = none for item in list: if prev == item: print("duplicate of", prev, "found") prev = item and for good measure: duplicate of 7 found okay, so how does it work? here is a special debugging version to help you understand (you don't need to type this in): l = [4, 5, 7, 8, 9, 1, 0, 7, 10] print("l = [4, 5, 7, 8, 9, 1, 0, 7, 10]", "\t\tl:", l) l.sort() print("l.sort()", "\t\tl:", l) prev = l[0] print("prev = l[0]", "\t\tprev:", prev) del l[0] print("del l[0]", "\t\tl:", l) for item in l: if prev == item: print("duplicate of", prev, "found") print("if prev == item:", "\t\tprev:", prev, "\titem:", item) prev = item print("prev = item", "\t\tprev:", prev, "\titem:", item) with the output being: l = [4, 5, 7, 8, 9, 1, 0, 7, 10] l: [4, 5, 7, 8, 9, 1, 0, 7, 10] l.sort() l: [0, 1, 4, 5, 7, 7, 8, 9, 10] prev = l[0] prev: 0 del l[0] l: [1, 4, 5, 7, 7, 8, 9, 10] if prev == item: prev: 0 item: 1 prev = item prev: 1 item: 1 if prev == item: prev: 1 item: 4 prev = item prev: 4 item: 4 if prev == item: prev: 4 item: 5 prev = item prev: 5 item: 5 if prev == item: prev: 5 item: 7 prev = item prev: 7 item: 7 duplicate of 7 found if prev == item: prev: 7 item: 7 prev = item prev: 7 item: 7 if prev == item: prev: 7 item: 8 prev = item prev: 8 item: 8 if prev == item: prev: 8 item: 9 prev = item prev: 9 item: 9 if prev == item: prev: 9 item: 10 prev = item prev: 10 item: 10 the reason i put so many print statements in the code was so that you can see what is happening in each line. (by the way, if you can't figure out why a program is not working, try putting in lots of print statements in places where you want to know what is happening.) first the program starts with a boring old list. next the program sorts the list. this is so that any duplicates get put next to each other. the program then initializes a prev(ious) variable. next the first element of the list is deleted so that the first item is not incorrectly thought to be a duplicate. next a for loop is gone into. each item of the list is checked to see if it is the same as the previous. if it is a duplicate was found. the value of prev is then changed so that the next time the for loop is run through prev is the previous item to the current. sure enough, the 7 is found to be a duplicate. (notice how \t is used to print a tab.) the other way to use for loops is to do something a certain number of times. here is some code to print out the first 9 numbers of the fibonacci series: a = 1 b = 1 for c in range(1, 10): print(a, end=" ") n = a + b a = b b = n with the surprising output: 1 1 2 3 5 8 13 21 34 everything that can be done with for loops can also be done with while loops but for loops give an easy way to go through all the elements in a list or to do something a certain number of times. non-programmer's tutorial for python 3 ← lists print version boolean expressions → 12. boolean expressions here is a little example of boolean expressions (you don't have to type it in): a = 6 b = 7 c = 42 print(1, a == 6) print(2, a == 7) print(3, a == 6 and b == 7) print(4, a == 7 and b == 7) print(5, not a == 7 and b == 7) print(6, a == 7 or b == 7) print(7, a == 7 or b == 6) print(8, not (a == 7 and b == 6)) print(9, not a == 7 and b == 6) with the output being: 1 true 2 false 3 true 4 false 5 true 6 true 7 false 8 true 9 false what is going on? the program consists of a bunch of funny looking print statements. each print statement prints a number and an expression. the number is to help keep track of which statement i am dealing with. notice how each expression ends up being either false or true. in python false can also be written as 0 and true as 1. the lines: print(1, a == 6) print(2, a == 7) print out a true and a false respectively just as expected since the first is true and the second is false. the third print, print(3, a == 6 and b == 7), is a little different. the operator and means if both the statement before and the statement after are true then the whole expression is true otherwise the whole expression is false. the next line, print(4, a == 7 and b == 7), shows how if part of an and expression is false, the whole thing is false. the behavior of and can be summarized as follows: expression result true and true true true and false false false and true false false and false false notice that if the first expression is false python does not check the second expression since it knows the whole expression is false. try running false and print("hi") and compare this to running true and print("hi") the technical term for this is short-circuit evaluation the next line, print(5, not a == 7 and b == 7), uses the not operator. not just gives the opposite of the expression. (the expression could be rewritten as print(5, a != 7 and b == 7)). here is the table: expression result not true false not false true the two following lines, print(6, a == 7 or b == 7) and print(7, a == 7 or b == 6), use the or operator. the or operator returns true if the first expression is true, or if the second expression is true or both are true. if neither are true it returns false. here's the table: expression result true or true true true or false true false or true true false or false false notice that if the first expression is true python doesn't check the second expression since it knows the whole expression is true. this works since or is true if at least one half of the expression is true. the first part is true so the second part could be either false or true, but the whole expression is still true. the next two lines, print(8, not (a == 7 and b == 6)) and print(9, not a == 7 and b == 6), show that parentheses can be used to group expressions and force one part to be evaluated first. notice that the parentheses changed the expression from false to true. this occurred since the parentheses forced the not to apply to the whole expression instead of just the a == 7 portion. here is an example of using a boolean expression: list = ["life", "the universe", "everything", "jack", "jill", "life", "jill"] # make a copy of the list. see the more on lists chapter to explain what [:] means. copy = list[:] # sort the copy copy.sort() prev = copy[0] del copy[0] count = 0 # go through the list searching for a match while count < len(copy) and copy[count] != prev: prev = copy[count] count = count + 1 # if a match was not found then count can't be < len # since the while loop continues while count is < len # and no match is found if count < len(copy): print("first match:", prev) and here is the output: first match: jill this program works by continuing to check for match while count < len(copy) and copy[count] is not equal to prev. when either count is greater than the last index of copy or a match has been found the and is no longer true so the loop exits. the if simply checks to make sure that the while exited because a match was found. the other "trick" of and is used in this example. if you look at the table for and notice that the third entry is "false and false". if count >= len(copy) (in other words count < len(copy) is false) then copy[count] is never looked at. this is because python knows that if the first is false then they can't both be true. this is known as a short circuit and is useful if the second half of the and will cause an error if something is wrong. i used the first expression (count < len(copy)) to check and see if count was a valid index for copy. (if you don't believe me remove the matches "jill" and "life", check that it still works and then reverse the order of count < len(copy) and copy[count] != prev to copy[count] != prev and count < len(copy).) boolean expressions can be used when you need to check two or more different things at once. a note on boolean operators a common mistake for people new to programming is a misunderstanding of the way that boolean operators works, which stems from the way the python interpreter reads these expressions. for example, after initially learning about "and " and "or" statements, one might assume that the expression x == ('a' or 'b') would check to see if the variable x was equivalent to one of the strings 'a' or 'b'. this is not so. to see what i'm talking about, start an interactive session with the interpreter and enter the following expressions: >>> 'a' == ('a' or 'b') >>> 'b' == ('a' or 'b') >>> 'a' == ('a' and 'b') >>> 'b' == ('a' and 'b') and this will be the unintuitive result: >>> 'a' == ('a' or 'b') true >>> 'b' == ('a' or 'b') false >>> 'a' == ('a' and 'b') false >>> 'b' == ('a' and 'b') true at this point, the and and or operators seem to be broken. it doesn't make sense that, for the first two expressions, 'a' is equivalent to 'a' or 'b' while 'b' is not. furthermore, it doesn't make any sense that 'b' is equivalent to 'a' and 'b'. after examining what the interpreter does with boolean operators, these results do in fact exactly what you are asking of them, it's just not the same as what you think you are asking. when the python interpreter looks at an or expression, it takes the first statement and checks to see if it is true. if the first statement is true, then python returns that object's value without checking the second statement. this is because for an or expression, the whole thing is true if one of the values is true; the program does not need to bother with the second statement. on the other hand, if the first value is evaluated as false python checks the second half and returns that value. that second half determines the truth value of the whole expression since the first half was false. this "laziness" on the part of the interpreter is called "short circuiting" and is a common way of evaluating boolean expressions in many programming languages. similarly, for an and expression, python uses a short circuit technique to speed truth value evaluation. if the first statement is false then the whole thing must be false, so it returns that value. otherwise if the first value is true it checks the second and returns that value. one thing to note at this point is that the boolean expression returns a value indicating true or false, but that python considers a number of different things to have a truth value assigned to them. to check the truth value of any given object x, you can use the function bool(x) to see its truth value. below is a table with examples of the truth values of various objects: true false true false 1 0 numbers other than zero the string 'none' nonempty strings empty strings nonempty lists empty lists nonempty dictionaries empty dictionaries now it is possible to understand the perplexing results we were getting when we tested those boolean expressions before. let's take a look at what the interpreter "sees" as it goes through that code: first case: >>> 'a' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'a' == 'a' # the string 'a' is equivalent to the string 'a', so expression is true true second case: >>> 'b' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'b' == 'a' # the string 'b' is not equivalent to the string 'a', so expression is false false third case: >>> 'a' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'a' == 'b' # the string 'a' is not equivalent to the string 'b', so expression is false false fourth case: >>> 'b' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'b' == 'b' # the string 'b' is equivalent to the string 'b', so expression is true true so python was really doing its job when it gave those apparently bogus results. as mentioned previously, the important thing is to recognize what value your boolean expression will return when it is evaluated, because it isn't always obvious. going back to those initial expressions, this is how you would write them out so they behaved in a way that you want: >>> 'a' == 'a' or 'a' == 'b' true >>> 'b' == 'a' or 'b' == 'b' true >>> 'a' == 'a' and 'a' == 'b' false >>> 'b' == 'a' and 'b' == 'b' false when these comparisons are evaluated they return truth values in terms of true or false, not strings, so we get the proper results. examples password1.py ## this program asks a user for a name and a password. # it then checks them to make sure that the user is allowed in. name = input("what is your name? ") password = input("what is the password? ") if name == "josh" and password == "friday": print("welcome josh") elif name == "fred" and password == "rock": print("welcome fred") else: print("i don't know you.") sample runs what is your name? josh what is the password? friday welcome josh what is your name? bill what is the password? money i don't know you. exercises write a program that has a user guess your name, but they only get 3 chances to do so until the program quits. solution print("try to guess my name!") count = 1 name = "guilherme" guess = input("what is my name? ") while count < 3 and guess.lower() != name: # .lower allows things like guilherme to still match print("you are wrong!") guess = input("what is my name? ") count = count + 1 if guess.lower() != name: print("you are wrong!") # this message isn't printed in the third chance, so we print it now print("you ran out of chances.") else: print("yes! my name is", name + "!") non-programmer's tutorial for python 3 ← for loops print version dictionaries → 13. dictionaries this chapter is about dictionaries. dictionaries have keys and values. the keys are used to find the values. here is an example of a dictionary in use: def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() and here is my output: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. quit type in a number (1-5): 2 add name and number name: joe number: 545-4464 type in a number (1-5): 2 add name and number name: jill number: 979-4654 type in a number (1-5): 2 add name and number name: fred number: 132-9874 type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 name: fred number: 132-9874 type in a number (1-5): 4 lookup number name: joe the number is 545-4464 type in a number (1-5): 3 remove name and number name: fred type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 type in a number (1-5): 5 this program is similar to the name list earlier in the chapter on lists. here's how the program works. first the function print_menu is defined. print_menu just prints a menu that is later used twice in the program. next comes the funny looking line numbers = {}. all that this line does is to tell python that numbers is a dictionary. the next few lines just make the menu work. the lines for x in numbers.keys(): print("name:", x, "\tnumber:", numbers[x]) go through the dictionary and print all the information. the function numbers.keys() returns a list that is then used by the for loop. the list returned by keys() is not in any particular order so if you want it in alphabetic order it must be sorted. similar to lists the statement numbers[x] is used to access a specific member of the dictionary. of course in this case x is a string. next the line numbers[name] = phone adds a name and phone number to the dictionary. if name had already been in the dictionary phone would replace whatever was there before. next the lines if name in numbers: del numbers[name] see if a name is in the dictionary and remove it if it is. the operator name in numbers returns true if name is in numbers but otherwise returns false. the line del numbers[name] removes the key name and the value associated with that key. the lines if name in numbers: print("the number is", numbers[name]) check to see if the dictionary has a certain key and if it does prints out the number associated with it. lastly if the menu choice is invalid it reprints the menu for your viewing pleasure. a recap: dictionaries have keys and values. keys can be strings or numbers. keys point to values. values can be any type of variable (including lists or even dictionaries (those dictionaries or lists of course can contain dictionaries or lists themselves (scary right? :-) ))). here is an example of using a list in a dictionary: max_points = [25, 25, 50, 25, 100] assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = {'#max': max_points} def print_menu(): print("1. add student") print("2. remove student") print("3. print grades") print("4. record grade") print("5. print menu") print("6. exit") def print_all_grades(): print('\t', end=' ') for i in range(len(assignments)): print(assignments[i], '\t', end=' ') print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) def print_grades(grades): for i in range(len(grades)): print(grades[i], '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 6: print() menu_choice = int(input("menu choice (1-6): ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(max_points) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: print_all_grades() elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i in range(len(assignments)): print(i + 1, assignments[i], '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 #same as which = which - 1 if 0 <= which < len(grades): grade = int(input("grade: ")) grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice != 6: print_menu() and here is a sample output: 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 menu choice (1-6): 5 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 1 student to add: bill menu choice (1-6): 4 record grade student: bill type in the number of the grade to record type a 0 (zero) to exit 1 hw ch 1 2 hw ch 2 3 quiz 4 hw ch 3 5 test 0 0 0 0 0 change which grade: 1 grade: 25 change which grade: 2 grade: 24 change which grade: 3 grade: 45 change which grade: 4 grade: 23 change which grade: 5 grade: 95 change which grade: 0 menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 bill 25 24 45 23 95 menu choice (1-6): 6 heres how the program works. basically the variable students is a dictionary with the keys being the name of the students and the values being their grades. the first two lines just create two lists. the next line students = {'#max': max_points} creates a new dictionary with the key {#max} and the value is set to be [25, 25, 50, 25, 100] (since thats what max_points was when the assignment is made) (i use the key #max since # is sorted ahead of any alphabetic characters). next print_menu is defined. next the print_all_grades function is defined in the lines: def print_all_grades(): print('\t',end=" ") for i in range(len(assignments)): print(assignments[i], '\t',end=" ") print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t',end=' ') grades = students[x] print_grades(grades) notice how first the keys are gotten out of the students dictionary with the keys function in the line keys = list(students.keys()). keys is an iterable, and it is converted to list so all the functions for lists can be used on it. next the keys are sorted in the line keys.sort(). for is used to go through all the keys. the grades are stored as a list inside the dictionary so the assignment grades = students[x] gives grades the list that is stored at the key x. the function print_grades just prints a list and is defined a few lines later. the later lines of the program implement the various options of the menu. the line students[name] = [0] * len(max_points) adds a student to the key of their name. the notation [0] * len(max_points) just creates a list of 0's that is the same length as the max_points list. the remove student entry just deletes a student similar to the telephone book example. the record grades choice is a little more complex. the grades are retrieved in the line grades = students[name] gets a reference to the grades of the student name. a grade is then recorded in the line grades[which] = grade. you may notice that grades is never put back into the students dictionary (as in no students[name] = grades). the reason for the missing statement is that grades is actually another name for students[name] and so changing grades changes student[name]. dictionaries provide an easy way to link keys to values. this can be used to easily keep track of data that is attached to various keys. non-programmer's tutorial for python 3 ← boolean expressions print version using modules → 14. using modules here's this chapter's typing exercise (name it cal.py (import actually looks for a file named calendar.py and reads it in. if the file is named calendar.py and it sees a "import calendar" it tries to read in itself which works poorly at best.)): import calendar year = int(input("type in the year number: ")) calendar.prcal(year) and here is part of the output i got: type in the year number: 2001 2001 january february march mo tu we th fr sa su mo tu we th fr sa su mo tu we th fr sa su 1 2 3 4 5 6 7 1 2 3 4 1 2 3 4 8 9 10 11 12 13 14 5 6 7 8 9 10 11 5 6 7 8 9 10 11 15 16 17 18 19 20 21 12 13 14 15 16 17 18 12 13 14 15 16 17 18 22 23 24 25 26 27 28 19 20 21 22 23 24 25 19 20 21 22 23 24 25 29 30 31 26 27 28 26 27 28 29 30 31 (i skipped some of the output, but i think you get the idea.) so what does the program do? the first line import calendar uses a new command import. the command import loads a module (in this case the calendar module). to see the commands available in the standard modules either look in the library reference for python (if you downloaded it) or go to http://docs.python.org/3/library/. if you look at the documentation for the calendar module, it lists a function called prcal that prints a calendar for a year. the line calendar.prcal(year) uses this function. in summary to use a module import it and then use module_name.function for functions in the module. another way to write the program is: from calendar import prcal year = int(input("type in the year number: ")) prcal(year) this version imports a specific function from a module. here is another program that uses the python library (name it something like clock.py) (press ctrl and the 'c' key at the same time to terminate the program): from time import time, ctime prev_time = "" while true: the_time = ctime(time()) if prev_time != the_time: print("the time is:", ctime(time())) prev_time = the_time with some output being: the time is: sun aug 20 13:40:04 2000 the time is: sun aug 20 13:40:05 2000 the time is: sun aug 20 13:40:06 2000 the time is: sun aug 20 13:40:07 2000 traceback (innermost last): file "clock.py", line 5, in ? the_time = ctime(time()) keyboardinterrupt the output is infinite of course so i cancelled it (or the output at least continues until ctrl+c is pressed). the program just does an infinite loop (true is always true, so while true: goes forever) and each time checks to see if the time has changed and prints it if it has. notice how multiple names after the import statement are used in the line from time import time, ctime. the python library contains many useful functions. these functions give your programs more abilities and many of them can simplify programming in python. exercises rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. solution rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. from random import randint number = randint(0, 99) guess = -1 while guess != number: guess = int(input ("guess a number: ")) if guess > number: print("too high") elif guess < number: print("too low") print("just right") other modules sometimes you want to use a python module that does not come with the python installation. you can also import those, but you have to have them installed on your computer. creating your own module when python reads the import command, it first checks files in your directory, then site-packages or pre installed modules. to make your own module, just create a .py file in the current directory and use the command: import module this will try to import the file module.py from your current directory and if not found, from site-packages and prepackaged modules. changing module to the name of the .py file you created will import that file. however, when it imports the module, it will basically start the file as a program, so any code on there will be run. you want to group all code into functions. the __name__ == __main__ trick in python, the variable __name__ will give you the current name of the program. if a module you import prints the __name__ variable, then it will print the name of the module. if the current file prints the __name__ variable, it will print __main__, to show it is the main program. if an if statement checks the name variable and runs code if the program is main, it can bypass the unintentional run problem created when a module is imported. say for example you have a file, which runs some code. it also has a function you want to use in another program. however, you only want the function, not to run the code. by setting up the code below, it will only run the code if it is the file that was clicked on or started, not if it was imported. if __name__ == '__main__': pass in this instance, if the file is run but not imported, it will run the pass command. you can replace the pass command with the code you want to be run when not imported. just remember to indent the code. the pip module the pip module is a module that comes with the python installation and acts as a module downloader/manager. you can download other modules from the internet with pip. the pip module is not used in the python interpreter, but is run through the command line. to use it, open up your command line interpreter (for windows it is command prompt, for mac/linux it is terminal) and type in the following code: py3 -m pip install module or the alternate code pip install module this will try to download and install module from the user-submitted python modules database. module can be changed to the name of the module. non-programmer's tutorial for python 3 ← dictionaries print version more on lists → 15. more on lists we have already seen lists and how they can be used. now that you have some more background i will go into more detail about lists. first we will look at more ways to get at the elements in a list and then we will talk about copying them. here are some examples of using indexing to access a single element of a list: >>> some_numbers = ['zero', 'one', 'two', 'three', 'four', 'five'] >>> some_numbers[0] 'zero' >>> some_numbers[4] 'four' >>> some_numbers[5] 'five' all those examples should look familiar to you. if you want the first item in the list just look at index 0. the second item is index 1 and so on through the list. however what if you want the last item in the list? one way could be to use the len() function like some_numbers[len(some_numbers) - 1]. this way works since the len() function always returns the last index plus one. the second from the last would then be some_numbers[len(some_numbers) - 2]. there is an easier way to do this. in python the last item is always index -1. the second to the last is index -2 and so on. here are some more examples: >>> some_numbers[len(some_numbers) - 1] 'five' >>> some_numbers[len(some_numbers) - 2] 'four' >>> some_numbers[-1] 'five' >>> some_numbers[-2] 'four' >>> some_numbers[-6] 'zero' thus any item in the list can be indexed in two ways: from the front and from the back. another useful way to get into parts of lists is using slicing. here is another example to give you an idea what they can be used for: >>> things = [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, "jack", "jill"] >>> things[0] 0 >>> things[7] 'jill' >>> things[0:8] [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, 'jack', 'jill'] >>> things[2:4] [2, 's.p.a.m.'] >>> things[4:7] ['stocking', 42, 'jack'] >>> things[1:5] ['fred', 2, 's.p.a.m.', 'stocking'] slicing is used to return part of a list. the slicing operator is in the form things[first_index:last_index]. slicing cuts the list before the first_index and before the last_index and returns the parts in between. you can use both types of indexing: >>> things[-4:-2] ['stocking', 42] >>> things[-4] 'stocking' >>> things[-4:6] ['stocking', 42] another trick with slicing is the unspecified index. if the first index is not specified the beginning of the list is assumed. if the last index is not specified the whole rest of the list is assumed. here are some examples: >>> things[:2] [0, 'fred'] >>> things[-2:] ['jack', 'jill'] >>> things[:3] [0, 'fred', 2] >>> things[:-5] [0, 'fred', 2] here is a (html inspired) program example (copy and paste in the poem definition if you want): poem = ["<b>", "jack", "and", "jill", "</b>", "went", "up", "the", "hill", "to", "<b>", "fetch", "a", "pail", "of", "</b>", "water.", "jack", "fell", "<b>", "down", "and", "broke", "</b>", "his", "crown", "and", "<b>", "jill", "came", "</b>", "tumbling", "after"] def get_bolds(text): true = 1 false = 0 ## is_bold tells whether or not we are currently looking at ## a bold section of text. is_bold = false ## start_block is the index of the start of either an unbolded ## segment of text or a bolded segment. start_block = 0 for index in range(len(text)): ## handle a starting of bold text if text[index] == "<b>": if is_bold: print("error: extra bold") ## print "not bold:", text[start_block:index] is_bold = true start_block = index + 1 ## handle end of bold text ## remember that the last number in a slice is the index ## after the last index used. if text[index] == "</b>": if not is_bold: print("error: extra close bold") print("bold [", start_block, ":", index, "]", text[start_block:index]) is_bold = false start_block = index + 1 get_bolds(poem) with the output being: bold [ 1 : 4 ] ['jack', 'and', 'jill'] bold [ 11 : 15 ] ['fetch', 'a', 'pail', 'of'] bold [ 20 : 23 ] ['down', 'and', 'broke'] bold [ 28 : 30 ] ['jill', 'came'] the get_bold() function takes in a list that is broken into words and tokens. the tokens that it looks for are <b> which starts the bold text and </b> which ends bold text. the function get_bold() goes through and searches for the start and end tokens. the next feature of lists is copying them. if you try something simple like: >>> a = [1, 2, 3] >>> b = a >>> print(b) [1, 2, 3] >>> b[1] = 10 >>> print(b) [1, 10, 3] >>> print(a) [1, 10, 3] this probably looks surprising since a modification to b resulted in a being changed as well. what happened is that the statement b = a makes b a reference to a. this means that b can be thought of as another name for a. hence any modification to b changes a as well. however some assignments don't create two names for one list: >>> a = [1, 2, 3] >>> b = a * 2 >>> print(a) [1, 2, 3] >>> print(b) [1, 2, 3, 1, 2, 3] >>> a[1] = 10 >>> print(a) [1, 10, 3] >>> print(b) [1, 2, 3, 1, 2, 3] in this case b is not a reference to a since the expression a * 2 creates a new list. then the statement b = a * 2 gives b a reference to a * 2 rather than a reference to a. all assignment operations create a reference. when you pass a list as an argument to a function you create a reference as well. most of the time you don't have to worry about creating references rather than copies. however when you need to make modifications to one list without changing another name of the list you have to make sure that you have actually created a copy. there are several ways to make a copy of a list. the simplest that works most of the time is the slice operator since it always makes a new list even if it is a slice of a whole list: >>> a = [1, 2, 3] >>> b = a[:] >>> b[1] = 10 >>> print(a) [1, 2, 3] >>> print(b) [1, 10, 3] taking the slice [:] creates a new copy of the list. however it only copies the outer list. any sublist inside is still a references to the sublist in the original list. therefore, when the list contains lists, the inner lists have to be copied as well. you could do that manually but python already contains a module to do it. you use the deepcopy function of the copy module: >>> import copy >>> a = [[1, 2, 3], [4, 5, 6]] >>> b = a[:] >>> c = copy.deepcopy(a) >>> b[0][1] = 10 >>> c[1][1] = 12 >>> print(a) [[1, 10, 3], [4, 5, 6]] >>> print(b) [[1, 10, 3], [4, 5, 6]] >>> print(c) [[1, 2, 3], [4, 12, 6]] first of all notice that a is a list of lists. then notice that when b[0][1] = 10 is run both a and b are changed, but c is not. this happens because the inner arrays are still references when the slice operator is used. however with deepcopy c was fully copied. so, should i worry about references every time i use a function or =? the good news is that you only have to worry about references when using dictionaries and lists. numbers and strings create references when assigned but every operation on numbers and strings that modifies them creates a new copy so you can never modify them unexpectedly. you do have to think about references when you are modifying a list or a dictionary. by now you are probably wondering why are references used at all? the basic reason is speed. it is much faster to make a reference to a thousand element list than to copy all the elements. the other reason is that it allows you to have a function to modify the inputed list or dictionary. just remember about references if you ever have some weird problem with data being changed when it shouldn't be. non-programmer's tutorial for python 3 ← using modules print version revenge of the strings → 16. revenge of the strings and now presenting a cool trick that can be done with strings: def shout(string): for character in string: print("gimme a " + character) print("'" + character + "'") shout("lose") def middle(string): print("the middle character is:", string[len(string) // 2]) middle("abcdefg") middle("the python programming language") middle("atlanta") and the output is: gimme a l 'l' gimme a o 'o' gimme a s 's' gimme a e 'e' the middle character is: d the middle character is: r the middle character is: a what these programs demonstrate is that strings are similar to lists in several ways. the shout() function shows that for loops can be used with strings just as they can be used with lists. the middle procedure shows that that strings can also use the len() function and array indexes and slices. most list features work on strings as well. the next feature demonstrates some string specific features: def to_upper(string): ## converts a string to upper case upper_case = "" for character in string: if 'a' <= character <= 'z': location = ord(character) - ord('a') new_ascii = location + ord('a') character = chr(new_ascii) upper_case = upper_case + character return upper_case print(to_upper("this is text")) with the output being: this is text this works because the computer represents the characters of a string as numbers from 0 to 1,114,111. for example 'a' is 65, 'b' is 66 and א is 1488. the values are the unicode value. python has a function called ord() (short for ordinal) that returns a character as a number. there is also a corresponding function called chr() that converts a number into a character. with this in mind the program should start to be clear. the first detail is the line: if 'a' <= character <= 'z': which checks to see if a letter is lower case. if it is then the next lines are used. first it is converted into a location so that a = 0, b = 1, c = 2 and so on with the line: location = ord(character) - ord('a'). next the new value is found with new_ascii = location + ord('a'). this value is converted back to a character that is now upper case. note that if you really need the upper case of a letter, you should use u=var.upper() which will work with other languages as well. now for some interactive typing exercise: >>> # integer to string >>> 2 2 >>> repr(2) '2' >>> -123 -123 >>> repr(-123) '-123' >>> # string to integer >>> "23" '23' >>> int("23") 23 >>> "23" * 2 '2323' >>> int("23") * 2 46 >>> # float to string >>> 1.23 1.23 >>> repr(1.23) '1.23' >>> # float to integer >>> 1.23 1.23 >>> int(1.23) 1 >>> int(-1.23) -1 >>> # string to float >>> float("1.23") 1.23 >>> "1.23" '1.23' >>> float("123") 123.0 if you haven't guessed already the function repr() can convert an integer to a string and the function int() can convert a string to an integer. the function float() can convert a string to a float. the repr() function returns a printable representation of something. here are some examples of this: >>> repr(1) '1' >>> repr(234.14) '234.14' >>> repr([4, 42, 10]) '[4, 42, 10]' the int() function tries to convert a string (or a float) into an integer. there is also a similar function called float() that will convert an integer or a string into a float. another function that python has is the eval() function. the eval() function takes a string and returns data of the type that python thinks it found. for example: >>> v = eval('123') >>> print(v, type(v)) 123 <type 'int'> >>> v = eval('645.123') >>> print(v, type(v)) 645.123 <type 'float'> >>> v = eval('[1, 2, 3]') >>> print(v, type(v)) [1, 2, 3] <type 'list'> if you use the eval() function you should check that it returns the type that you expect. one useful string function is the split() method. here's an example: >>> "this is a bunch of words".split() ['this', 'is', 'a', 'bunch', 'of', 'words'] >>> text = "first batch, second batch, third, fourth" >>> text.split(",") ['first batch', ' second batch', ' third', ' fourth'] notice how split() converts a string into a list of strings. the string is split by whitespace by default or by the optional argument (in this case a comma). you can also add another argument that tells split() how many times the separator will be used to split the text. for example: >>> list = text.split(",") >>> len(list) 4 >>> list[-1] ' fourth' >>> list = text.split(",", 2) >>> len(list) 3 >>> list[-1] ' third, fourth' slicing strings (and lists) strings can be cut into pieces — in the same way as it was shown for lists in the previous chapter — by using the slicing "operator" []. the slicing operator works in the same way as before: text[first_index:last_index] (in very rare cases there can be another colon and a third argument, as in the example shown below). in order not to get confused by the index numbers, it is easiest to see them as clipping places, possibilities to cut a string into parts. here is an example, which shows the clipping places (in yellow) and their index numbers (red and blue) for a simple text string: 0 1 2 ... -2 -1 ↓ ↓ ↓ ↓ ↓ ↓ ↓ text = " s t r i n g " ↑ ↑ [: :] note that the red indexes are counted from the beginning of the string and the blue ones from the end of the string backwards. (note that there is no blue -0, which could seem to be logical at the end of the string. because -0 == 0, -0 means "beginning of the string" as well.) now we are ready to use the indexes for slicing operations: text[1:4] → "tri" text[:5] → "strin" text[:-1] → "strin" text[-4:] → "ring" text[2] → "r" text[:] → "string" text[::-1] → "gnirts" text[1:4] gives us all of the text string between clipping places 1 and 4, "tri". if you omit one of the [first_index:last_index] arguments, you get the beginning or end of the string as default: text[:5] gives "strin". for both first_index and last_index we can use both the red and the blue numbering schema: text[:-1] gives the same as text[:5], because the index -1 is at the same place as 5 in this case. if we do not use an argument containing a colon, the number is treated in a different way: text[2] gives us one character following the second clipping point, "r". the special slicing operation text[:] means "from the beginning to the end" and produces a copy of the entire string (or list, as shown in the previous chapter). last but not least, the slicing operation can have a second colon and a third argument, which is interpreted as the "step size": text[::-1] is text from beginning to the end, with a step size of -1. -1 means "every character, but in the other direction". "string" backwards is "gnirts" (test a step length of 2, if you have not got the point here). all these slicing operations work with lists as well. in that sense strings are just a special case of lists, where the list elements are single characters. just remember the concept of clipping places, and the indexes for slicing things will get a lot less confusing. examples # this program requires an excellent understanding of decimal numbers. def to_string(in_int): """converts an integer to a string""" out_str = "" prefix = "" if in_int < 0: prefix = "-" in_int = -in_int while in_int // 10 != 0: out_str = str(in_int % 10) + out_str in_int = in_int // 10 out_str = str(in_int % 10) + out_str return prefix + out_str def to_int(in_str): """converts a string to an integer""" out_num = 0 if in_str[0] == "-": multiplier = -1 in_str = in_str[1:] else: multiplier = 1 for c in in_str: out_num = out_num * 10 + int(c) return out_num * multiplier print(to_string(2)) print(to_string(23445)) print(to_string(-23445)) print(to_int("14234")) print(to_int("12345")) print(to_int("-3512")) the output is: 2 23445 -23445 14234 12345 -3512 non-programmer's tutorial for python 3 ← more on lists print version file io → 17. file io file i/o here is a simple example of file i/o (input/output): # write a file with open("test.txt", "wt") as out_file: out_file.write("this text is going to out file\nlook at it and see!") # read a file with open("test.txt", "rt") as in_file: text = in_file.read() print(text) the output and the contents of the file test.txt are: this text is going to out file look at it and see! notice that it wrote a file called test.txt in the directory that you ran the program from. the \n in the string tells python to put a newline where it is. an overview of file i/o is: get a file object with the open function read or write to the file object (depending on how it was opened) if you did not use with to open the file, you'd have to close it manually the first step is to get a file object. the way to do this is to use the open function. the format is file_object = open(filename, mode) where file_object is the variable to put the file object, filename is a string with the filename, and mode is "rt" to read a file as text or "wt" to write a file as text (and a few others we will skip here). next the file objects functions can be called. the two most common functions are read and write. the write function adds a string to the end of the file. the read function reads the next thing in the file and returns it as a string. if no argument is given it will return the whole file (as done in the example). now here is a new version of the phone numbers program that we made earlier: def print_numbers(numbers): print("telephone numbers:") for k, v in numbers.items(): print("name:", k, "\tnumber:", v) print() def add_number(numbers, name, number): numbers[name] = number def lookup_number(numbers, name): if name in numbers: return "the number is " + numbers[name] else: return name + " was not found" def remove_number(numbers, name): if name in numbers: del numbers[name] else: print(name," was not found") def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. load numbers') print('6. save numbers') print('7. quit') print() phone_list = {} menu_choice = 0 print_menu() while true: menu_choice = int(input("type in a number (1-7): ")) if menu_choice == 1: print_numbers(phone_list) elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") add_number(phone_list, name, phone) elif menu_choice == 3: print("remove name and number") name = input("name: ") remove_number(phone_list, name) elif menu_choice == 4: print("lookup number") name = input("name: ") print(lookup_number(phone_list, name)) elif menu_choice == 5: filename = input("filename to load: ") load_numbers(phone_list, filename) elif menu_choice == 6: filename = input("filename to save: ") save_numbers(phone_list, filename) elif menu_choice == 7: break else: print_menu() print("goodbye") notice that it now includes saving and loading files. here is some output of my running it twice: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 2 add name and number name: jill number: 1234 type in a number (1-7): 2 add name and number name: fred number: 4321 type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 6 filename to save: numbers.txt type in a number (1-7): 7 goodbye 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 5 filename to load: numbers.txt type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 7 goodbye the new portions of this program are: def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() first we will look at the save portion of the program. first it creates a file object with the command open(filename, "wt"). next it goes through and creates a line for each of the phone numbers with the command out_file.write(k + "," + v + "\n"). this writes out a line that contains the name, a comma, the number and follows it by a newline. the loading portion is a little more complicated. it starts by getting a file object. then it uses a while true: loop to keep looping until a break statement is encountered. next it gets a line with the line in_line = in_file.readline(). the readline function will return an empty string when the end of the file is reached. the if statement checks for this and breaks out of the while loop when that happens. of course if the readline function did not return the newline at the end of the line there would be no way to tell if an empty string was an empty line or the end of the file so the newline is left in what readline returns. hence we have to get rid of the newline. the line in_line = in_line[:-1] does this for us by dropping the last character. next the line name, number = in_line.split(",") splits the line at the comma into a name and a number. this is then added to the numbers dictionary. advanced use of .txt files you might be saying to yourself, "well i know how to read and write to a textfile, but what if i want to print the file without opening out another program?" there are a few different ways to accomplish this. the easiest way does open another program, but everything is taken care of in the python code, and doesn't require the user to specify a file to be printed. this method involves invoking the subprocess of another program. remember the file we wrote output to in the above program? let's use that file. keep in mind, in order to prevent some errors, this program uses concepts from the next chapter. please feel free to revisit this example after the next chapter. import subprocess def main(): try: print("this small program invokes the print function in the notepad application") #lets print the file we created in the program above subprocess.call(['notepad','/p','numbers.txt']) except windowserror: print("the called subprocess does not exist, or cannot be called.") main() the subprocess.call takes three arguments. the first argument in the context of this example, should be the name of the program which you would like to invoke the printing subprocess from. the second argument should be the specific subprocess within that program. for simplicity, just understand that in this program, '/p' is the subprocess used to access your printer through the specified application. the last argument should be the name of the file you want to send to the printing subprocess. in this case, it is the same file used earlier in this chapter. exercises now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. solution now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = { } def load_grades(gradesfile): inputfile = open(gradesfile, "r") grades = [ ] while true: student_and_grade = inputfile.readline() student_and_grade = student_and_grade[:-1] if not student_and_grade: break else: studentname, studentgrades = student_and_grade.split(",") studentgrades = studentgrades.split(" ") students[studentname] = studentgrades inputfile.close() print("grades loaded.") def save_grades(gradesfile): outputfile = open(gradesfile, "w") for k, v in students.items(): outputfile.write(k + ",") for x in v: outputfile.write(str(x) + " ") outputfile.write("\n") outputfile.close() print("grades saved.") def print_menu(): print("1. add student") print("2. remove student") print("3. load grades") print("4. record grade") print("5. print grades") print("6. save grades") print("7. print menu") print("9. quit") def print_all_grades(): if students: keys = sorted(students.keys()) print('\t', end=' ') for x in assignments: print(x, '\t', end=' ') print() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) else: print("there are no grades to print.") def print_grades(grades): for x in grades: print(x, '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 9: print() menu_choice = int(input("menu choice: ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(assignments) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: gradesfile = input("load grades from which file? ") load_grades(gradesfile) elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i,x in enumerate(assignments): print(i + 1, x, '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 if 0 <= which < len(grades): grade = input("grade: ") # change from float(input()) to input() to avoid an error when saving grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice == 5: print_all_grades() elif menu_choice == 6: gradesfile = input("save grades to which file? ") save_grades(gradesfile) elif menu_choice != 9: print_menu() non-programmer's tutorial for python 3 ← revenge of the strings print version dealing with the imperfect → 18. dealing with the imperfect ...or how to handle errors closing files with with we use the "with" statement to open and close files.[1][2] with open("in_test.txt", "rt") as in_file: with open("out_test.txt", "wt") as out_file: text = in_file.read() data = parse(text) results = encode(data) out_file.write(results) print( "all done." ) if some sort of error happens anywhere in this code (one of the files is inaccessible, the parse() function chokes on corrupt data, etc.) the "with" statements guarantee that all the files will eventually be properly closed. closing a file just means that the file is "cleaned up" and "released" by our program so that it can be used in another program. to do: is the "closing files with with" section too much detail for a non-programmers tutorial? if so, move it to some other python wikibook (subject:python programming language) catching errors with try so you now have the perfect program, it runs flawlessly, except for one detail, it will crash on invalid user input. have no fear, for python has a special control structure for you. it's called try and it tries to do something. here is an example of a program with a problem: print("type control c or -1 to exit") number = 1 while number != -1: number = int(input("enter a number: ")) print("you entered:", number) notice how when you enter @#& it outputs something like: traceback (most recent call last): file "try_less.py", line 4, in <module> number = int(input("enter a number: ")) valueerror: invalid literal for int() with base 10: '\\@#&' as you can see the int() function is unhappy with the number @#& (as well it should be). the last line shows what the problem is; python found a valueerror. how can our program deal with this? what we do is first: put the place where errors may occur in a try block, and second: tell python how we want valueerrors handled. the following program does this: print("type control c or -1 to exit") number = 1 while number != -1: try: number = int(input("enter a number: ")) print("you entered:", number) except valueerror: print("that was not a number.") now when we run the new program and give it @#& it tells us "that was not a number." and continues with what it was doing before. when your program keeps having some error that you know how to handle, put code in a try block, and put the way to handle the error in the except block. exercises update at least the phone numbers program (in section dictionaries) so it doesn't crash if a user doesn't enter any data at the menu. solution def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: try: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() except valueerror: print("that was not a number.") non-programmer's tutorial for python 3 ← file io print version recursion → 19. the end so here we are at the end, or maybe the beginning. this tutorial is on wikibooks, so feel free to make improvements to it. if you want to learn more about python, the python tutorial by guido van rossum has more topics that you can learn about. if you have been following this tutorial, you should be able to understand a fair amount of it. the python programming wikibook can be worth looking at, too. here are few other books which cover python 3: a byte of python by swaroop c h datacamp interactive python 3 tutorial - online hands-on python tutorial by dr. andrew n. harrington subject:python programming language lists other wikibooks related to python. hopefully this book covers everything you have needed to get started programming. thanks to everyone who has sent me emails about it. i enjoyed reading them, even when i have not always been the best replier. happy programming, may it change your life and the world. non-programmer's tutorial for python 3 ← intro to imported libraries and other functions print version faq → 20. faq how do i make a gui in python? you can use one of these library: tkinter, pyqt, pygobject. for really simple graphics, you can use the turtle graphics mode import turtle how do i make a game in python? the best method is probably to use pygame at http://pygame.org/ how do i make an executable from a python program? short answer: python is an interepreted language so that is impossible. long answer is that something similar to an executable can be created by taking the python interpreter and the file and joining them together and distributing that. for more on that problem see http://www.python.org/doc/faq/programming/#how-can-i-create-a-stand-alone-binary-from-a-python-script (ifaq) why do you use first person in this tutorial? once upon a time in a different millenia, (1999 to be exact), an earlier version was written entirely by josh cogliati, and it was up on his webpage http://www.honors.montana.edu/~jjc/easytut and it was good. then the server rupert, like all good things than have a beginning came to an end, and josh moved it to wikibooks, but the first person writing stuck. if someone really wants to change it, i will not revert it, but i don't see much point. (the webpage has since moved to http://jjc.freeshell.org/easytut/ and http://jjc.freeshell.org/easytut3/ ) my question is not answered. ask on the discussion page or add it to this faq, or email one of the authors. for other faqs, you may want to see the python 2.6 version of this page non-programmer's tutorial for python 2.6/faq, or the python faq. non-programmer's tutorial for python 3 ← the end print version ↑ "the 'with' statement" ↑ 'the python "with" statement by example' retrieved from "https://en.wikibooks.org/w/index.php?title=non-programmer%27s_tutorial_for_python_3/print_version&oldid=3412786" this is the print version of non-programmer's tutorial for python 3you won't see this message or any elements not part of the book's content when you print or preview this page. non-programmer's tutorial for python 3 the current, editable version of this book is available in wikibooks, the open-content textbooks collection, at https://en.wikibooks.org/wiki/non-programmer%27s_tutorial_for_python_3 permission is granted to copy, distribute, and/or modify this document under the terms of the creative commons attribution-sharealike 3.0 license. contents 1 1. front matter 1.1 other resources 2 2. intro 2.1 first things first 2.2 installing python 2.2.1 linux, bsd, and unix users 2.2.2 mac users 2.2.3 windows users 2.2.3.1 configuring your path environment variable 2.3 interactive mode 2.4 creating and running programs 2.4.1 program file names 2.5 using python from the command line 2.5.1 running python programs in *nix 2.6 where to get help 2.6.1 python documentation 2.6.2 python user community 3 3. hello, world 3.1 what you should know 3.2 printing 3.2.1 terminology 3.2.2 \n in printing 3.3 expressions 3.3.1 arithmetic expressions 3.4 commenting in python 3.5 examples 3.6 exercises 3.6.1 footnotes 4 4. who goes there? 4.1 input and variables 4.2 assignment 4.3 examples 4.4 exercises 5 5. count to 10 5.1 while loops 5.1.1 infinite loops or never ending loop 5.2 examples 5.2.1 fibonacci sequence 5.2.2 enter password 5.3 exercises 6 6. decisions 6.1 if statement 6.2 examples 6.3 exercises 7 7. debugging 7.1 what is debugging? 7.2 what should the program do? 7.3 what does the program do? 7.4 how do i fix my program? 8 8. defining functions 8.1 creating functions 8.2 variables in functions 8.3 examples 8.4 exercises 9 9. advanced functions example 9.1 recursion 9.2 examples 10 10. lists 10.1 variables with more than one value 10.2 more features of lists 10.3 examples 10.4 exercises 11 11. for loops 12 12. boolean expressions 12.1 a note on boolean operators 12.2 examples 12.3 exercises 13 13. dictionaries 14 14. using modules 14.1 exercises 14.2 other modules 14.2.1 creating your own module 14.2.1.1 the __name__ == __main__ trick 14.2.2 the pip module 15 15. more on lists 16 16. revenge of the strings 16.1 slicing strings (and lists) 16.2 examples 17 17. file io 17.1 file i/o 17.2 advanced use of .txt files 17.3 exercises 18 18. dealing with the imperfect 18.1 ...or how to handle errors 18.2 closing files with with 18.3 catching errors with try 18.4 exercises 19 19. the end 20 20. faq 1. front matter all example python source code in this tutorial is granted to the public domain. therefore you may modify it and relicense it under any license you please. since you are expected to learn programming, the creative commons attribution-sharealike license would require you to keep all programs that are derived from the source code in this tutorial under that license. since the python source code is granted to the public domain, that requirement is waived. this tutorial is more or less a conversion of non-programmer's tutorial for python 2.6. older versions and some versions in korean, spanish, italian and greek are available from http://jjc.freeshell.org/easytut/ the non-programmers' tutorial for python 3 is a tutorial designed to be an introduction to the python programming language. this guide is for someone with no programming experience. if you have programmed in other languages i recommend using python tutorial for programmers written by guido van rossum. if you have any questions or comments please use the discussion pages or see authors page for author contact information. i welcome questions and comments about this tutorial. i will try to answer any questions you have as best i can. thanks go to james a. brown for writing most of the windows install info. thanks also to elizabeth cogliati for complaining enough :) about the original tutorial (that is almost unusable for a non-programmer), for proofreading, and for many ideas and comments on it. thanks to joe oppegaard for writing almost all the exercises. thanks to everyone i have missed. other resources python home page python 3 documentation a byte of python by swaroop c h porting to python 3: an in-depth guide non-programmer's tutorial for python 3 ← authors print version intro → 2. intro first things first so, you've never programmed before. as we go through this tutorial, i will attempt to teach you how to program. there really is only one way to learn to program. you must read code and write code (as computer programs are often called). i'm going to show you lots of code. you should type in code that i show you to see what happens. play around with it and make changes. the worst that can happen is that it won't work. when i type in code it will be formatted like this: # python is easy to learn print("hello, world!") that's so it is easy to distinguish from the other text. if you're reading this on the web, you'll notice the code is in color -- that's just to make it stand out, and to make the different parts of the code stand out from each other. the code you enter will probably not be colored, or the colors may be different, but it won't affect the code as long as you enter it the same way as it's printed here. if the computer prints something out it will be formatted like this: hello, world! (note that printed text goes to your screen, and does not involve paper. before computers had screens, the output of computer programs would be printed on paper.) note that this is a python 3 tutorial, which means that most of the examples will not work in python 2.7 and before. as well, all but a small number of the extra python 2.7 libraries (third-party libraries) have been converted to python 3. most likely you will want to learn python 3, but if you are learning python for a specific package or set of modules that are only written in python 2.7, you may want to consider learning from the non-programmer's tutorial for python 2.6. however, the differences between python 2 and 3 are not particularly large, so if you learn one, you should be able to read programs written for the other without much difficulty. there will often be a mixture of the text you type (which is shown in bold) and the text the program prints to the screen, which would look like this: halt! who goes there? josh you may pass, josh (some of the tutorial has not been converted to this format. since this is a wiki, you can convert it when you find it.) i will also introduce you to the terminology of programming - for example, that programming is often referred to as coding or hacking. this will not only help you understand what programmers are talking about, but also help the learning process. now, on to more important things. in order to program in python you need the python 3 software. if you don't already have the python software go to www.python.org/download and get the proper version for your platform. download it, read the instructions and get it installed. installing python for python programming you need a working python installation and a text editor. python comes with its own editor, idle, which is quite nice and totally sufficient for the beginning. as you get more into programming, you will probably switch to some other editor like nano, emacs, vi or another. the python download page is http://www.python.org/download. the most recent version is python 3.8.5 (as of july 2020); python 2.7 and older versions will not work with this tutorial. there are various different installation files for different computer platforms available on the download site. here are some specific instructions for the most common operating systems: linux, bsd, and unix users you are probably lucky and python is already installed on your machine. to test it type python3 on a command line. if you see something like what is shown in the following section, you are set. idle may need to be installed separately, from its own package such as idle3 or as part of python-tools. if you have to install python, first try to use the operating system's package manager or go to the repository where your packages are available and get python 3. python 3.0 was released in december 2008; all distributions should have python 3 available, so you may not need to compile it from scratch. ubuntu and fedora do have python 3 binary packages available, but they are not yet the default, so they need to be installed specially. roughly, here are the steps to compile python from source code in unix (if these totally don't make sense, you may want to read another introduction to *nix, such as introduction to linux): download the .tgz file (use your web browser to get the gzipped tar file from https://www.python.org/ftp/python/3.7.4/python-3.7.4.tgz) uncompress the tar file (put in the correct path to where you downloaded it): $ tar -xvzf ~/download/python-3.7.4.tgz ... list of files as they are uncompressed change to the directory and tell the computer to compile and install the program $ cd python-3.7/ $ ./configure --prefix=$home/python3_install ... lots of output. watch for error messages here ... $ make ... even more output. hopefully no error messages ... $ make install add python 3 to your path. you can test it first by specifying the full path. you should add $home/python3_install/bin to your path bash variable. $ ~/python3_install/bin/python3 python 3.7.4 (... size and date information ...) [gcc 9.1.0] on linux type "help", "copyright", "credits" or "license" for more information. >>> the above commands will install python 3 to your home directory, which is probably what you want, but if you skip the --prefix=$home/python3_install, it will install it to /usr/local. if you want to use the idle graphical code editor, you need to make sure that the tk and tcl libraries, together with their development files, are installed on the system. you will get a warning during the make phase if these are not available. mac users starting from mac os x tiger (10.4), versions of python 2 shipped with the operating system by default, but you will need to also install python 3 unless mac os starts including python 3 (check the version by starting python3 in a command line terminal). also idle (the python editor) might be missing in the standard installation. if you want to (re-)install python, get the mac os installer from the python download site. windows users download the appropriate windows installer (the x86 msi installer, if you do not have a 64-bit amd or intel chip). start the installer by double-clicking it and follow the prompts. see https://docs.python.org/3/using/windows.html#installing-python for more information. configuring your path environment variable the path environment variable is a list of folders, separated by semicolons, in which windows will look for a program whenever you try to execute one by typing its name at a command prompt. you can see the current value of your path by typing this command at a command prompt: echo %path% the easiest way to permanently change environment variables is to bring up the built-in environment variable editor in windows. how you get to this editor is slightly different on different versions of windows. on windows 8 or windows 10: press the windows key and type control panel to locate the windows control panel. once you've opened the control panel, select view by: large icons, then click on system. in the window that pops up, click the advanced system settings link, then click the environment variables... button. on windows 7 or vista: click the start button in the lower-left corner of the screen, move your mouse over computer, right-click, and select properties from the pop-up menu. click the advanced system settings link, then click the environment variables... button. once you've brought up the environment variable editor, you'll do the same thing regardless of which version of windows you're running. under system variables in the bottom half of the editor, find a variable called path. if there is is one, select it and click edit.... assuming your python root is c:\python37, add these two folders to your path (and make sure you get the semicolons right; there should be a semicolon between each folder in the list): c:\python37 c:\python37\scripts note: if you want to double-click and start your python programs from a windows folder and not have the console window disappear, you can add the following code to the bottom of each script: #stops console from exiting end_prog = "" while end_prog != "q": end_prog = input("type q to quit") interactive mode go into idle (also called the python gui). you should see a window that has some text like this: python 3.0 (r30:67503, dec 29 2008, 21:31:07) [gcc 4.3.2 20081105 (red hat 4.3.2-7)] on linux2 type "copyright", "credits" or "license()" for more information. **************************************************************** personal firewall software may warn about the connection idle makes to its subprocess using this computer's internal loopback interface. this connection is not visible on any external interface and no data is sent to or received from the internet. **************************************************************** idle 3.0 >>> the >>> is python's way of telling you that you are in interactive mode. in interactive mode what you type is immediately run. try typing 1+1 in. python will respond with 2. interactive mode allows you to test out and see what python will do. if you ever feel you need to play with new python statements, go into interactive mode and try them out. creating and running programs go into idle if you are not already. in the menu at the top, select file then new file. in the new window that appears, type the following: print("hello, world!") now save the program: select file from the menu, then save. save it as "hello.py" (you can save it in any folder you want). now that it is saved it can be run. next run the program by going to run then run module (or if you have an older version of idle use edit then run script). this will output hello, world! on the *python shell* window. for a more in-depth introduction to idle, a longer tutorial with screenshots can be found at http://hkn.eecs.berkeley.edu/~dyoo/python/idle_intro/index.html. program file names it is very useful to stick to some rules regarding the file names of python programs. otherwise some things might go wrong unexpectedly. these don't matter as much for programs, but you can have weird problems if you don't follow them for module names (modules will be discussed later). always save the program with the extension .py. do not put another dot anywhere else in the file name. only use standard characters for file names: letters, numbers, dash (-) and underscore (_). white space (" ") should not be used at all (use underscores instead). do not use anything other than a letter (particularly no numbers!) at the beginning of a file name. do not use "non-english" characters (such as å, ɓ, ç, ð, é, õ, ü) in your file names—or, even better, do not use them at all when programming. do not use module names for file names (such as print.py, math.py, list.py) using python from the command line if you don't want to use python from the command line, you don't have to, just use idle. to get into interactive mode just type python3 without any arguments. to run a program, create it with a text editor (emacs has a good python mode) and then run it with python3 program_name. running python programs in *nix if you are using unix (such as linux, mac os, or bsd), if you make the program executable with chmod, and have as the first line: #!/usr/bin/env python3 you can run the python program with ./hello.py like any other command. where to get help at some point in your python career you will probably get stuck and have no clue about how to solve the problem you are supposed to work on. this tutorial only covers the basics of python programming, but there is a lot of further information available. python documentation first of all, python is very well documented. there might even be copies of these documents on your computer that came with your python installation: the official python 3 tutorial by guido van rossum is often a good starting point for general questions. for questions about standard modules (you will learn what these are later), the python 3 library reference is the place to look. if you really want to get to know something about the details of the language, the python 3 reference manual is comprehensive but quite complex for beginners. python user community there are a lot of other python users out there, and usually they are nice and willing to help you. this very active user community is organised mostly through mailing lists and a newsgroup: the tutor mailing list is for folks who want to ask questions regarding how to learn computer programming with the python language. the python-help mailing list is python.org's help desk. you can ask a group of knowledgeable volunteers questions about all your python problems. the python newsgroup comp.lang.python (google groups archive) is the place for general python discussions, questions and the central meeting point of the community. python wiki has a list of local user groups, you can join the group mailing list and ask questions. you can also participate in the user group meetings. learnpython subreddit is another location where beginner level questions can be asked. in order not to reinvent the wheel and discuss the same questions again and again, people will appreciate very much if you do a web search for a solution to your problem before contacting these lists! non-programmer's tutorial for python 3 ← front matter print version hello, world → 3. hello, world what you should know once you've read and mastered this chapter, you should know how to edit programs in a text editor or idle, save them to the hard disk, and run them once they have been saved. printing programming tutorials since the beginning of time have started with a little program called "hello, world!"[1] so here it is: print("hello, world!") if you are using the command line to run programs then type it in with a text editor, save it as hello.py and run it with python3 hello.py otherwise go into idle, create a new window, and create the program as in section creating and running programs. when this program is run here's what it prints: hello, world! now i'm not going to tell you this every time, but when i show you a program i recommend that you type it in and run it. i learn better when i type it in and you probably do too. now here is a more complicated program: print("jack and jill went up a hill") print("to fetch a pail of water;") print("jack fell down, and broke his crown,") print("and jill came tumbling after.") when you run this program it prints out: jack and jill went up a hill to fetch a pail of water; jack fell down, and broke his crown, and jill came tumbling after. when the computer runs this program it first sees the line: print("jack and jill went up a hill") so the computer prints: jack and jill went up a hill then the computer goes down to the next line and sees: print("to fetch a pail of water;") so the computer prints to the screen: to fetch a pail of water; the computer keeps looking at each line, follows the command and then goes on to the next line. the computer keeps running commands until it reaches the end of the program. terminology now is probably a good time to give you a bit of an explanation of what is happening - and a little bit of programming terminology. what we were doing above was using a function called print. the function's name - print - is followed by parentheses containing zero or more arguments. so in this example print("hello, world!") there is one argument, which is "hello, world!". note that this argument is a group of characters enclosed in double quotes (""). this is commonly referred to as a string of characters, or string, for short. another example of a string is "jack and jill went up a hill". the combination of a function and parentheses with the arguments is a function call. a function and its arguments are one type of statement that python has, so print("hello, world!") is an example of a statement. basically, you can think of a statement as a single line in a program. that's probably more than enough terminology for now. \n in printing \n in printing makes the strings after the \n in a new line,here is an example: print("hello, world!\nwhat should i do?") here is the output: hello, world! what should i do? it can be used to put a bunch of strings that are supposed to be on different lines into 1 print statement instead of making multiple print statements expressions here is another program: print("2 + 2 is", 2 + 2) print("3 * 4 is", 3 * 4) print("100 - 1 is", 100 - 1) print("(33 + 2) / 5 + 11.5 is", (33 + 2) / 5 + 11.5) and here is the output when the program is run: 2 + 2 is 4 3 * 4 is 12 100 - 1 is 99 (33 + 2) / 5 + 11.5 is 18.5 as you can see, python can turn your thousand-dollar computer into a five-dollar calculator. arithmetic expressions in this example, the print function is followed by two arguments, with each of the arguments separated by a comma. so with the first line of the program print("2 + 2 is", 2 + 2) the first argument is the string "2 + 2 is" and the second argument is the arithmetic expression 2 + 2, which is one kind of expression. what is important to note is that a string is printed as is (without the enclosing double quotes), but an expression is evaluated, or converted to its actual value. python has seven basic operations for numbers: operation symbol example power (exponentiation) ** 5 ** 2 == 25 multiplication * 2 * 3 == 6 division / 14 / 3 == 4.666666666666667 integer division // 14 // 3 == 4 remainder (modulo) % 14 % 3 == 2 addition + 1 + 2 == 3 subtraction - 4 - 3 == 1 notice that there are two ways to do division, one that returns the repeating decimal, and the other that can get the remainder and the whole number. the order of operations is the same as in math: parentheses () exponents ** multiplication *, division /, integer division //, and remainder % addition + and subtraction - so use parentheses to structure your formulas when needed. commenting in python often in programming, you are doing something complicated and may not in the future remember what you did. when this happens the program should probably be commented. a comment is a note to you and other programmers explaining what is happening. for example: # not quite pi, but a credible simulation print(22 / 7) which outputs 3.14285714286 notice that the comment starts with a hash: #. comments are used to communicate with others who read the program and your future self to make clear what is complicated. note that any text can follow comment and that when the program is run, the text after the # through to the end of that line is ignored. the # does not have to be at the beginning of a new line: # output pi on the screen print(22 / 7) # well, just a good approximation examples each chapter (eventually) will contain examples of the programming features introduced in the chapter. you should at least look over them and see if you understand them. if you don't, you may want to type them in and see what happens. mess around with them, change them and see what happens. denmark.py print("something's rotten in the state of denmark.") print(" -- shakespeare") output: something's rotten in the state of denmark. -- shakespeare school.py # this is not quite true outside of usa # and is based on my dim memories of my younger years print("firstish grade") print("1 + 1 =", 1 + 1) print("2 + 4 =", 2 + 4) print("5 - 2 =", 5 - 2) print() print("thirdish grade") print("243 - 23 =", 243 - 23) print("12 * 4 =", 12 * 4) print("12 / 3 =", 12 / 3) print("13 / 3 =", 13 // 3, "r", 13 % 3) print() print("junior high") print("123.56 - 62.12 =", 123.56 - 62.12) print("(4 + 3) * 2 =", (4 + 3) * 2) print("4 + 3 * 2 =", 4 + 3 * 2) print("3 ** 2 =", 3 ** 2) output: firstish grade 1 + 1 = 2 2 + 4 = 6 5 - 2 = 3 thirdish grade 243 - 23 = 220 12 * 4 = 48 12 / 3 = 4 13 / 3 = 4 r 1 junior high 123.56 - 62.12 = 61.44 (4 + 3) * 2 = 14 4 + 3 * 2 = 10 3 ** 2 = 9 exercises write a program that prints your full name and your birthday as separate strings. write a program that shows the use of all 7 arithmetic operations. solution 1. write a program that prints your full name and your birthday as separate strings. print("ada lovelace", "born on", "november 27, 1852") print("albert einstein", "born on", "14 march 1879") print(("john smith"), ("born on"), ("14 march 1879")) solution 2. write a program that shows the use of all 7 arithmetic operations. print("5**5 = ", 5**5) print("6*7 = ", 6*7) print("56/8 = ", 56/8) print("14//6 = ", 14//6) print("14%6 = ", 14%6) print("5+6 = ", 5+6) print("9-0 = ", 9-0) footnotes ↑ here is a great list of the famous "hello, world!" program in many programming languages. just so you know how simple python can be... non-programmer's tutorial for python 3 ← intro print version who goes there? → 4. who goes there? input and variables now i feel it is time for a really complicated program. here it is: print("halt!") user_input = input("who goes there? ") print("you may pass,", user_input) when i ran it, here is what my screen showed: halt! who goes there? josh you may pass, josh note: after running the code by pressing f5, the python shell will only give output: halt! who goes there? you need to enter your name in the python shell, and then press enter for the rest of the output. of course when you run the program your screen will look different because of the input() statement. when you ran the program you probably noticed (you did run the program, right?) how you had to type in your name and then press enter. then the program printed out some more text and also your name. this is an example of input. the program reaches a certain point and then waits for the user to input some data that the program can use later. of course, getting information from the user would be useless if we didn't have anywhere to put that information and this is where variables come in. in the previous program user_input is a variable. variables are like a box that can store some piece of data. here is a program to show examples of variables: a = 123.4 b23 = 'spam' first_name = "bill" b = 432 c = a + b print("a + b is",c) print("first_name is",first_name) print("sorted parts, after midnight or",b23) and here is the output: a + b is 555.4 first_name is bill sorted parts, after midnight or spam variables store data. the variables in the above program are a, b23, first_name, b, and c. the two basic types are strings and numbers. strings are a sequence of letters, numbers and other characters. in this example b23 and first_name are variables that are storing strings. spam, bill, a + b is, first_name is, and sorted parts, after midnight or are the strings in this program. the characters are surrounded by " or '. the other type of variables are numbers. remember that variables are used to store a value, they do not use quotation marks (" and '). if you want to use an actual value, you must use quotation marks. value1 == pim value2 == "pim" both look the same, but in the first one python checks if the value stored in the variable value1 is the same as the value stored in the variable pim. in the second one, python checks if the string (the actual letters p,i, and m) are the same as in value2 (continue this tutorial for more explanation about strings and about the ==). assignment okay, so we have these boxes called variables and also data that can go into the variable. the computer will see a line like first_name = "bill" and it reads it as "put the string bill into the box (or variable) first_name". later on it sees the statement c = a + b and it reads it as "put the sum of a + b or 123.4 + 432 which equals 555.4 into c". the right hand side of the statement (a + b) is evaluated and the result is stored in the variable on the left hand side (c). this is called assignment, and you should not confuse the assignment equal sign (=) with "equality" in a mathematical sense here (that's what == will be used for later). here is another example of variable usage: a = 1 print(a) a = a + 1 print(a) a = a * 2 print(a) and of course here is the output: 1 2 4 even if the same variable appears on both sides of the equals sign (e.g., spam = spam), the computer still reads it as, "first find out the data to store and then find out where the data goes." one more program before i end this chapter: number = float(input("type in a number: ")) integer = int(input("type in an integer: ")) text = input("type in a string: ") print("number =", number) print("number is a", type(number)) print("number * 2 =", number * 2) print("integer =", integer) print("integer is a", type(integer)) print("integer * 2 =", integer * 2) print("text =", text) print("text is a", type(text)) print("text * 2 =", text * 2) the output i got was: type in a number: 12.34 type in an integer: -3 type in a string: hello number = 12.34 number is a <class 'float'> number * 2 = 24.68 integer = -3 integer is a <class 'int'> integer * 2 = -6 text = hello text is a <class 'str'> text * 2 = hellohello notice that number was created with float(input()) ,int(input()) returns an integer, a number with no decimal point, while text created with input() returns a string(can be writen as str(input()), too). when you want the user to type in a decimal use float(input()), if you want the user to type in an integer use int(input()), but if you want the user to type in a string use input(). the second half of the program uses the type() function which tells what kind a variable is. numbers are of type int or float, which are short for integer and floating point (mostly used for decimal numbers), respectively. text strings are of type str, short for string. integers and floats can be worked on by mathematical functions, strings cannot. notice how when python multiplies a number by an integer the expected thing happens. however when a string is multiplied by an integer the result is that multiple copies of the string are produced (i.e., text * 2 = hellohello). operations with strings do different things than operations with numbers. as well, some operations only work with numbers (both integers and floating point numbers) and will give an error if a string is used. here are some interactive mode examples to show that some more. >>> print("this" + " " + "is" + " joined.") this is joined. >>> print("ha, " * 5) ha, ha, ha, ha, ha, >>> print("ha, " * 5 + "ha!") ha, ha, ha, ha, ha, ha! >>> print(3 - 1) 2 >>> print("3" - "1") traceback (most recent call last): file "<stdin>", line 1, in <module> typeerror: unsupported operand type(s) for -: 'str' and 'str' >>> here is the list of some string operations: operation symbol example repetition * "i" * 5 == "iiiii" concatenation + "hello, " + "world!" == "hello, world!" examples rate_times.py # this program calculates rate and distance problems print("input a rate and a distance") rate = float(input("rate: ")) distance = float(input("distance: ")) time=(distance/ rate) print("time:", time) sample runs: input a rate and a distance rate: 5 distance: 10 time: 2.0 input a rate and a distance rate: 3.52 distance: 45.6 time: 12.9545454545 area.py # this program calculates the perimeter and area of a rectangle print("calculate information about a rectangle") length = float(input("length: ")) width = float(input("width: ")) perimeter=(2 * length + 2 * width) print("area:", length * width) print("perimeter:",perimeter) sample runs: calculate information about a rectangle length: 4 width: 3 area: 12.0 perimeter: 14.0 calculate information about a rectangle length: 2.53 width: 5.2 area: 13.156 perimeter: 15.46 temperature.py # this program converts fahrenheit to celsius fahr_temp = float(input("fahrenheit temperature: ")) celc_temp = (fahr_temp - 32.0) *( 5.0 / 9.0) print("celsius temperature:", celc_temp) sample runs: fahrenheit temperature: 32 celsius temperature: 0.0 fahrenheit temperature: -40 celsius temperature: -40.0 fahrenheit temperature: 212 celsius temperature: 100.0 fahrenheit temperature: 98.6 celsius temperature: 37.0 exercises write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. solution write a program that gets 2 string variables and 2 number variables from the user, concatenates (joins them together with no spaces) and displays the strings, then multiplies the two numbers on a new line. string1 = input('string 1: ') string2 = input('string 2: ') float1 = float(input('number 1: ')) float2 = float(input('number 2: ')) print(string1 + string2) print(float1 * float2) non-programmer's tutorial for python 3 ← hello, world print version count to 10 → 5. count to 10 while loops presenting our first control structure. ordinarily the computer starts with the first line and then goes down from there. control structures change the order that statements are executed or decide if a certain statement will be run. here's the source for a program that uses the while control structure: a = 0 # first, set the initial value of the variable a to 0(zero). while a < 10: # while the value of the variable a is less than 10 do the following: a = a + 1 # increase the value of the variable a by 1, as in: a = a + 1! print(a) # print to screen what the present value of the variable a is. # repeat! until the value of the variable a is equal to 9!? see note. # note: # the value of the variable a will increase by 1 # with each repeat, or loop of the 'while statement block'. # e.g. a = 1 then a = 2 then a = 3 etc. until a = 9 then... # the code will finish adding 1 to a (now a = 10), printing the # result, and then exiting the 'while statement block'. # -- # while a < 10: | # a = a + 1 |<--[ the while statement block ] # print (a) | # -- and here is the extremely exciting output: 1 2 3 4 5 6 7 8 9 10 (and you thought it couldn't get any worse after turning your computer into a five-dollar calculator?) so what does the program do? first it sees the line a = 0 and sets a to zero. then it sees while a < 10: and so the computer checks to see if a < 10. the first time the computer sees this statement, a is zero, so it is less than 10. in other words, as long as a is less than ten, the computer will run the tabbed in statements. this eventually makes a equal to ten (by adding one to a again and again) and the while a < 10 is not true any longer. reaching that point, the program will stop running the indented lines. always remember to put a colon ":" at the end of the while statement line! here is another example of the use of while: a = 1 s = 0 print('enter numbers to add to the sum.') print('enter 0 to quit.') while a != 0: print('current sum:', s) a = float(input('number? ')) s = s + a print('total sum =', s) enter numbers to add to the sum. enter 0 to quit. current sum: 0 number? 200 current sum: 200.0 number? -15.25 current sum: 184.75 number? -151.85 current sum: 32.9 number? 10.00 current sum: 42.9 number? 0 total sum = 42.9 notice how print('total sum =', s) is only run at the end. the while statement only affects the lines that are indented with whitespace. the != means does not equal so while a != 0: means as long as a is not zero run the tabbed statements that follow. note that a is a floating point number, and not all floating point numbers can be accurately represented, so using != on them can sometimes not work. try typing in 1.1 in interactive mode. infinite loops or never ending loop now that we have while loops, it is possible to have programs that run forever. an easy way to do this is to write a program like this: while 1 == 1: print("help, i'm stuck in a loop.") the "==" operator is used to test equality of the expressions on the two sides of the operator, just as "<" was used for "less than" before (you will get a complete list of all comparison operators in the next chapter). this program will output help, i'm stuck in a loop. until the heat death of the universe or you stop it, because 1 will forever be equal to 1. the way to stop it is to hit the control (or ctrl) button and c (the letter) at the same time. this will kill the program. (note: sometimes you will have to hit enter after the control-c.) on some systems, nothing will stop it, short of killing the process--so avoid! examples fibonacci sequence fibonacci-method1.py # this program calculates the fibonacci sequence a = 0 b = 1 count = 0 max_count = 20 while count < max_count: count = count + 1 print(a, end=" ") # notice the magic end=" " in the print function arguments # that keeps it from creating a new line. old_a = a # we need to keep track of a since we change it. a = b b = old_a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 note that the output is on a single line because of the extra argument end=" " in the print arguments. fibonacci-method2.py # simplified and faster method to calculate the fibonacci sequence a = 0 b = 1 count = 0 max_count = 10 while count < max_count: count = count + 1 print(a, b, end=" ") # notice the magic end=" " a = a + b b = a + b print() # gets a new (empty) line. output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 fibonacci-method3.py a = 0 b = 1 count = 0 maxcount = 20 #once loop is started we stay in it while count < maxcount: count += 1 olda = a a = a + b b = olda print(olda,end=" ") print() output: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 enter password password.py # waits until a password has been entered. use control-c to break out without # the password #note that this must not be the password so that the # while loop runs at least once. password = str() # note that != means not equal while password != "unicorn": password = input("password: ") print("welcome in") sample run: password: auo password: y22 password: password password: open sesame password: unicorn welcome in exercises write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. solution write a program that asks the user for a login name and password. then when they type "lock", they need to type in their name and password to unlock the program. name = input("what is your username: ") password = input("what is your password: ") print("to lock your computer type lock.") command = none input1 = none input2 = none while command != "lock": command = input("what is your command: ") while input1 != name: input1 = input("what is your username: ") while input2 != password: input2 = input("what is your password: ") print("welcome back to your system!") if you would like the program to run continuously, just add a while 1 == 1: loop around the whole thing. you will have to indent the rest of the program when you add this at the top of the code, but don't worry, you don't have to do it manually for each line! just highlight everything you want to indent and click on "indent" under "format" in the top bar of the python window. another way of doing this could be: name = input('set name: ') password = input('set password: ') while 1 == 1: nameguess="" passwordguess="" key="" while (nameguess != name) or (passwordguess != password): nameguess = input('name? ') passwordguess = input('password? ') print("welcome,", name, ". type lock to lock.") while key != "lock": key = input("") notice the or in while (nameguess != name) or (passwordguess != password), which we haven't yet introduced. you can probably figure out how it works. non-programmer's tutorial for python 3 ← who goes there? print version decisions → 6. decisions if statement as always, i believe i should start each chapter with a warm-up typing exercise, so here is a short program to compute the absolute value of an integer: n = int(input("number? ")) if n < 0: print("the absolute value of", n, "is", -n) else: print("the absolute value of", n, "is", n) here is the output from the two times that i ran this program: number? -34 the absolute value of -34 is 34 number? 1 the absolute value of 1 is 1 so what does the computer do when it sees this piece of code? first it prompts the user for a number with the statement "n = int(input("number? "))". next it reads the line "if n < 0:". if n is less than zero python runs the line "print("the absolute value of", n, "is", -n)". otherwise it runs the line "print("the absolute value of", n, "is", n)". more formally python looks at whether the expression n < 0 is true or false. an if statement is followed by an indented block of statements that are run when the expression is true. optionally after the if statement is an else statement and another indented block of statements. this second block of statements is run if the expression is false. there are a number of different tests that an expression can have. here is a table of all of them: operator function < less than <= less than or equal to > greater than >= greater than or equal to == equal != not equal another feature of the if command is the elif statement. it stands for else if and means if the original if statement is false but the elif part is true, then do the elif part. and if neither the if or elif expressions are true, then do what's in the else block. here's an example: a = 0 while a < 10: a = a + 1 if a > 5: print(a, ">", 5) elif a <= 3: print(a, "<=", 3) else: print("neither test was true") and the output: 1 <= 3 2 <= 3 3 <= 3 neither test was true neither test was true 6 > 5 7 > 5 8 > 5 9 > 5 10 > 5 notice how the elif a <= 3 is only tested when the if statement fails to be true. there can be more than one elif expression, allowing multiple tests to be done in a single if statement. examples # this program demonstrates the use of the == operator # using numbers print(5 == 6) # using variables x = 5 y = 8 print(x == y) and the output false false high_low.py # plays the guessing game higher or lower # this should actually be something that is semi random like the # last digits of the time or something else, but that will have to # wait till a later chapter. (extra credit, modify it to be random # after the modules chapter) number = 7 guess = -1 print("guess the number!") while guess != number: guess = int(input("is it... ")) if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") sample run: guess the number! is it... 2 it's bigger... is it... 5 it's bigger... is it... 10 it's not so big. is it... 7 hooray! you guessed it right! even.py # asks for a number. # prints if it is even or odd number = float(input("tell me a number: ")) if number % 2 == 0: print(int(number), "is even.") elif number % 2 == 1: print(int(number), "is odd.") else: print(number, "is very strange.") sample runs: tell me a number: 3 3 is odd. tell me a number: 2 2 is even. tell me a number: 3.4895 3.4895 is very strange. average1.py # keeps asking for numbers until 0 is entered. # prints the average value. count = 0 sum = 0.0 number = 1 # set to something that will not exit the while loop immediately. print("enter 0 to exit the loop") while number != 0: number = float(input("enter a number: ")) if number != 0: count = count + 1 sum = sum + number if number == 0: print("the average was:", sum / count) sample runs sample runs: enter 0 to exit the loop enter a number: 3 enter a number: 5 enter a number: 0 the average was: 4.0 enter 0 to exit the loop enter a number: 1 enter a number: 4 enter a number: 3 enter a number: 0 the average was: 2.66666666667 average2.py # keeps asking for numbers until count numbers have been entered. # prints the average value. #notice that we use an integer to keep track of how many numbers, # but floating point numbers for the input of each number sum = 0.0 print("this program will take several numbers then average them") count = int(input("how many numbers would you like to average: ")) current_count = 0 while current_count < count: current_count = current_count + 1 print("number", current_count) number = float(input("enter a number: ")) sum = sum + number print("the average was:", sum / count) sample runs: this program will take several numbers then average them how many numbers would you like to average: 2 number 1 enter a number: 3 number 2 enter a number: 5 the average was: 4.0 this program will take several numbers then average them how many numbers would you like to average: 3 number 1 enter a number: 1 number 2 enter a number: 4 number 3 enter a number: 3 the average was: 2.66666666667 exercises write a program that asks the user their name, if they enter your name say "that is a nice name", if they enter "john cleese" or "michael palin", tell them how you feel about them ;), otherwise tell them "you have a nice name." solution name = input('your name: ') if name == 'bryn': print('that is a nice name.') elif name == 'john cleese': print('... some funny text.') elif name == 'michael palin': print('... some funny text.') else: print('you have a nice name.') modify the higher or lower program from this section to keep track of how many times the user has entered the wrong number. if it is more than 3 times, print "that must have been complicated." at the end, otherwise print "good job!" solution number = 7 guess = -1 count = 0 print("guess the number!") while guess != number: guess = int(input("is it... ")) count = count + 1 if guess == number: print("hooray! you guessed it right!") elif guess < number: print("it's bigger...") elif guess > number: print("it's not so big.") if count > 3: print("that must have been complicated.") else: print("good job!") write a program that asks for two numbers. if the sum of the numbers is greater than 100, print "that is a big number." solution number1 = float(input('1st number: ')) number2 = float(input('2nd number: ')) if number1 + number2 > 100: print('that is a big number.') non-programmer's tutorial for python 3 ← count to 10 print version debugging → 7. debugging what is debugging? "as soon as we started programming, we found to our surprise that it wasn't as easy to get programs right as we had thought. debugging had to be discovered. i can remember the exact instant when i realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs." — maurice wilkes discovers debugging, 1949 by now if you have been messing around with the programs you have probably found that sometimes the program does something you didn't want it to do. this is fairly common. debugging is the process of figuring out what the computer is doing and then getting it to do what you want it to do. this can be tricky. i once spent nearly a week tracking down and fixing a bug that was caused by someone putting an x where a y should have been. this chapter will be more abstract than previous chapters. what should the program do? the first thing to do (this sounds obvious) is to figure out what the program should be doing if it is running correctly. come up with some test cases and see what happens. for example, let's say i have a program to compute the perimeter of a rectangle (the sum of the length of all the edges). i have the following test cases: height width perimeter 3 4 14 2 3 10 4 4 16 2 2 8 5 1 12 i now run my program on all of the test cases and see if the program does what i expect it to do. if it doesn't then i need to find out what the computer is doing. more commonly some of the test cases will work and some will not. if that is the case you should try and figure out what the working ones have in common. for example here is the output for a perimeter program (you get to see the code in a minute): height: 3 width: 4 perimeter = 15 height: 2 width: 3 perimeter = 11 height: 4 width: 4 perimeter = 16 height: 2 width: 2 perimeter = 8 height: 5 width: 1 perimeter = 8 notice that it didn't work for the first two inputs, it worked for the next two and it didn't work on the last one. try and figure out what is in common with the working ones. once you have some idea what the problem is finding the cause is easier. with your own programs you should try more test cases if you need them. what does the program do? the next thing to do is to look at the source code. one of the most important things to do while programming is reading source code. the primary way to do this is code walkthroughs. a code walkthrough starts at the first line, and works its way down until the program is done. while loops and if statements mean that some lines may never be run and some lines are run many times. at each line you figure out what python has done. lets start with the simple perimeter program. don't type it in, you are going to read it, not run it. the source code is: height = int(input("height: ")) width = int(input("width: ")) print("perimeter =", width + height + width + width) question: what is the first line python runs? answer: the first line is always run first. in this case it is: height = int(input("height: ")) what does that line do? prints height: , waits for the user to type a string in, and then converts the string to an integer variable height. what is the next line that runs? in general, it is the next line down which is: width = int(input("width: ")) what does that line do? prints width: , waits for the user to type a number in, and puts what the user types in the variable width. what is the next line that runs? when the next line is not indented more or less than the current line, it is the line right afterwards, so it is: print("perimeter = ", width + height + width + width) (it may also run a function in the current line, but that's a future chapter.) what does that line do? first it prints perimeter = , then it prints the sum of the values contained within the variables, width and height, from width + height + width + width. does width + height + width + width calculate the perimeter properly? let's see, perimeter of a rectangle is the bottom (width) plus the left side (height) plus the top (width) plus the right side (huh?). the last item should be the right side's length, or the height. do you understand why some of the times the perimeter was calculated "correctly"? it was calculated correctly when the width and the height were equal. the next program we will do a code walkthrough for is a program that is supposed to print out 5 dots on the screen. however, this is what the program is outputting: . . . . and here is the program: number = 5 while number > 1: print(".",end=" ") number = number - 1 print() this program will be more complex to walkthrough since it now has indented portions (or control structures). let us begin. what is the first line to be run? the first line of the file: number = 5 what does it do? puts the number 5 in the variable number. what is the next line? the next line is: while number > 1: what does it do? well, while statements in general look at their expression, and if it is true they do the next indented block of code, otherwise they skip the next indented block of code. so what does it do right now? if number > 1 is true then the next two lines will be run. so is number > 1? the last value put into number was 5 and 5 > 1 so yes. so what is the next line? since the while was true the next line is: print(".",end=" ") what does that line do? prints one dot and since the extra argument end=" " exists the next printed text will not be on a different screen line. what is the next line? number = number - 1 since that is following line and there are no indent changes. what does it do? it calculates number - 1, which is the current value of number (or 5) subtracts 1 from it, and makes that the new value of number. so basically it changes number's value from 5 to 4. what is the next line? well, the indent level decreases so we have to look at what type of control structure it is. it is a while loop, so we have to go back to the while clause which is while number > 1: what does it do? it looks at the value of number, which is 4, and compares it to 1 and since 4 > 1 the while loop continues. what is the next line? since the while loop was true, the next line is: print(".",end=" ") what does it do? it prints a second dot on the line, ending by a space. what is the next line? no indent change so it is: number = number - 1 and what does it do? it takes the current value of number (4), subtracts 1 from it, which gives it 3 and then finally makes 3 the new value of number. what is the next line? since there is an indent change caused by the end of the while loop, the next line is: while number > 1: what does it do? it compares the current value of number (3) to 1. 3 > 1 so the while loop continues. what is the next line? since the while loop condition was true the next line is: print(".",end=" ") and it does what? a third dot is printed on the line. what is the next line? it is: number = number - 1 what does it do? it takes the current value of number (3) subtracts from it 1 and makes the 2 the new value of number. what is the next line? back up to the start of the while loop: while number > 1: what does it do? it compares the current value of number (2) to 1. since 2 > 1 the while loop continues. what is the next line? since the while loop is continuing: print(".",end=" ") what does it do? it discovers the meaning of life, the universe and everything. i'm joking. (i had to make sure you were awake.) the line prints a fourth dot on the screen. what is the next line? it's: number = number - 1 what does it do? takes the current value of number (2) subtracts 1 and makes 1 the new value of number. what is the next line? back up to the while loop: while number > 1: what does the line do? it compares the current value of number (1) to 1. since 1 > 1 is false (one is not greater than one), the while loop exits. what is the next line? since the while loop condition was false the next line is the line after the while loop exits, or: print() what does that line do? makes the screen go to the next line. why doesn't the program print 5 dots? the loop exits 1 dot too soon. how can we fix that? make the loop exit 1 dot later. and how do we do that? there are several ways. one way would be to change the while loop to: while number > 0: another way would be to change the conditional to: number >= 1 there are a couple others. how do i fix my program? you need to figure out what the program is doing. you need to figure out what the program should do. figure out what the difference between the two is. debugging is a skill that has to be practiced to be learned. if you can't figure it out after an hour, take a break, talk to someone about the problem or contemplate the lint in your navel. come back in a while and you will probably have new ideas about the problem. good luck. non-programmer's tutorial for python 3 ← decisions print version defining functions → 8. defining functions creating functions to start off this chapter i am going to give you an example of what you could do but shouldn't (so don't type it in): a = 23 b = -23 if a < 0: a = -a if b < 0: b = -b if a == b: print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and 23 are equal. the program seems a little repetitive. programmers hate to repeat things -- that's what computers are for, after all! (note also that finding the absolute value changed the value of the variable, which is why it is printing out 23, and not -23 in the output.) fortunately python allows you to create functions to remove duplication. here is the rewritten example: a = 23 b = -23 def absolute_value(n): if n < 0: n = -n return n if absolute_value(a) == absolute_value(b): print("the absolute values of", a, "and", b, "are equal.") else: print("the absolute values of", a, "and", b, "are different.") with the output being: the absolute values of 23 and -23 are equal. the key feature of this program is the def statement. def (short for define) starts a function definition. def is followed by the name of the function absolute_value. next comes a '(' followed by the parameter n (n is passed from the program into the function when the function is called). the statements after the ':' are executed when the function is used. the statements continue until either the indented statements end or a return is encountered. the return statement returns a value back to the place where the function was called. we already have encountered a function in our very first program, the print function. now we can make new functions. notice how the values of a and b are not changed. functions can be used to repeat tasks that don't return values. here are some examples: def hello(): print("hello") def area(width, height): return width * height def print_welcome(name): print("welcome", name) hello() hello() print_welcome("fred") w = 4 h = 5 print("width =", w, " height =", h, " area =", area(w, h)) with output being: hello hello welcome fred width = 4 height = 5 area = 20 that example shows some more stuff that you can do with functions. notice that you can use no arguments or two or more. notice also when a function doesn't need to send back a value, a return is optional. variables in functions when eliminating repeated code, you often have variables in the repeated code. in python, these are dealt with in a special way. so far all variables we have seen are global variables. functions have a special type of variable called local variables. these variables only exist while the function is running. when a local variable has the same name as another variable (such as a global variable), the local variable hides the other. sound confusing? well, these next examples (which are a bit contrived) should help clear things up. a = 4 def print_func(): a = 17 print("in print_func a =", a) print_func() print("a = ", a) when run, we will receive an output of: in print_func a = 17 a = 4 variable assignments inside a function do not override global variables, they exist only inside the function. even though a was assigned a new value inside the function, this newly assigned value was only relevant to print_func, when the function finishes running, and the a's values is printed again, we see the originally assigned values. here is another more complex example. a_var = 10 b_var = 15 e_var = 25 def a_func(a_var): print("in a_func a_var =", a_var) b_var = 100 + a_var d_var = 2 * a_var print("in a_func b_var =", b_var) print("in a_func d_var =", d_var) print("in a_func e_var =", e_var) return b_var + 10 c_var = a_func(b_var) print("a_var =", a_var) print("b_var =", b_var) print("c_var =", c_var) print("d_var =", d_var) output: in a_func a_var = 15 in a_func b_var = 115 in a_func d_var = 30 in a_func e_var = 25 a_var = 10 b_var = 15 c_var = 125 d_var = traceback (most recent call last): file "c:\def2.py", line 19, in <module> print("d_var = ", d_var) nameerror: name 'd_var' is not defined in this example the variables a_var, b_var, and d_var are all local variables when they are inside the function a_func. after the statement return b_var + 10 is run, they all cease to exist. the variable a_var is automatically a local variable since it is a parameter name. the variables b_var and d_var are local variables since they appear on the left of an equals sign in the function in the statements b_var = 100 + a_var and d_var = 2 * a_var . inside of the function a_var has no value assigned to it. when the function is called with c_var = a_func(b_var), 15 is assigned to a_var since at that point in time b_var is 15, making the call to the function a_func(15). this ends up setting a_var to 15 when it is inside of a_func. as you can see, once the function finishes running, the local variables a_var and b_var that had hidden the global variables of the same name are gone. then the statement print("a_var = ", a_var) prints the value 10 rather than the value 15 since the local variable that hid the global variable is gone. another thing to notice is the nameerror that happens at the end. this appears since the variable d_var no longer exists since a_func finished. all the local variables are deleted when the function exits. if you want to get something from a function, then you will have to use return something. one last thing to notice is that the value of e_var remains unchanged inside a_func since it is not a parameter and it never appears on the left of an equals sign inside of the function a_func. when a global variable is accessed inside a function it is the global variable from the outside. functions allow local variables that exist only inside the function and can hide other variables that are outside the function. examples temperature2.py #! /usr/bin/python #-*-coding: utf-8 -*- # converts temperature to fahrenheit or celsius def print_options(): print("options:") print(" 'p' print options") print(" 'c' convert from celsius") print(" 'f' convert from fahrenheit") print(" 'q' quit the program") def celsius_to_fahrenheit(c_temp): return 9.0 / 5.0 * c_temp + 32 def fahrenheit_to_celsius(f_temp): return (f_temp - 32.0) * 5.0 / 9.0 choice = "p" while choice != "q": if choice == "c": c_temp = float(input("celsius temperature: ")) print("fahrenheit:", celsius_to_fahrenheit(c_temp)) choice = input("option: ") elif choice == "f": f_temp = float(input("fahrenheit temperature: ")) print("celsius:", fahrenheit_to_celsius(f_temp)) choice = input("option: ") else: choice = "p" #alternatively choice != "q": so that print #when anything unexpected inputed print_options() choice = input("option: ") sample run: options: 'p' print options 'c' convert from celsius 'f' convert from fahrenheit 'q' quit the program option: c celsius temperature: 30 fahrenheit: 86.0 option: f fahrenheit temperature: 60 celsius: 15.5555555556 option: q area2.py #! /usr/bin/python #-*-coding: utf-8 -*- # calculates a given rectangle area def hello(): print('hello!') def area(width, height): return width * height def print_welcome(name): print('welcome,', name) def positive_input(prompt): number = float(input(prompt)) while number <= 0: print('must be a positive number') number = float(input(prompt)) return number name = input('your name: ') hello() print_welcome(name) print() print('to find the area of a rectangle,') print('enter the width and height below.') print() w = positive_input('width: ') h = positive_input('height: ') print('width =', w, ' height =', h, ' so area =', area(w, h)) sample run: your name: josh hello! welcome, josh to find the area of a rectangle, enter the width and height below. width: -4 must be a positive number width: 4 height: 3 width = 4 height = 3 so area = 12 exercises rewrite the area2.py program from the examples above to have a separate function for the area of a square, the area of a rectangle, and the area of a circle (3.14 * radius**2). this program should include a menu interface. solution def square(l): return l * l def rectangle(width , height): return width * height def circle(radius): return 3.14159 * radius ** 2 def options(): print() print("options:") print("s = calculate the area of a square.") print("c = calculate the area of a circle.") print("r = calculate the area of a rectangle.") print("q = quit") print() print("this program will calculate the area of a square, circle or rectangle.") choice = "x" options() while choice != "q": choice = input("please enter your choice: ") if choice == "s": l = float(input("length of square side: ")) print("the area of this square is", square(l)) options() elif choice == "c": radius = float(input("radius of the circle: ")) print("the area of the circle is", circle(radius)) options() elif choice == "r": width = float(input("width of the rectangle: ")) height = float(input("height of the rectangle: ")) print("the area of the rectangle is", rectangle(width, height)) options() elif choice == "q": print(" ",end="") else: print("unrecognized option.") options() non-programmer's tutorial for python 3 ← debugging print version advanced functions example → 9. advanced functions example some people find this section useful, and some find it confusing. if you find it confusing you can skip it. now we will do a walk through for the following program: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value result = mult(3, 2) print("3 * 2 = ", result) basically this program creates a positive integer multiplication function (that is far slower than the built in multiplication function) and then demonstrates this function with a use of the function. this program demonstrates the use of recursion, that is a form of iteration (repetition) in which there is a function that repeatedly calls itself until an exit condition is satisfied. it uses repeated additions to give the same result as mutiplication: e.g. 3 + 3 (addition) gives the same result as 3 * 2 (multiplication). question: what is the first thing the program does? answer: the first thing done is the function mult is defined with the lines: def mult(a, b): if b == 0: return 0 rest = mult(a, b - 1) value = a + rest return value this creates a function that takes two parameters and returns a value when it is done. later this function can be run. what happens next? the next line after the function, result = mult(3, 2) is run. what does this line do? this line will assign the return value of mult(3, 2) to the variable result. and what does mult(3, 2) return? we need to do a walkthrough of the mult function to find out. what happens next? the variable a gets the value 3 assigned to it and the variable b gets the value 2 assigned to it. and then? the line if b == 0: is run. since b has the value 2 this is false so the line return 0 is skipped. and what then? the line rest = mult(a, b - 1) is run. this line sets the local variable rest to the value of mult(a, b - 1). the value of a is 3 and the value of b is 2 so the function call is mult(3,1) so what is the value of mult(3, 1) ? we will need to run the function mult with the parameters 3 and 1. so what happens next? the local variables in the new run of the function are set so that a has the value 3 and b has the value 1. since these are local values these do not affect the previous values of a and b. and then? since b has the value 1 the if statement is false, so the next line becomes rest = mult(a, b - 1). what does this line do? this line will assign the value of mult(3, 0) to rest. so what is that value? we will have to run the function one more time to find that out. this time a has the value 3 and b has the value 0. so what happens next? the first line in the function to run is if b == 0:. b has the value 0 so the next line to run is return 0 and what does the line return 0 do? this line returns the value 0 out of the function. so? so now we know that mult(3, 0) has the value 0. now we know what the line rest = mult(a, b - 1) did since we have run the function mult with the parameters 3 and 0. we have finished running mult(3, 0) and are now back to running mult(3, 1). the variable rest gets assigned the value 0. what line is run next? the line value = a + rest is run next. in this run of the function, a = 3 and rest = 0 so now value = 3. what happens next? the line return value is run. this returns 3 from the function. this also exits from the run of the function mult(3, 1). after return is called, we go back to running mult(3, 2). where were we in mult(3, 2)? we had the variables a = 3 and b = 2 and were examining the line rest = mult(a, b - 1). so what happens now? the variable rest get 3 assigned to it. the next line value = a + rest sets value to 3 + 3 or 6. so now what happens? the next line runs, this returns 6 from the function. we are now back to running the line result = mult(3, 2) which can now assign the value 6 to the variable result. what happens next? the next line after the function, print("3 * 2 = ", result) is run. and what does this do? it prints 3 * 2 = and the value of result which is 6. the complete line printed is 3 * 2 = 6. what is happening overall? basically we used two facts to calculate the multiple of the two numbers. the first is that any number times 0 is 0 (x * 0 = 0). the second is that a number times another number is equal to the first number plus the first number times one less than the second number (x * y = x + x * (y - 1)). so what happens is 3 * 2 is first converted into 3 + 3 * 1. then 3 * 1 is converted into 3 + 3 * 0. then we know that any number times 0 is 0 so 3 * 0 is 0. then we can calculate that 3 + 3 * 0 is 3 + 0 which is 3. now we know what 3 * 1 is so we can calculate that 3 + 3 * 1 is 3 + 3 which is 6. this is how the whole thing works: mult(3, 2) 3 + mult(3, 1) 3 + 3 + mult(3, 0) 3 + 3 + 0 3 + 3 6 recursion programming constructs solving a problem by solving a smaller version of the same problem are called recursive. in the examples in this chapter, recursion is realized by defining a function calling itself. this facilitates implementing solutions to programming tasks as it may be sufficient to consider the next step of a problem instead of the whole problem at once. it is also useful as it allows to express some mathematical concepts with straightforward, easy to read code. any problem that can be solved with recursion could be re-implemented with loops. using the latter usually results in better performance. however equivalent implementations using loops are usually harder to get done correctly. probably the most intuitive definition of recursion is: recursion if you still don't get it, see recursion. try walking through the factorial example if the multiplication example did not make sense. examples factorial.py #defines a function that calculates the factorial def factorial(n): if n == 0: return 1 if n<0: return "error, negative numbers do not have factorial values!!" return n * factorial(n - 1) print("2! =", factorial(2)) print("3! =", factorial(3)) print("4! =", factorial(4)) print("5! =", factorial(5)) print("-3! =", factorial(-3)) output: 2! = 2 3! = 6 4! = 24 5! = 120 -3! = error, negative values do not have factorial values!! countdown.py def count_down(n): print(n) if n > 0: return count_down(n-1) count_down(5) output: 5 4 3 2 1 0 non-programmer's tutorial for python 3 ← defining functions print version lists → 10. lists variables with more than one value you have already seen ordinary variables that store a single value. however other variable types can hold more than one value. these are called containers because they can contain more than one object. the simplest type is called a list. here is an example of a list being used: which_one = int(input("what month (1-12)? ")) months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'] if 1 <= which_one <= 12: print("the month is", months[which_one - 1]) and an output example: what month (1-12)? 3 the month is march in this example the months is a list. months is defined with the lines months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', and 'august', 'september', 'october', 'november', 'december'] (note that a \ could also be used to split a long line, but that is not necessary in this case because python is intelligent enough to recognize that everything within brackets belongs together). the [ and ] start and end the list with commas (,) separating the list items. the list is used in months[which_one - 1]. a list consists of items that are numbered starting at 0. in other words if you wanted january you would use months[0]. give a list a number and it will return the value that is stored at that location. the statement if 1 <= which_one <= 12: will only be true if which_one is between one and twelve inclusive (in other words it is what you would expect if you have seen that in algebra). lists can be thought of as a series of boxes. each box has a different value. for example, the boxes created by demolist = ['life', 42, 'the universe', 6, 'and', 9] would look like this: box number 0 1 2 3 4 5 demolist "life" 42 "the universe" 6 "and" 9 each box is referenced by its number so the statement demolist[0] would get 'life', demolist[1] would get 42 and so on up to demolist[5] getting 9. more features of lists the next example is just to show a lot of other stuff lists can do (for once i don't expect you to type it in, but you should probably play around with lists in interactive mode until you are comfortable with them.). here goes: demolist = ["life", 42, "the universe", 6, "and", 9] print("demolist = ",demolist) demolist.append("everything") print("after 'everything' was appended demolist is now:") print(demolist) print("len(demolist) =", len(demolist)) print("demolist.index(42) =", demolist.index(42)) print("demolist[1] =", demolist[1]) # next we will loop through the list for c in range(len(demolist)): print("demolist[", c, "] =", demolist[c]) del demolist[2] print("after 'the universe' was removed demolist is now:") print(demolist) if "life" in demolist: print("'life' was found in demolist") else: print("'life' was not found in demolist") if "amoeba" in demolist: print("'amoeba' was found in demolist") if "amoeba" not in demolist: print("'amoeba' was not found in demolist") another_list = [42,7,0,123] another_list.sort() print("the sorted another_list is", another_list) the output is: demolist = ['life', 42, 'the universe', 6, 'and', 9] after 'everything' was appended demolist is now: ['life', 42, 'the universe', 6, 'and', 9, 'everything'] len(demolist) = 7 demolist.index(42) = 1 demolist[1] = 42 demolist[ 0 ] = life demolist[ 1 ] = 42 demolist[ 2 ] = the universe demolist[ 3 ] = 6 demolist[ 4 ] = and demolist[ 5 ] = 9 demolist[ 6 ] = everything after 'the universe' was removed demolist is now: ['life', 42, 6, 'and', 9, 'everything'] 'life' was found in demolist 'amoeba' was not found in demolist the sorted another_list is [0, 7, 42, 123] this example uses a whole bunch of new functions. notice that you can just print a whole list. next the append function is used to add a new item to the end of the list. len returns how many items are in a list. the valid indexes (as in numbers that can be used inside of the []) of a list range from 0 to len - 1. the index function tells where the first location of an item is located in a list. notice how demolist.index(42) returns 1, and when demolist[1] is run it returns 42. to get help on all the functions a list provides for you, type help(list) in the interactive python interpreter. the line # next we will loop through the list is a just a reminder to the programmer (also called a comment). python ignores everything that is written after a # on the current line. next the lines: for c in range(len(demolist)): print('demolist[', c, '] =', demolist[c]) create a variable c, which starts at 0 and is incremented until it reaches the last index of the list. meanwhile the print statement prints out each element of the list. a much better way to do the above is: for c, x in enumerate(demolist): print("demolist[", c, "] =", x) the del command can be used to remove a given element in a list. the next few lines use the in operator to test if an element is in or is not in a list. the sort function sorts the list. this is useful if you need a list in order from smallest number to largest or alphabetical. note that this rearranges the list. in summary, for a list, the following operations occur: example explanation demolist[2] accesses the element at index 2 demolist[2] = 3 sets the element at index 2 to be 3 del demolist[2] removes the element at index 2 len(demolist) returns the length of demolist "value" in demolist is true if "value" is an element in demolist "value" not in demolist is true if "value" is not an element in demolist another_list.sort() sorts another_list. note that the list must be all numbers or all strings to be sorted. demolist.index("value") returns the index of the first place that "value" occurs demolist.append("value") adds an element "value" at the end of the list demolist.remove("value") removes the first occurrence of value from demolist (same as del demolist[demolist.index("value")]) this next example uses these features in a more useful way: menu_item = 0 namelist = [] while menu_item != 9: print("--------------------") print("1. print the list") print("2. add a name to the list") print("3. remove a name from the list") print("4. change an item in the list") print("9. quit") menu_item = int(input("pick an item from the menu: ")) if menu_item == 1: current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") elif menu_item == 2: name = input("type in a name to add: ") namelist.append(name) elif menu_item == 3: del_name = input("what name would you like to remove: ") if del_name in namelist: # namelist.remove(del_name) would work just as fine item_number = namelist.index(del_name) del namelist[item_number] # the code above only removes the first occurrence of # the name. the code below from gerald removes all. # while del_name in namelist: # item_number = namelist.index(del_name) # del namelist[item_number] else: print(del_name, "was not found") elif menu_item == 4: old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") print("goodbye") and here is part of the output: -------------------- 1. print the list 2. add a name to the list 3. remove a name from the list 4. change an item in the list 9. quit pick an item from the menu: 2 type in a name to add: jack pick an item from the menu: 2 type in a name to add: jill pick an item from the menu: 1 0 . jack 1 . jill pick an item from the menu: 3 what name would you like to remove: jack pick an item from the menu: 4 what name would you like to change: jill what is the new name: jill peters pick an item from the menu: 1 0 . jill peters pick an item from the menu: 9 goodbye that was a long program. let's take a look at the source code. the line namelist = [] makes the variable namelist a list with no items (or elements). the next important line is while menu_item != 9:. this line starts a loop that allows the menu system for this program. the next few lines display a menu and decide which part of the program to run. the section current = 0 if len(namelist) > 0: while current < len(namelist): print(current, ".", namelist[current]) current = current + 1 else: print("list is empty") goes through the list and prints each name. len(namelist) tells how many items are in the list. if len returns 0, then the list is empty. then, a few lines later, the statement namelist.append(name) appears. it uses the append function to add an item to the end of the list. jump down another two lines, and notice this section of code: item_number = namelist.index(del_name) del namelist[item_number] here the index function is used to find the index value that will be used later to remove the item. del namelist[item_number] is used to remove an element of the list. the next section old_name = input("what name would you like to change: ") if old_name in namelist: item_number = namelist.index(old_name) new_name = input("what is the new name: ") namelist[item_number] = new_name else: print(old_name, "was not found") uses index to find the item_number and then puts new_name where the old_name was. congratulations, with lists under your belt, you now know enough of the language that you could do any computations that a computer can do (this is technically known as turing-completeness). of course, there are still many features that are used to make your life easier. examples test.py ## this program runs a test of knowledge # first get the test questions # later this will be modified to use file io. def get_questions(): # notice how the data is stored as a list of lists return [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list # this function takes a list with two elements, a question and an answer. question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the tester's answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question #note that this is extracting a question and answer list from the list of lists. if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions),\ "% right out of", len(questions)) # now let's get the questions from the get_questions function, and # send the returned list of lists as an argument to the run_test function. run_test(get_questions()) the values true and false point to 1 and 0, respectively. they are often used in sanity checks, loop conditions etc. you will learn more about this a little bit later (chapter boolean expressions). please note that get_questions() is essentially a list because even though it's technically a function, returning a list of lists is the only thing it does. sample output: what color is the daytime sky on a clear day? green incorrect, correct was: blue what is the answer to life, the universe and everything? 42 correct what is a three letter word for mouse trap? cat correct you got 66 % right out of 3 exercises expand the test.py program so it has a menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". solution expand the test.py program so it has menu giving the option of taking the test, viewing the list of questions and answers, and an option to quit. also, add a new question to ask, "what noise does a truly advanced machine make?" with the answer of "ping". ## this program runs a test of knowledge questions = [["what color is the daytime sky on a clear day? ", "blue"], ["what is the answer to life, the universe and everything? ", "42"], ["what is a three letter word for mouse trap? ", "cat"], ["what noise does a truly advanced machine make?", "ping"]] # this will test a single question # it takes a single question in # it returns true if the user typed the correct answer, otherwise false def check_question(question_and_answer): # extract the question and the answer from the list question = question_and_answer[0] answer = question_and_answer[1] # give the question to the user given_answer = input(question) # compare the user's answer to the testers answer if answer == given_answer: print("correct") return true else: print("incorrect, correct was:", answer) return false # this will run through all the questions def run_test(questions): if len(questions) == 0: print("no questions were given.") # the return exits the function return index = 0 right = 0 while index < len(questions): # check the question if check_question(questions[index]): right = right + 1 # go to the next question index = index + 1 # notice the order of the computation, first multiply, then divide print("you got", right * 100 / len(questions), "% right out of", len(questions)) #showing a list of questions and answers def showquestions(): q = 0 while q < len(questions): a = 0 print("q:" , questions[q][a]) a = 1 print("a:" , questions[q][a]) q = q + 1 # now let's define the menu function def menu(): print("-----------------") print("menu:") print("1 - take the test") print("2 - view a list of questions and answers") print("3 - view the menu") print("5 - quit") print("-----------------") choice = "3" while choice != "5": if choice == "1": run_test(questions) elif choice == "2": showquestions() elif choice == "3": menu() print() choice = input("choose your option from the menu above: ") non-programmer's tutorial for python 3 ← advanced functions example print version for loops → 11. for loops and here is the new typing exercise for this chapter: onetoten = range(1, 11) for count in onetoten: print(count) and the ever-present output: 1 2 3 4 5 6 7 8 9 10 the output looks awfully familiar but the program code looks different. the first line uses the range function. the range function uses two arguments like this range(start, finish). start is the first number that is produced. finish is one larger than the last number. note that this program could have been done in a shorter way: for count in range(1, 11): print(count) the range function returns an iterable. this can be converted into a list with the list function. which will then be the dominant number. here are some examples to show what happens with the range command: >>> range(1, 10) range(1, 10) >>> list(range(1, 10)) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> list(range(-32, -20)) [-32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21] >>> list(range(5,21)) [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] >>> list(range(5)) [0, 1, 2, 3, 4] >>> list(range(21, 5)) [] the next line for count in onetoten: uses the for control structure. a for control structure looks like for variable in list:. list is gone through starting with the first element of the list and going to the last. as for goes through each element in a list it puts each into variable. that allows variable to be used in each successive time the for loop is run through. here is another example (you don't have to type this) to demonstrate: demolist = ['life', 42, 'the universe', 6, 'and', 7, 'everything'] for item in demolist: print("the current item is:",item) the output is: the current item is: life the current item is: 42 the current item is: the universe the current item is: 6 the current item is: and the current item is: 7 the current item is: everything notice how the for loop goes through and sets item to each element in the list. so, what is for good for? the first use is to go through all the elements of a list and do something with each of them. here's a quick way to add up all the elements: list = [2, 4, 6, 8] sum = 0 for num in list: sum = sum + num print("the sum is:", sum) with the output simply being: the sum is: 20 or you could write a program to find out if there are any duplicates in a list like this program does: list = [4, 5, 7, 8, 9, 1, 0, 7, 10] list.sort() prev = none for item in list: if prev == item: print("duplicate of", prev, "found") prev = item and for good measure: duplicate of 7 found okay, so how does it work? here is a special debugging version to help you understand (you don't need to type this in): l = [4, 5, 7, 8, 9, 1, 0, 7, 10] print("l = [4, 5, 7, 8, 9, 1, 0, 7, 10]", "\t\tl:", l) l.sort() print("l.sort()", "\t\tl:", l) prev = l[0] print("prev = l[0]", "\t\tprev:", prev) del l[0] print("del l[0]", "\t\tl:", l) for item in l: if prev == item: print("duplicate of", prev, "found") print("if prev == item:", "\t\tprev:", prev, "\titem:", item) prev = item print("prev = item", "\t\tprev:", prev, "\titem:", item) with the output being: l = [4, 5, 7, 8, 9, 1, 0, 7, 10] l: [4, 5, 7, 8, 9, 1, 0, 7, 10] l.sort() l: [0, 1, 4, 5, 7, 7, 8, 9, 10] prev = l[0] prev: 0 del l[0] l: [1, 4, 5, 7, 7, 8, 9, 10] if prev == item: prev: 0 item: 1 prev = item prev: 1 item: 1 if prev == item: prev: 1 item: 4 prev = item prev: 4 item: 4 if prev == item: prev: 4 item: 5 prev = item prev: 5 item: 5 if prev == item: prev: 5 item: 7 prev = item prev: 7 item: 7 duplicate of 7 found if prev == item: prev: 7 item: 7 prev = item prev: 7 item: 7 if prev == item: prev: 7 item: 8 prev = item prev: 8 item: 8 if prev == item: prev: 8 item: 9 prev = item prev: 9 item: 9 if prev == item: prev: 9 item: 10 prev = item prev: 10 item: 10 the reason i put so many print statements in the code was so that you can see what is happening in each line. (by the way, if you can't figure out why a program is not working, try putting in lots of print statements in places where you want to know what is happening.) first the program starts with a boring old list. next the program sorts the list. this is so that any duplicates get put next to each other. the program then initializes a prev(ious) variable. next the first element of the list is deleted so that the first item is not incorrectly thought to be a duplicate. next a for loop is gone into. each item of the list is checked to see if it is the same as the previous. if it is a duplicate was found. the value of prev is then changed so that the next time the for loop is run through prev is the previous item to the current. sure enough, the 7 is found to be a duplicate. (notice how \t is used to print a tab.) the other way to use for loops is to do something a certain number of times. here is some code to print out the first 9 numbers of the fibonacci series: a = 1 b = 1 for c in range(1, 10): print(a, end=" ") n = a + b a = b b = n with the surprising output: 1 1 2 3 5 8 13 21 34 everything that can be done with for loops can also be done with while loops but for loops give an easy way to go through all the elements in a list or to do something a certain number of times. non-programmer's tutorial for python 3 ← lists print version boolean expressions → 12. boolean expressions here is a little example of boolean expressions (you don't have to type it in): a = 6 b = 7 c = 42 print(1, a == 6) print(2, a == 7) print(3, a == 6 and b == 7) print(4, a == 7 and b == 7) print(5, not a == 7 and b == 7) print(6, a == 7 or b == 7) print(7, a == 7 or b == 6) print(8, not (a == 7 and b == 6)) print(9, not a == 7 and b == 6) with the output being: 1 true 2 false 3 true 4 false 5 true 6 true 7 false 8 true 9 false what is going on? the program consists of a bunch of funny looking print statements. each print statement prints a number and an expression. the number is to help keep track of which statement i am dealing with. notice how each expression ends up being either false or true. in python false can also be written as 0 and true as 1. the lines: print(1, a == 6) print(2, a == 7) print out a true and a false respectively just as expected since the first is true and the second is false. the third print, print(3, a == 6 and b == 7), is a little different. the operator and means if both the statement before and the statement after are true then the whole expression is true otherwise the whole expression is false. the next line, print(4, a == 7 and b == 7), shows how if part of an and expression is false, the whole thing is false. the behavior of and can be summarized as follows: expression result true and true true true and false false false and true false false and false false notice that if the first expression is false python does not check the second expression since it knows the whole expression is false. try running false and print("hi") and compare this to running true and print("hi") the technical term for this is short-circuit evaluation the next line, print(5, not a == 7 and b == 7), uses the not operator. not just gives the opposite of the expression. (the expression could be rewritten as print(5, a != 7 and b == 7)). here is the table: expression result not true false not false true the two following lines, print(6, a == 7 or b == 7) and print(7, a == 7 or b == 6), use the or operator. the or operator returns true if the first expression is true, or if the second expression is true or both are true. if neither are true it returns false. here's the table: expression result true or true true true or false true false or true true false or false false notice that if the first expression is true python doesn't check the second expression since it knows the whole expression is true. this works since or is true if at least one half of the expression is true. the first part is true so the second part could be either false or true, but the whole expression is still true. the next two lines, print(8, not (a == 7 and b == 6)) and print(9, not a == 7 and b == 6), show that parentheses can be used to group expressions and force one part to be evaluated first. notice that the parentheses changed the expression from false to true. this occurred since the parentheses forced the not to apply to the whole expression instead of just the a == 7 portion. here is an example of using a boolean expression: list = ["life", "the universe", "everything", "jack", "jill", "life", "jill"] # make a copy of the list. see the more on lists chapter to explain what [:] means. copy = list[:] # sort the copy copy.sort() prev = copy[0] del copy[0] count = 0 # go through the list searching for a match while count < len(copy) and copy[count] != prev: prev = copy[count] count = count + 1 # if a match was not found then count can't be < len # since the while loop continues while count is < len # and no match is found if count < len(copy): print("first match:", prev) and here is the output: first match: jill this program works by continuing to check for match while count < len(copy) and copy[count] is not equal to prev. when either count is greater than the last index of copy or a match has been found the and is no longer true so the loop exits. the if simply checks to make sure that the while exited because a match was found. the other "trick" of and is used in this example. if you look at the table for and notice that the third entry is "false and false". if count >= len(copy) (in other words count < len(copy) is false) then copy[count] is never looked at. this is because python knows that if the first is false then they can't both be true. this is known as a short circuit and is useful if the second half of the and will cause an error if something is wrong. i used the first expression (count < len(copy)) to check and see if count was a valid index for copy. (if you don't believe me remove the matches "jill" and "life", check that it still works and then reverse the order of count < len(copy) and copy[count] != prev to copy[count] != prev and count < len(copy).) boolean expressions can be used when you need to check two or more different things at once. a note on boolean operators a common mistake for people new to programming is a misunderstanding of the way that boolean operators works, which stems from the way the python interpreter reads these expressions. for example, after initially learning about "and " and "or" statements, one might assume that the expression x == ('a' or 'b') would check to see if the variable x was equivalent to one of the strings 'a' or 'b'. this is not so. to see what i'm talking about, start an interactive session with the interpreter and enter the following expressions: >>> 'a' == ('a' or 'b') >>> 'b' == ('a' or 'b') >>> 'a' == ('a' and 'b') >>> 'b' == ('a' and 'b') and this will be the unintuitive result: >>> 'a' == ('a' or 'b') true >>> 'b' == ('a' or 'b') false >>> 'a' == ('a' and 'b') false >>> 'b' == ('a' and 'b') true at this point, the and and or operators seem to be broken. it doesn't make sense that, for the first two expressions, 'a' is equivalent to 'a' or 'b' while 'b' is not. furthermore, it doesn't make any sense that 'b' is equivalent to 'a' and 'b'. after examining what the interpreter does with boolean operators, these results do in fact exactly what you are asking of them, it's just not the same as what you think you are asking. when the python interpreter looks at an or expression, it takes the first statement and checks to see if it is true. if the first statement is true, then python returns that object's value without checking the second statement. this is because for an or expression, the whole thing is true if one of the values is true; the program does not need to bother with the second statement. on the other hand, if the first value is evaluated as false python checks the second half and returns that value. that second half determines the truth value of the whole expression since the first half was false. this "laziness" on the part of the interpreter is called "short circuiting" and is a common way of evaluating boolean expressions in many programming languages. similarly, for an and expression, python uses a short circuit technique to speed truth value evaluation. if the first statement is false then the whole thing must be false, so it returns that value. otherwise if the first value is true it checks the second and returns that value. one thing to note at this point is that the boolean expression returns a value indicating true or false, but that python considers a number of different things to have a truth value assigned to them. to check the truth value of any given object x, you can use the function bool(x) to see its truth value. below is a table with examples of the truth values of various objects: true false true false 1 0 numbers other than zero the string 'none' nonempty strings empty strings nonempty lists empty lists nonempty dictionaries empty dictionaries now it is possible to understand the perplexing results we were getting when we tested those boolean expressions before. let's take a look at what the interpreter "sees" as it goes through that code: first case: >>> 'a' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'a' == 'a' # the string 'a' is equivalent to the string 'a', so expression is true true second case: >>> 'b' == ('a' or 'b') # look at parentheses first, so evaluate expression "('a' or 'b')" # 'a' is a nonempty string, so the first value is true # return that first value: 'a' >>> 'b' == 'a' # the string 'b' is not equivalent to the string 'a', so expression is false false third case: >>> 'a' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'a' == 'b' # the string 'a' is not equivalent to the string 'b', so expression is false false fourth case: >>> 'b' == ('a' and 'b') # look at parentheses first, so evaluate expression "('a' and 'b')" # 'a' is a nonempty string, so the first value is true, examine second value # 'b' is a nonempty string, so second value is true # return that second value as result of whole expression: 'b' >>> 'b' == 'b' # the string 'b' is equivalent to the string 'b', so expression is true true so python was really doing its job when it gave those apparently bogus results. as mentioned previously, the important thing is to recognize what value your boolean expression will return when it is evaluated, because it isn't always obvious. going back to those initial expressions, this is how you would write them out so they behaved in a way that you want: >>> 'a' == 'a' or 'a' == 'b' true >>> 'b' == 'a' or 'b' == 'b' true >>> 'a' == 'a' and 'a' == 'b' false >>> 'b' == 'a' and 'b' == 'b' false when these comparisons are evaluated they return truth values in terms of true or false, not strings, so we get the proper results. examples password1.py ## this program asks a user for a name and a password. # it then checks them to make sure that the user is allowed in. name = input("what is your name? ") password = input("what is the password? ") if name == "josh" and password == "friday": print("welcome josh") elif name == "fred" and password == "rock": print("welcome fred") else: print("i don't know you.") sample runs what is your name? josh what is the password? friday welcome josh what is your name? bill what is the password? money i don't know you. exercises write a program that has a user guess your name, but they only get 3 chances to do so until the program quits. solution print("try to guess my name!") count = 1 name = "guilherme" guess = input("what is my name? ") while count < 3 and guess.lower() != name: # .lower allows things like guilherme to still match print("you are wrong!") guess = input("what is my name? ") count = count + 1 if guess.lower() != name: print("you are wrong!") # this message isn't printed in the third chance, so we print it now print("you ran out of chances.") else: print("yes! my name is", name + "!") non-programmer's tutorial for python 3 ← for loops print version dictionaries → 13. dictionaries this chapter is about dictionaries. dictionaries have keys and values. the keys are used to find the values. here is an example of a dictionary in use: def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() and here is my output: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. quit type in a number (1-5): 2 add name and number name: joe number: 545-4464 type in a number (1-5): 2 add name and number name: jill number: 979-4654 type in a number (1-5): 2 add name and number name: fred number: 132-9874 type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 name: fred number: 132-9874 type in a number (1-5): 4 lookup number name: joe the number is 545-4464 type in a number (1-5): 3 remove name and number name: fred type in a number (1-5): 1 telephone numbers: name: jill number: 979-4654 name: joe number: 545-4464 type in a number (1-5): 5 this program is similar to the name list earlier in the chapter on lists. here's how the program works. first the function print_menu is defined. print_menu just prints a menu that is later used twice in the program. next comes the funny looking line numbers = {}. all that this line does is to tell python that numbers is a dictionary. the next few lines just make the menu work. the lines for x in numbers.keys(): print("name:", x, "\tnumber:", numbers[x]) go through the dictionary and print all the information. the function numbers.keys() returns a list that is then used by the for loop. the list returned by keys() is not in any particular order so if you want it in alphabetic order it must be sorted. similar to lists the statement numbers[x] is used to access a specific member of the dictionary. of course in this case x is a string. next the line numbers[name] = phone adds a name and phone number to the dictionary. if name had already been in the dictionary phone would replace whatever was there before. next the lines if name in numbers: del numbers[name] see if a name is in the dictionary and remove it if it is. the operator name in numbers returns true if name is in numbers but otherwise returns false. the line del numbers[name] removes the key name and the value associated with that key. the lines if name in numbers: print("the number is", numbers[name]) check to see if the dictionary has a certain key and if it does prints out the number associated with it. lastly if the menu choice is invalid it reprints the menu for your viewing pleasure. a recap: dictionaries have keys and values. keys can be strings or numbers. keys point to values. values can be any type of variable (including lists or even dictionaries (those dictionaries or lists of course can contain dictionaries or lists themselves (scary right? :-) ))). here is an example of using a list in a dictionary: max_points = [25, 25, 50, 25, 100] assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = {'#max': max_points} def print_menu(): print("1. add student") print("2. remove student") print("3. print grades") print("4. record grade") print("5. print menu") print("6. exit") def print_all_grades(): print('\t', end=' ') for i in range(len(assignments)): print(assignments[i], '\t', end=' ') print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) def print_grades(grades): for i in range(len(grades)): print(grades[i], '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 6: print() menu_choice = int(input("menu choice (1-6): ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(max_points) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: print_all_grades() elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i in range(len(assignments)): print(i + 1, assignments[i], '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 #same as which = which - 1 if 0 <= which < len(grades): grade = int(input("grade: ")) grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice != 6: print_menu() and here is a sample output: 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 menu choice (1-6): 5 1. add student 2. remove student 3. print grades 4. record grade 5. print menu 6. exit menu choice (1-6): 1 student to add: bill menu choice (1-6): 4 record grade student: bill type in the number of the grade to record type a 0 (zero) to exit 1 hw ch 1 2 hw ch 2 3 quiz 4 hw ch 3 5 test 0 0 0 0 0 change which grade: 1 grade: 25 change which grade: 2 grade: 24 change which grade: 3 grade: 45 change which grade: 4 grade: 23 change which grade: 5 grade: 95 change which grade: 0 menu choice (1-6): 3 hw ch 1 hw ch 2 quiz hw ch 3 test #max 25 25 50 25 100 bill 25 24 45 23 95 menu choice (1-6): 6 heres how the program works. basically the variable students is a dictionary with the keys being the name of the students and the values being their grades. the first two lines just create two lists. the next line students = {'#max': max_points} creates a new dictionary with the key {#max} and the value is set to be [25, 25, 50, 25, 100] (since thats what max_points was when the assignment is made) (i use the key #max since # is sorted ahead of any alphabetic characters). next print_menu is defined. next the print_all_grades function is defined in the lines: def print_all_grades(): print('\t',end=" ") for i in range(len(assignments)): print(assignments[i], '\t',end=" ") print() keys = list(students.keys()) keys.sort() for x in keys: print(x, '\t',end=' ') grades = students[x] print_grades(grades) notice how first the keys are gotten out of the students dictionary with the keys function in the line keys = list(students.keys()). keys is an iterable, and it is converted to list so all the functions for lists can be used on it. next the keys are sorted in the line keys.sort(). for is used to go through all the keys. the grades are stored as a list inside the dictionary so the assignment grades = students[x] gives grades the list that is stored at the key x. the function print_grades just prints a list and is defined a few lines later. the later lines of the program implement the various options of the menu. the line students[name] = [0] * len(max_points) adds a student to the key of their name. the notation [0] * len(max_points) just creates a list of 0's that is the same length as the max_points list. the remove student entry just deletes a student similar to the telephone book example. the record grades choice is a little more complex. the grades are retrieved in the line grades = students[name] gets a reference to the grades of the student name. a grade is then recorded in the line grades[which] = grade. you may notice that grades is never put back into the students dictionary (as in no students[name] = grades). the reason for the missing statement is that grades is actually another name for students[name] and so changing grades changes student[name]. dictionaries provide an easy way to link keys to values. this can be used to easily keep track of data that is attached to various keys. non-programmer's tutorial for python 3 ← boolean expressions print version using modules → 14. using modules here's this chapter's typing exercise (name it cal.py (import actually looks for a file named calendar.py and reads it in. if the file is named calendar.py and it sees a "import calendar" it tries to read in itself which works poorly at best.)): import calendar year = int(input("type in the year number: ")) calendar.prcal(year) and here is part of the output i got: type in the year number: 2001 2001 january february march mo tu we th fr sa su mo tu we th fr sa su mo tu we th fr sa su 1 2 3 4 5 6 7 1 2 3 4 1 2 3 4 8 9 10 11 12 13 14 5 6 7 8 9 10 11 5 6 7 8 9 10 11 15 16 17 18 19 20 21 12 13 14 15 16 17 18 12 13 14 15 16 17 18 22 23 24 25 26 27 28 19 20 21 22 23 24 25 19 20 21 22 23 24 25 29 30 31 26 27 28 26 27 28 29 30 31 (i skipped some of the output, but i think you get the idea.) so what does the program do? the first line import calendar uses a new command import. the command import loads a module (in this case the calendar module). to see the commands available in the standard modules either look in the library reference for python (if you downloaded it) or go to http://docs.python.org/3/library/. if you look at the documentation for the calendar module, it lists a function called prcal that prints a calendar for a year. the line calendar.prcal(year) uses this function. in summary to use a module import it and then use module_name.function for functions in the module. another way to write the program is: from calendar import prcal year = int(input("type in the year number: ")) prcal(year) this version imports a specific function from a module. here is another program that uses the python library (name it something like clock.py) (press ctrl and the 'c' key at the same time to terminate the program): from time import time, ctime prev_time = "" while true: the_time = ctime(time()) if prev_time != the_time: print("the time is:", ctime(time())) prev_time = the_time with some output being: the time is: sun aug 20 13:40:04 2000 the time is: sun aug 20 13:40:05 2000 the time is: sun aug 20 13:40:06 2000 the time is: sun aug 20 13:40:07 2000 traceback (innermost last): file "clock.py", line 5, in ? the_time = ctime(time()) keyboardinterrupt the output is infinite of course so i cancelled it (or the output at least continues until ctrl+c is pressed). the program just does an infinite loop (true is always true, so while true: goes forever) and each time checks to see if the time has changed and prints it if it has. notice how multiple names after the import statement are used in the line from time import time, ctime. the python library contains many useful functions. these functions give your programs more abilities and many of them can simplify programming in python. exercises rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. solution rewrite the high_low.py program from section decisions to use an random integer between 0 and 99 instead of the hard-coded 7. use the python documentation to find an appropriate module and function to do this. from random import randint number = randint(0, 99) guess = -1 while guess != number: guess = int(input ("guess a number: ")) if guess > number: print("too high") elif guess < number: print("too low") print("just right") other modules sometimes you want to use a python module that does not come with the python installation. you can also import those, but you have to have them installed on your computer. creating your own module when python reads the import command, it first checks files in your directory, then site-packages or pre installed modules. to make your own module, just create a .py file in the current directory and use the command: import module this will try to import the file module.py from your current directory and if not found, from site-packages and prepackaged modules. changing module to the name of the .py file you created will import that file. however, when it imports the module, it will basically start the file as a program, so any code on there will be run. you want to group all code into functions. the __name__ == __main__ trick in python, the variable __name__ will give you the current name of the program. if a module you import prints the __name__ variable, then it will print the name of the module. if the current file prints the __name__ variable, it will print __main__, to show it is the main program. if an if statement checks the name variable and runs code if the program is main, it can bypass the unintentional run problem created when a module is imported. say for example you have a file, which runs some code. it also has a function you want to use in another program. however, you only want the function, not to run the code. by setting up the code below, it will only run the code if it is the file that was clicked on or started, not if it was imported. if __name__ == '__main__': pass in this instance, if the file is run but not imported, it will run the pass command. you can replace the pass command with the code you want to be run when not imported. just remember to indent the code. the pip module the pip module is a module that comes with the python installation and acts as a module downloader/manager. you can download other modules from the internet with pip. the pip module is not used in the python interpreter, but is run through the command line. to use it, open up your command line interpreter (for windows it is command prompt, for mac/linux it is terminal) and type in the following code: py3 -m pip install module or the alternate code pip install module this will try to download and install module from the user-submitted python modules database. module can be changed to the name of the module. non-programmer's tutorial for python 3 ← dictionaries print version more on lists → 15. more on lists we have already seen lists and how they can be used. now that you have some more background i will go into more detail about lists. first we will look at more ways to get at the elements in a list and then we will talk about copying them. here are some examples of using indexing to access a single element of a list: >>> some_numbers = ['zero', 'one', 'two', 'three', 'four', 'five'] >>> some_numbers[0] 'zero' >>> some_numbers[4] 'four' >>> some_numbers[5] 'five' all those examples should look familiar to you. if you want the first item in the list just look at index 0. the second item is index 1 and so on through the list. however what if you want the last item in the list? one way could be to use the len() function like some_numbers[len(some_numbers) - 1]. this way works since the len() function always returns the last index plus one. the second from the last would then be some_numbers[len(some_numbers) - 2]. there is an easier way to do this. in python the last item is always index -1. the second to the last is index -2 and so on. here are some more examples: >>> some_numbers[len(some_numbers) - 1] 'five' >>> some_numbers[len(some_numbers) - 2] 'four' >>> some_numbers[-1] 'five' >>> some_numbers[-2] 'four' >>> some_numbers[-6] 'zero' thus any item in the list can be indexed in two ways: from the front and from the back. another useful way to get into parts of lists is using slicing. here is another example to give you an idea what they can be used for: >>> things = [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, "jack", "jill"] >>> things[0] 0 >>> things[7] 'jill' >>> things[0:8] [0, 'fred', 2, 's.p.a.m.', 'stocking', 42, 'jack', 'jill'] >>> things[2:4] [2, 's.p.a.m.'] >>> things[4:7] ['stocking', 42, 'jack'] >>> things[1:5] ['fred', 2, 's.p.a.m.', 'stocking'] slicing is used to return part of a list. the slicing operator is in the form things[first_index:last_index]. slicing cuts the list before the first_index and before the last_index and returns the parts in between. you can use both types of indexing: >>> things[-4:-2] ['stocking', 42] >>> things[-4] 'stocking' >>> things[-4:6] ['stocking', 42] another trick with slicing is the unspecified index. if the first index is not specified the beginning of the list is assumed. if the last index is not specified the whole rest of the list is assumed. here are some examples: >>> things[:2] [0, 'fred'] >>> things[-2:] ['jack', 'jill'] >>> things[:3] [0, 'fred', 2] >>> things[:-5] [0, 'fred', 2] here is a (html inspired) program example (copy and paste in the poem definition if you want): poem = ["<b>", "jack", "and", "jill", "</b>", "went", "up", "the", "hill", "to", "<b>", "fetch", "a", "pail", "of", "</b>", "water.", "jack", "fell", "<b>", "down", "and", "broke", "</b>", "his", "crown", "and", "<b>", "jill", "came", "</b>", "tumbling", "after"] def get_bolds(text): true = 1 false = 0 ## is_bold tells whether or not we are currently looking at ## a bold section of text. is_bold = false ## start_block is the index of the start of either an unbolded ## segment of text or a bolded segment. start_block = 0 for index in range(len(text)): ## handle a starting of bold text if text[index] == "<b>": if is_bold: print("error: extra bold") ## print "not bold:", text[start_block:index] is_bold = true start_block = index + 1 ## handle end of bold text ## remember that the last number in a slice is the index ## after the last index used. if text[index] == "</b>": if not is_bold: print("error: extra close bold") print("bold [", start_block, ":", index, "]", text[start_block:index]) is_bold = false start_block = index + 1 get_bolds(poem) with the output being: bold [ 1 : 4 ] ['jack', 'and', 'jill'] bold [ 11 : 15 ] ['fetch', 'a', 'pail', 'of'] bold [ 20 : 23 ] ['down', 'and', 'broke'] bold [ 28 : 30 ] ['jill', 'came'] the get_bold() function takes in a list that is broken into words and tokens. the tokens that it looks for are <b> which starts the bold text and </b> which ends bold text. the function get_bold() goes through and searches for the start and end tokens. the next feature of lists is copying them. if you try something simple like: >>> a = [1, 2, 3] >>> b = a >>> print(b) [1, 2, 3] >>> b[1] = 10 >>> print(b) [1, 10, 3] >>> print(a) [1, 10, 3] this probably looks surprising since a modification to b resulted in a being changed as well. what happened is that the statement b = a makes b a reference to a. this means that b can be thought of as another name for a. hence any modification to b changes a as well. however some assignments don't create two names for one list: >>> a = [1, 2, 3] >>> b = a * 2 >>> print(a) [1, 2, 3] >>> print(b) [1, 2, 3, 1, 2, 3] >>> a[1] = 10 >>> print(a) [1, 10, 3] >>> print(b) [1, 2, 3, 1, 2, 3] in this case b is not a reference to a since the expression a * 2 creates a new list. then the statement b = a * 2 gives b a reference to a * 2 rather than a reference to a. all assignment operations create a reference. when you pass a list as an argument to a function you create a reference as well. most of the time you don't have to worry about creating references rather than copies. however when you need to make modifications to one list without changing another name of the list you have to make sure that you have actually created a copy. there are several ways to make a copy of a list. the simplest that works most of the time is the slice operator since it always makes a new list even if it is a slice of a whole list: >>> a = [1, 2, 3] >>> b = a[:] >>> b[1] = 10 >>> print(a) [1, 2, 3] >>> print(b) [1, 10, 3] taking the slice [:] creates a new copy of the list. however it only copies the outer list. any sublist inside is still a references to the sublist in the original list. therefore, when the list contains lists, the inner lists have to be copied as well. you could do that manually but python already contains a module to do it. you use the deepcopy function of the copy module: >>> import copy >>> a = [[1, 2, 3], [4, 5, 6]] >>> b = a[:] >>> c = copy.deepcopy(a) >>> b[0][1] = 10 >>> c[1][1] = 12 >>> print(a) [[1, 10, 3], [4, 5, 6]] >>> print(b) [[1, 10, 3], [4, 5, 6]] >>> print(c) [[1, 2, 3], [4, 12, 6]] first of all notice that a is a list of lists. then notice that when b[0][1] = 10 is run both a and b are changed, but c is not. this happens because the inner arrays are still references when the slice operator is used. however with deepcopy c was fully copied. so, should i worry about references every time i use a function or =? the good news is that you only have to worry about references when using dictionaries and lists. numbers and strings create references when assigned but every operation on numbers and strings that modifies them creates a new copy so you can never modify them unexpectedly. you do have to think about references when you are modifying a list or a dictionary. by now you are probably wondering why are references used at all? the basic reason is speed. it is much faster to make a reference to a thousand element list than to copy all the elements. the other reason is that it allows you to have a function to modify the inputed list or dictionary. just remember about references if you ever have some weird problem with data being changed when it shouldn't be. non-programmer's tutorial for python 3 ← using modules print version revenge of the strings → 16. revenge of the strings and now presenting a cool trick that can be done with strings: def shout(string): for character in string: print("gimme a " + character) print("'" + character + "'") shout("lose") def middle(string): print("the middle character is:", string[len(string) // 2]) middle("abcdefg") middle("the python programming language") middle("atlanta") and the output is: gimme a l 'l' gimme a o 'o' gimme a s 's' gimme a e 'e' the middle character is: d the middle character is: r the middle character is: a what these programs demonstrate is that strings are similar to lists in several ways. the shout() function shows that for loops can be used with strings just as they can be used with lists. the middle procedure shows that that strings can also use the len() function and array indexes and slices. most list features work on strings as well. the next feature demonstrates some string specific features: def to_upper(string): ## converts a string to upper case upper_case = "" for character in string: if 'a' <= character <= 'z': location = ord(character) - ord('a') new_ascii = location + ord('a') character = chr(new_ascii) upper_case = upper_case + character return upper_case print(to_upper("this is text")) with the output being: this is text this works because the computer represents the characters of a string as numbers from 0 to 1,114,111. for example 'a' is 65, 'b' is 66 and א is 1488. the values are the unicode value. python has a function called ord() (short for ordinal) that returns a character as a number. there is also a corresponding function called chr() that converts a number into a character. with this in mind the program should start to be clear. the first detail is the line: if 'a' <= character <= 'z': which checks to see if a letter is lower case. if it is then the next lines are used. first it is converted into a location so that a = 0, b = 1, c = 2 and so on with the line: location = ord(character) - ord('a'). next the new value is found with new_ascii = location + ord('a'). this value is converted back to a character that is now upper case. note that if you really need the upper case of a letter, you should use u=var.upper() which will work with other languages as well. now for some interactive typing exercise: >>> # integer to string >>> 2 2 >>> repr(2) '2' >>> -123 -123 >>> repr(-123) '-123' >>> # string to integer >>> "23" '23' >>> int("23") 23 >>> "23" * 2 '2323' >>> int("23") * 2 46 >>> # float to string >>> 1.23 1.23 >>> repr(1.23) '1.23' >>> # float to integer >>> 1.23 1.23 >>> int(1.23) 1 >>> int(-1.23) -1 >>> # string to float >>> float("1.23") 1.23 >>> "1.23" '1.23' >>> float("123") 123.0 if you haven't guessed already the function repr() can convert an integer to a string and the function int() can convert a string to an integer. the function float() can convert a string to a float. the repr() function returns a printable representation of something. here are some examples of this: >>> repr(1) '1' >>> repr(234.14) '234.14' >>> repr([4, 42, 10]) '[4, 42, 10]' the int() function tries to convert a string (or a float) into an integer. there is also a similar function called float() that will convert an integer or a string into a float. another function that python has is the eval() function. the eval() function takes a string and returns data of the type that python thinks it found. for example: >>> v = eval('123') >>> print(v, type(v)) 123 <type 'int'> >>> v = eval('645.123') >>> print(v, type(v)) 645.123 <type 'float'> >>> v = eval('[1, 2, 3]') >>> print(v, type(v)) [1, 2, 3] <type 'list'> if you use the eval() function you should check that it returns the type that you expect. one useful string function is the split() method. here's an example: >>> "this is a bunch of words".split() ['this', 'is', 'a', 'bunch', 'of', 'words'] >>> text = "first batch, second batch, third, fourth" >>> text.split(",") ['first batch', ' second batch', ' third', ' fourth'] notice how split() converts a string into a list of strings. the string is split by whitespace by default or by the optional argument (in this case a comma). you can also add another argument that tells split() how many times the separator will be used to split the text. for example: >>> list = text.split(",") >>> len(list) 4 >>> list[-1] ' fourth' >>> list = text.split(",", 2) >>> len(list) 3 >>> list[-1] ' third, fourth' slicing strings (and lists) strings can be cut into pieces — in the same way as it was shown for lists in the previous chapter — by using the slicing "operator" []. the slicing operator works in the same way as before: text[first_index:last_index] (in very rare cases there can be another colon and a third argument, as in the example shown below). in order not to get confused by the index numbers, it is easiest to see them as clipping places, possibilities to cut a string into parts. here is an example, which shows the clipping places (in yellow) and their index numbers (red and blue) for a simple text string: 0 1 2 ... -2 -1 ↓ ↓ ↓ ↓ ↓ ↓ ↓ text = " s t r i n g " ↑ ↑ [: :] note that the red indexes are counted from the beginning of the string and the blue ones from the end of the string backwards. (note that there is no blue -0, which could seem to be logical at the end of the string. because -0 == 0, -0 means "beginning of the string" as well.) now we are ready to use the indexes for slicing operations: text[1:4] → "tri" text[:5] → "strin" text[:-1] → "strin" text[-4:] → "ring" text[2] → "r" text[:] → "string" text[::-1] → "gnirts" text[1:4] gives us all of the text string between clipping places 1 and 4, "tri". if you omit one of the [first_index:last_index] arguments, you get the beginning or end of the string as default: text[:5] gives "strin". for both first_index and last_index we can use both the red and the blue numbering schema: text[:-1] gives the same as text[:5], because the index -1 is at the same place as 5 in this case. if we do not use an argument containing a colon, the number is treated in a different way: text[2] gives us one character following the second clipping point, "r". the special slicing operation text[:] means "from the beginning to the end" and produces a copy of the entire string (or list, as shown in the previous chapter). last but not least, the slicing operation can have a second colon and a third argument, which is interpreted as the "step size": text[::-1] is text from beginning to the end, with a step size of -1. -1 means "every character, but in the other direction". "string" backwards is "gnirts" (test a step length of 2, if you have not got the point here). all these slicing operations work with lists as well. in that sense strings are just a special case of lists, where the list elements are single characters. just remember the concept of clipping places, and the indexes for slicing things will get a lot less confusing. examples # this program requires an excellent understanding of decimal numbers. def to_string(in_int): """converts an integer to a string""" out_str = "" prefix = "" if in_int < 0: prefix = "-" in_int = -in_int while in_int // 10 != 0: out_str = str(in_int % 10) + out_str in_int = in_int // 10 out_str = str(in_int % 10) + out_str return prefix + out_str def to_int(in_str): """converts a string to an integer""" out_num = 0 if in_str[0] == "-": multiplier = -1 in_str = in_str[1:] else: multiplier = 1 for c in in_str: out_num = out_num * 10 + int(c) return out_num * multiplier print(to_string(2)) print(to_string(23445)) print(to_string(-23445)) print(to_int("14234")) print(to_int("12345")) print(to_int("-3512")) the output is: 2 23445 -23445 14234 12345 -3512 non-programmer's tutorial for python 3 ← more on lists print version file io → 17. file io file i/o here is a simple example of file i/o (input/output): # write a file with open("test.txt", "wt") as out_file: out_file.write("this text is going to out file\nlook at it and see!") # read a file with open("test.txt", "rt") as in_file: text = in_file.read() print(text) the output and the contents of the file test.txt are: this text is going to out file look at it and see! notice that it wrote a file called test.txt in the directory that you ran the program from. the \n in the string tells python to put a newline where it is. an overview of file i/o is: get a file object with the open function read or write to the file object (depending on how it was opened) if you did not use with to open the file, you'd have to close it manually the first step is to get a file object. the way to do this is to use the open function. the format is file_object = open(filename, mode) where file_object is the variable to put the file object, filename is a string with the filename, and mode is "rt" to read a file as text or "wt" to write a file as text (and a few others we will skip here). next the file objects functions can be called. the two most common functions are read and write. the write function adds a string to the end of the file. the read function reads the next thing in the file and returns it as a string. if no argument is given it will return the whole file (as done in the example). now here is a new version of the phone numbers program that we made earlier: def print_numbers(numbers): print("telephone numbers:") for k, v in numbers.items(): print("name:", k, "\tnumber:", v) print() def add_number(numbers, name, number): numbers[name] = number def lookup_number(numbers, name): if name in numbers: return "the number is " + numbers[name] else: return name + " was not found" def remove_number(numbers, name): if name in numbers: del numbers[name] else: print(name," was not found") def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. load numbers') print('6. save numbers') print('7. quit') print() phone_list = {} menu_choice = 0 print_menu() while true: menu_choice = int(input("type in a number (1-7): ")) if menu_choice == 1: print_numbers(phone_list) elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") add_number(phone_list, name, phone) elif menu_choice == 3: print("remove name and number") name = input("name: ") remove_number(phone_list, name) elif menu_choice == 4: print("lookup number") name = input("name: ") print(lookup_number(phone_list, name)) elif menu_choice == 5: filename = input("filename to load: ") load_numbers(phone_list, filename) elif menu_choice == 6: filename = input("filename to save: ") save_numbers(phone_list, filename) elif menu_choice == 7: break else: print_menu() print("goodbye") notice that it now includes saving and loading files. here is some output of my running it twice: 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 2 add name and number name: jill number: 1234 type in a number (1-7): 2 add name and number name: fred number: 4321 type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 6 filename to save: numbers.txt type in a number (1-7): 7 goodbye 1. print phone numbers 2. add a phone number 3. remove a phone number 4. lookup a phone number 5. load numbers 6. save numbers 7. quit type in a number (1-7): 5 filename to load: numbers.txt type in a number (1-7): 1 telephone numbers: name: jill number: 1234 name: fred number: 4321 type in a number (1-7): 7 goodbye the new portions of this program are: def load_numbers(numbers, filename): in_file = open(filename, "rt") while true: in_line = in_file.readline() if not in_line: break in_line = in_line[:-1] name, number = in_line.split(",") numbers[name] = number in_file.close() def save_numbers(numbers, filename): out_file = open(filename, "wt") for k, v in numbers.items(): out_file.write(k + "," + v + "\n") out_file.close() first we will look at the save portion of the program. first it creates a file object with the command open(filename, "wt"). next it goes through and creates a line for each of the phone numbers with the command out_file.write(k + "," + v + "\n"). this writes out a line that contains the name, a comma, the number and follows it by a newline. the loading portion is a little more complicated. it starts by getting a file object. then it uses a while true: loop to keep looping until a break statement is encountered. next it gets a line with the line in_line = in_file.readline(). the readline function will return an empty string when the end of the file is reached. the if statement checks for this and breaks out of the while loop when that happens. of course if the readline function did not return the newline at the end of the line there would be no way to tell if an empty string was an empty line or the end of the file so the newline is left in what readline returns. hence we have to get rid of the newline. the line in_line = in_line[:-1] does this for us by dropping the last character. next the line name, number = in_line.split(",") splits the line at the comma into a name and a number. this is then added to the numbers dictionary. advanced use of .txt files you might be saying to yourself, "well i know how to read and write to a textfile, but what if i want to print the file without opening out another program?" there are a few different ways to accomplish this. the easiest way does open another program, but everything is taken care of in the python code, and doesn't require the user to specify a file to be printed. this method involves invoking the subprocess of another program. remember the file we wrote output to in the above program? let's use that file. keep in mind, in order to prevent some errors, this program uses concepts from the next chapter. please feel free to revisit this example after the next chapter. import subprocess def main(): try: print("this small program invokes the print function in the notepad application") #lets print the file we created in the program above subprocess.call(['notepad','/p','numbers.txt']) except windowserror: print("the called subprocess does not exist, or cannot be called.") main() the subprocess.call takes three arguments. the first argument in the context of this example, should be the name of the program which you would like to invoke the printing subprocess from. the second argument should be the specific subprocess within that program. for simplicity, just understand that in this program, '/p' is the subprocess used to access your printer through the specified application. the last argument should be the name of the file you want to send to the printing subprocess. in this case, it is the same file used earlier in this chapter. exercises now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. solution now modify the grades program from section dictionaries so that is uses file i/o to keep a record of the students. assignments = ['hw ch 1', 'hw ch 2', 'quiz ', 'hw ch 3', 'test'] students = { } def load_grades(gradesfile): inputfile = open(gradesfile, "r") grades = [ ] while true: student_and_grade = inputfile.readline() student_and_grade = student_and_grade[:-1] if not student_and_grade: break else: studentname, studentgrades = student_and_grade.split(",") studentgrades = studentgrades.split(" ") students[studentname] = studentgrades inputfile.close() print("grades loaded.") def save_grades(gradesfile): outputfile = open(gradesfile, "w") for k, v in students.items(): outputfile.write(k + ",") for x in v: outputfile.write(str(x) + " ") outputfile.write("\n") outputfile.close() print("grades saved.") def print_menu(): print("1. add student") print("2. remove student") print("3. load grades") print("4. record grade") print("5. print grades") print("6. save grades") print("7. print menu") print("9. quit") def print_all_grades(): if students: keys = sorted(students.keys()) print('\t', end=' ') for x in assignments: print(x, '\t', end=' ') print() for x in keys: print(x, '\t', end=' ') grades = students[x] print_grades(grades) else: print("there are no grades to print.") def print_grades(grades): for x in grades: print(x, '\t', end=' ') print() print_menu() menu_choice = 0 while menu_choice != 9: print() menu_choice = int(input("menu choice: ")) if menu_choice == 1: name = input("student to add: ") students[name] = [0] * len(assignments) elif menu_choice == 2: name = input("student to remove: ") if name in students: del students[name] else: print("student:", name, "not found") elif menu_choice == 3: gradesfile = input("load grades from which file? ") load_grades(gradesfile) elif menu_choice == 4: print("record grade") name = input("student: ") if name in students: grades = students[name] print("type in the number of the grade to record") print("type a 0 (zero) to exit") for i,x in enumerate(assignments): print(i + 1, x, '\t', end=' ') print() print_grades(grades) which = 1234 while which != -1: which = int(input("change which grade: ")) which -= 1 if 0 <= which < len(grades): grade = input("grade: ") # change from float(input()) to input() to avoid an error when saving grades[which] = grade elif which != -1: print("invalid grade number") else: print("student not found") elif menu_choice == 5: print_all_grades() elif menu_choice == 6: gradesfile = input("save grades to which file? ") save_grades(gradesfile) elif menu_choice != 9: print_menu() non-programmer's tutorial for python 3 ← revenge of the strings print version dealing with the imperfect → 18. dealing with the imperfect ...or how to handle errors closing files with with we use the "with" statement to open and close files.[1][2] with open("in_test.txt", "rt") as in_file: with open("out_test.txt", "wt") as out_file: text = in_file.read() data = parse(text) results = encode(data) out_file.write(results) print( "all done." ) if some sort of error happens anywhere in this code (one of the files is inaccessible, the parse() function chokes on corrupt data, etc.) the "with" statements guarantee that all the files will eventually be properly closed. closing a file just means that the file is "cleaned up" and "released" by our program so that it can be used in another program. to do: is the "closing files with with" section too much detail for a non-programmers tutorial? if so, move it to some other python wikibook (subject:python programming language) catching errors with try so you now have the perfect program, it runs flawlessly, except for one detail, it will crash on invalid user input. have no fear, for python has a special control structure for you. it's called try and it tries to do something. here is an example of a program with a problem: print("type control c or -1 to exit") number = 1 while number != -1: number = int(input("enter a number: ")) print("you entered:", number) notice how when you enter @#& it outputs something like: traceback (most recent call last): file "try_less.py", line 4, in <module> number = int(input("enter a number: ")) valueerror: invalid literal for int() with base 10: '\\@#&' as you can see the int() function is unhappy with the number @#& (as well it should be). the last line shows what the problem is; python found a valueerror. how can our program deal with this? what we do is first: put the place where errors may occur in a try block, and second: tell python how we want valueerrors handled. the following program does this: print("type control c or -1 to exit") number = 1 while number != -1: try: number = int(input("enter a number: ")) print("you entered:", number) except valueerror: print("that was not a number.") now when we run the new program and give it @#& it tells us "that was not a number." and continues with what it was doing before. when your program keeps having some error that you know how to handle, put code in a try block, and put the way to handle the error in the except block. exercises update at least the phone numbers program (in section dictionaries) so it doesn't crash if a user doesn't enter any data at the menu. solution def print_menu(): print('1. print phone numbers') print('2. add a phone number') print('3. remove a phone number') print('4. lookup a phone number') print('5. quit') print() numbers = {} menu_choice = 0 print_menu() while menu_choice != 5: try: menu_choice = int(input("type in a number (1-5): ")) if menu_choice == 1: print("telephone numbers:") for x in numbers.keys(): print("name: ", x, "\tnumber:", numbers[x]) print() elif menu_choice == 2: print("add name and number") name = input("name: ") phone = input("number: ") numbers[name] = phone elif menu_choice == 3: print("remove name and number") name = input("name: ") if name in numbers: del numbers[name] else: print(name, "was not found") elif menu_choice == 4: print("lookup number") name = input("name: ") if name in numbers: print("the number is", numbers[name]) else: print(name, "was not found") elif menu_choice != 5: print_menu() except valueerror: print("that was not a number.") non-programmer's tutorial for python 3 ← file io print version recursion → 19. the end so here we are at the end, or maybe the beginning. this tutorial is on wikibooks, so feel free to make improvements to it. if you want to learn more about python, the python tutorial by guido van rossum has more topics that you can learn about. if you have been following this tutorial, you should be able to understand a fair amount of it. the python programming wikibook can be worth looking at, too. here are few other books which cover python 3: a byte of python by swaroop c h datacamp interactive python 3 tutorial - online hands-on python tutorial by dr. andrew n. harrington subject:python programming language lists other wikibooks related to python. hopefully this book covers everything you have needed to get started programming. thanks to everyone who has sent me emails about it. i enjoyed reading them, even when i have not always been the best replier. happy programming, may it change your life and the world. non-programmer's tutorial for python 3 ← intro to imported libraries and other functions print version faq → 20. faq how do i make a gui in python? you can use one of these library: tkinter, pyqt, pygobject. for really simple graphics, you can use the turtle graphics mode import turtle how do i make a game in python? the best method is probably to use pygame at http://pygame.org/ how do i make an executable from a python program? short answer: python is an interepreted language so that is impossible. long answer is that something similar to an executable can be created by taking the python interpreter and the file and joining them together and distributing that. for more on that problem see http://www.python.org/doc/faq/programming/#how-can-i-create-a-stand-alone-binary-from-a-python-script (ifaq) why do you use first person in this tutorial? once upon a time in a different millenia, (1999 to be exact), an earlier version was written entirely by josh cogliati, and it was up on his webpage http://www.honors.montana.edu/~jjc/easytut and it was good. then the server rupert, like all good things than have a beginning came to an end, and josh moved it to wikibooks, but the first person writing stuck. if someone really wants to change it, i will not revert it, but i don't see much point. (the webpage has since moved to http://jjc.freeshell.org/easytut/ and http://jjc.freeshell.org/easytut3/ ) my question is not answered. ask on the discussion page or add it to this faq, or email one of the authors. for other faqs, you may want to see the python 2.6 version of this page non-programmer's tutorial for python 2.6/faq, or the python faq. non-programmer's tutorial for python 3 ← the end print version ↑ "the 'with' statement" ↑ 'the python "with" statement by example' retrieved from "https://en.wikibooks.org/w/index.php?title=non-programmer%27s_tutorial_for_python_3/print_version&oldid=3412786"